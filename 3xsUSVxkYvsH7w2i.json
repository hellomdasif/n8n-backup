{
  "active": true,
  "connections": {
    "Webhook": {
      "main": [
        [
          {
            "node": "username_check",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Respond to Webhook": {
      "main": [
        []
      ]
    },
    "username_check": {
      "main": [
        [
          {
            "node": "without_screen_overlay",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Million Views",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Edit Fields",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "set_public_link1",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Million Views",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "without_screen_overlay": {
      "main": [
        [
          {
            "node": "set_public_link",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Million Views": {
      "main": [
        [
          {
            "node": "set_public_link",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "set_public_link": {
      "main": [
        [
          {
            "node": "pre",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "data": {
      "main": [
        [
          {
            "node": "final_data",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "pre": {
      "main": [
        [
          {
            "node": "data",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "final_data": {
      "main": [
        [
          {
            "node": "Respond to Webhook",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "set_public_link1": {
      "main": [
        [
          {
            "node": "pre",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Reaction1": {
      "main": [
        [
          {
            "node": "set_public_link",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Edit Fields": {
      "main": [
        [
          {
            "node": "Reaction1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    }
  },
  "createdAt": "2025-10-17T10:42:40.289Z",
  "id": "3xsUSVxkYvsH7w2i",
  "isArchived": false,
  "meta": null,
  "name": "all-in-one-modify",
  "nodes": [
    {
      "parameters": {
        "path": "modify",
        "responseMode": "responseNode",
        "options": {}
      },
      "type": "n8n-nodes-base.webhook",
      "typeVersion": 2.1,
      "position": [
        -3264,
        -960
      ],
      "id": "fa647c75-b9a9-4a7b-adda-34e87d591c9c",
      "name": "Webhook",
      "webhookId": "df26a640-8e37-4602-abd2-bad4edc5ae0d"
    },
    {
      "parameters": {
        "respondWith": "allIncomingItems",
        "options": {}
      },
      "type": "n8n-nodes-base.respondToWebhook",
      "typeVersion": 1.4,
      "position": [
        -1456,
        -848
      ],
      "id": "a6c7426a-effe-46ac-b350-908e82cfc15c",
      "name": "Respond to Webhook"
    },
    {
      "parameters": {
        "rules": {
          "values": [
            {
              "conditions": {
                "options": {
                  "caseSensitive": true,
                  "leftValue": "",
                  "typeValidation": "strict",
                  "version": 2
                },
                "conditions": [
                  {
                    "leftValue": "={{ $json.body.username }}",
                    "rightValue": "GyaanManch",
                    "operator": {
                      "type": "string",
                      "operation": "equals"
                    },
                    "id": "e5028f49-1f95-4050-934d-a43f376c4543"
                  }
                ],
                "combinator": "and"
              },
              "renameOutput": true,
              "outputKey": "GyaanManch"
            },
            {
              "conditions": {
                "options": {
                  "caseSensitive": true,
                  "leftValue": "",
                  "typeValidation": "strict",
                  "version": 2
                },
                "conditions": [
                  {
                    "id": "5e7db562-4847-4e41-809f-fde144e57c37",
                    "leftValue": "={{ $json.body.username }}",
                    "rightValue": "knowsparkz",
                    "operator": {
                      "type": "string",
                      "operation": "equals",
                      "name": "filter.operator.equals"
                    }
                  }
                ],
                "combinator": "and"
              },
              "renameOutput": true,
              "outputKey": "knowsparkz"
            },
            {
              "conditions": {
                "options": {
                  "caseSensitive": true,
                  "leftValue": "",
                  "typeValidation": "strict",
                  "version": 2
                },
                "conditions": [
                  {
                    "id": "4d310438-a820-4d69-a1fc-6b9c06463c7e",
                    "leftValue": "={{ $json.body.username }}",
                    "rightValue": "ReelSense",
                    "operator": {
                      "type": "string",
                      "operation": "equals",
                      "name": "filter.operator.equals"
                    }
                  }
                ],
                "combinator": "and"
              },
              "renameOutput": true,
              "outputKey": "ReelSense"
            },
            {
              "conditions": {
                "options": {
                  "caseSensitive": true,
                  "leftValue": "",
                  "typeValidation": "strict",
                  "version": 2
                },
                "conditions": [
                  {
                    "id": "6e397b7a-8758-4b53-ba15-ba4fe09841dd",
                    "leftValue": "={{ $json.body.username }}",
                    "rightValue": "Tanvi_Kapoor_01",
                    "operator": {
                      "type": "string",
                      "operation": "equals",
                      "name": "filter.operator.equals"
                    }
                  }
                ],
                "combinator": "and"
              },
              "renameOutput": true,
              "outputKey": "Tanvi_Kapoor_01"
            },
            {
              "conditions": {
                "options": {
                  "caseSensitive": true,
                  "leftValue": "",
                  "typeValidation": "strict",
                  "version": 2
                },
                "conditions": [
                  {
                    "id": "2f0b374e-a4d3-4fd9-a79f-e09b3881bcf0",
                    "leftValue": "={{ $json.body.username }}",
                    "rightValue": "FactsMind_99",
                    "operator": {
                      "type": "string",
                      "operation": "equals",
                      "name": "filter.operator.equals"
                    }
                  }
                ],
                "combinator": "and"
              },
              "renameOutput": true,
              "outputKey": "FactsMind_99"
            }
          ]
        },
        "options": {}
      },
      "type": "n8n-nodes-base.switch",
      "typeVersion": 3.3,
      "position": [
        -3024,
        -1152
      ],
      "id": "66b7b5f3-92b1-469d-8ace-4fd5dfcde1e6",
      "name": "username_check"
    },
    {
      "parameters": {
        "command": "=ROOT=\"{{ $json.body.root_dir }}\"; \\\n$ROOT/script/views/views.sh \\\n  --output-dir $ROOT{{ $('Webhook').item.json.body.folder }}/output/ \\\n  --rand-min 10 \\\n  --rand-max 50 \\\n  --no-screenshot \\\n  $ROOT{{ $json.body.folder }}/{{ $json.body.filename }} \\\n  {{ $json.body.filename }} \\\n  2>&1 | grep -E \"^/.*\\.mp4$\""
      },
      "type": "n8n-nodes-base.executeCommand",
      "typeVersion": 1,
      "position": [
        -2608,
        -1040
      ],
      "id": "0c1040f0-639b-4464-9009-4fc65afe7a97",
      "name": "without_screen_overlay",
      "notes": "{{ $json.body.root_dir }}script/views/views.sh --output-dir {{ $json.body.root_dir }}script/views/output --rand-min 10 --rand-max 50 --no-screenshot --no-caption --no-emoji {{ $json.body.root_dir }}{{ $json.body.folder }}/{{ $json.body.filename }} {{ $json.body.filename }} 2>&1 | grep -E \"^/.*\\.mp4$\"\n"
    },
    {
      "parameters": {
        "command": "=ROOT=\"{{ $json.body.root_dir }}\"; \\\n$ROOT/script/views/views.sh \\\n  --output-dir $ROOT{{ $('Webhook').item.json.body.folder }}/output/ \\\n  --rand-min 10 \\\n  --rand-max 50 \\\n  $ROOT{{ $json.body.folder }}/{{ $json.body.filename }} \\\n  {{ $json.body.filename }} \\\n  2>&1 | grep -E \"^/.*\\.mp4$\""
      },
      "type": "n8n-nodes-base.executeCommand",
      "typeVersion": 1,
      "position": [
        -2592,
        -944
      ],
      "id": "f364fd87-2bec-40e2-8c1a-98ffde6a9f32",
      "name": "Million Views",
      "notes": "{{ $json.body.root_dir }}script/views/views.sh --output-dir {{ $json.body.root_dir }}script/views/output --rand-min 10 --rand-max 50 --no-screenshot --no-caption --no-emoji {{ $json.body.root_dir }}{{ $json.body.folder }}/{{ $json.body.filename }} {{ $json.body.filename }} 2>&1 | grep -E \"^/.*\\.mp4$\"\n"
    },
    {
      "parameters": {
        "command": "=#!/bin/bash\nset -eu\n\n# Fast Video Enhancement Script - Optimized for Speed\n# For n8n Execute Command Node\n\n# ============== CONFIGURATION ==============\n\n# Basic Input/Output - SET YOUR PATHS HERE\nINPUT_VIDEO=\"{{ $json.body.INPUT_VIDEO }}\"\nOUTPUT_VIDEO=\"{{ $json.body.OUTPUT_VIDEO }}\"\n\n# Speed Control (0.5 = half speed, 1.0 = normal, 2.0 = double speed)\nSPEED_FACTOR=\"1.1\"        # Slightly faster for engagement\n\n# Brightness (-1.0 to 1.0, where 0 = normal, positive = brighter, negative = darker)\nBRIGHTNESS=\"0.08\"          # Slightly brighter for pop\n\n# Contrast (0.0 to 4.0, where 1.0 = normal, >1.0 = more contrast, <1.0 = less contrast)\nCONTRAST=\"1.12\"            # Enhanced contrast for depth\n\n# Saturation (0.0 to 3.0, where 1.0 = normal, >1.0 = more saturated, <1.0 = less saturated)\nSATURATION=\"1.18\"          # More vibrant colors\n\n# Border Settings\nBORDER_ENABLE=true\nBORDER_SIZE=20            # 4px border as requested\nBORDER_COLOR=\"white\"       # Clean white border\n\n# Quality Settings - OPTIMIZED FOR SPEED\nCRF=\"25\"                   # Faster encoding (good quality)\nPRESET=\"ultrafast\"         # Fastest possible encoding\n\n# FFmpeg timeout\nFFMPEG_TIMEOUT=\"2m\"        # Short timeout for fast processing\n\n# ============== END CONFIGURATION ==============\n\necho \"=== Fast Video Enhancement ===\" >&2\necho \"Input: $INPUT_VIDEO\" >&2\necho \"Output: $OUTPUT_VIDEO\" >&2\n\n# Create output directory if it doesn't exist\nOUTPUT_DIR=$(dirname \"$OUTPUT_VIDEO\")\nmkdir -p \"$OUTPUT_DIR\"\n\n# Validate input file\nif [ ! -f \"$INPUT_VIDEO\" ]; then\n    echo \"ERROR: Input video file not found: $INPUT_VIDEO\" >&2\n    exit 1\nfi\n\n# Get video resolution for border calculation\nRESOLUTION=$(ffprobe -v error -select_streams v:0 -show_entries stream=width,height -of csv=p=0:s=x \"$INPUT_VIDEO\" 2>/dev/null || echo \"1920x1080\")\nWIDTH=$(echo \"$RESOLUTION\" | cut -d'x' -f1)\nHEIGHT=$(echo \"$RESOLUTION\" | cut -d'x' -f2)\n\necho \"Resolution: ${RESOLUTION}\" >&2\necho \"Starting fast video processing...\" >&2\n\n# Build filter chain - SIMPLIFIED FOR SPEED\nFILTERS=\"\"\n\n# Speed adjustment\nif [ \"$SPEED_FACTOR\" != \"1.0\" ]; then\n    FILTERS=\"${FILTERS}setpts=PTS/${SPEED_FACTOR},\"\n    echo \"Applying speed: ${SPEED_FACTOR}x\" >&2\nfi\n\n# Color adjustments - COMBINED FOR EFFICIENCY\nFILTERS=\"${FILTERS}eq=brightness=${BRIGHTNESS}:contrast=${CONTRAST}:saturation=${SATURATION},\"\necho \"Applying color enhancements\" >&2\n\n# Border (if enabled)\nif [ \"$BORDER_ENABLE\" = true ] && [ \"$BORDER_SIZE\" != \"0\" ]; then\n    NEW_WIDTH=$((WIDTH + 2 * BORDER_SIZE))\n    NEW_HEIGHT=$((HEIGHT + 2 * BORDER_SIZE))\n    FILTERS=\"${FILTERS}pad=${NEW_WIDTH}:${NEW_HEIGHT}:${BORDER_SIZE}:${BORDER_SIZE}:${BORDER_COLOR},\"\n    echo \"Applying border: ${BORDER_SIZE}px ${BORDER_COLOR}\" >&2\nfi\n\n# Remove trailing comma\nFILTERS=$(echo \"$FILTERS\" | sed 's/,$//')\n\n# Audio processing\nAUDIO_FILTERS=\"\"\nif [ \"$SPEED_FACTOR\" != \"1.0\" ]; then\n    AUDIO_FILTERS=\"atempo=${SPEED_FACTOR}\"\nfi\n\n# Build and execute FFmpeg command - OPTIMIZED FOR SPEED\necho \"Processing with ultrafast settings...\" >&2\n\nif [ -n \"$AUDIO_FILTERS\" ]; then\n    # With audio speed adjustment\n    timeout \"$FFMPEG_TIMEOUT\" ffmpeg -y -hide_banner -loglevel error \\\n        -i \"$INPUT_VIDEO\" \\\n        -vf \"$FILTERS\" \\\n        -af \"$AUDIO_FILTERS\" \\\n        -c:v libx264 -crf \"$CRF\" -preset \"$PRESET\" -threads 0 \\\n        -c:a aac -b:a 128k \\\n        -movflags +faststart \\\n        \"$OUTPUT_VIDEO\"\nelse\n    # No audio adjustment needed\n    timeout \"$FFMPEG_TIMEOUT\" ffmpeg -y -hide_banner -loglevel error \\\n        -i \"$INPUT_VIDEO\" \\\n        -vf \"$FILTERS\" \\\n        -c:v libx264 -crf \"$CRF\" -preset \"$PRESET\" -threads 0 \\\n        -c:a copy \\\n        -movflags +faststart \\\n        \"$OUTPUT_VIDEO\"\nfi\n\nif [ $? -eq 0 ]; then\n    echo \"âœ… Video enhanced successfully!\" >&2\n    echo \"Output: $OUTPUT_VIDEO\" >&2\n    \n    # Show file sizes\n    INPUT_SIZE=$(du -h \"$INPUT_VIDEO\" | cut -f1)\n    OUTPUT_SIZE=$(du -h \"$OUTPUT_VIDEO\" | cut -f1)\n    echo \"Size - Input: $INPUT_SIZE, Output: $OUTPUT_SIZE\" >&2\n    \n    echo \"$(basename \"$OUTPUT_VIDEO\")\"\n\nelse\n    echo \"âŒ Error: Video processing failed\" >&2\n    exit 1\nfi"
      },
      "type": "n8n-nodes-base.executeCommand",
      "typeVersion": 1,
      "position": [
        -1728,
        -1344
      ],
      "id": "2980c8dd-eeb9-47e1-b54d-738699bfb0bd",
      "name": "Tweak"
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "UPDATE {{ String($('Webhook').item.json.body.database_name).toLowerCase() }}\nSET public = 'https://files.mohdasif.net/{{ $('Webhook').item.json.body.folder }}/output/{{ $('Webhook').item.json.body.filename }}'\nWHERE id = {{ $('Webhook').item.json.body.id }};\n",
        "options": {}
      },
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.6,
      "position": [
        -2352,
        -944
      ],
      "id": "59d78f68-407f-40f9-826d-dde18a3c3a91",
      "name": "set_public_link",
      "credentials": {
        "postgres": {
          "id": "NTm0aBQ2ka4qBTqV",
          "name": "Postgres account"
        }
      }
    },
    {
      "parameters": {
        "content": "# MODIFY SCRIPTS",
        "height": 224,
        "width": 384
      },
      "type": "n8n-nodes-base.stickyNote",
      "position": [
        -1792,
        -1424
      ],
      "typeVersion": 1,
      "id": "499240bb-fe26-48d2-ab29-03edc72343d0",
      "name": "Sticky Note2"
    },
    {
      "parameters": {
        "workflowId": {
          "__rl": true,
          "value": "BsyOPmLgdOcI8rtZ",
          "mode": "list",
          "cachedResultUrl": "/workflow/BsyOPmLgdOcI8rtZ",
          "cachedResultName": "getData"
        },
        "workflowInputs": {
          "mappingMode": "defineBelow",
          "value": {}
        },
        "options": {}
      },
      "type": "n8n-nodes-base.executeWorkflow",
      "typeVersion": 1.3,
      "position": [
        -1904,
        -848
      ],
      "id": "03a636ca-4534-4cf4-b866-e5b2843e1f97",
      "name": "data"
    },
    {
      "parameters": {
        "mode": "raw",
        "jsonOutput": "={\n  \"username\": \"{{ $('Webhook').item.json.body.username }}\",\n  \"type\": \"{{ $('Webhook').item.json.body.type }}\",\n  \"title\":\"{{ $('Webhook').item.json.body.title }}\"\n}",
        "options": {}
      },
      "type": "n8n-nodes-base.set",
      "typeVersion": 3.4,
      "position": [
        -2128,
        -848
      ],
      "id": "c0e1fbff-4ca0-4534-84b1-9c143cc03d71",
      "name": "pre"
    },
    {
      "parameters": {
        "mode": "raw",
        "jsonOutput": "={\n  \"acc_id\": \"{{ String($('data').item.json.accounts[0].acc_id || '').trim() }}\",\n  \"username\": \"{{ String($('data').item.json.accounts[0].username || '').trim() }}\",\n  \"public\": \"{{ String($('data').item.json.pending_url[0].public || '').trim() }}\",\n  \"access_token\": \"{{ String($('data').item.json.accounts[0].token || '').trim() }}\",\n  \"database_name\": \"{{ String($('data').item.json.accounts[0].database_name || '').trim() }}\",\n  \"title\": {{\n    JSON.stringify(\n      String(\n        $('pre').item.json.title === 'false'\n          ? $('data').item.json.accounts[0].default_title\n          : ($('pre').item.json.title === 'true'\n              ? $('data').item.json.pending_url[0].title\n              : $('pre').item.json.title)\n      ).trim()\n    )\n  }},\n  \"description\": {{\n    JSON.stringify(\n      String(\n        $('pre').item.json.description\n          || $('data').item.json.accounts[0].default_des\n          || ''\n      ).trim()\n    )\n  }},\n  \"type\": \"{{ String($('pre').item.json.type || '').trim() }}\",\n  \"id\": \"{{ $('data').item.json.pending_url[0].id }}\",\n  \"folder\": \"{{ String($('data').item.json.accounts[0].folder || '').trim() }}\",\n  \"filename\": \"{{ String($('data').item.json.pending_url[0].filename || '').trim() }}\",\n  \"root_dir\": \"{{ String($('data').item.json.accounts[0].root_dir || '').trim() }}\",\n  \"files_url\": \"{{ String($('data').item.json.accounts[0].files_url || '').trim() }}\"\n}\n",
        "options": {}
      },
      "type": "n8n-nodes-base.set",
      "typeVersion": 3.4,
      "position": [
        -1680,
        -848
      ],
      "id": "2638dfe2-0f6b-46bc-a3ec-4dee5d8af018",
      "name": "final_data",
      "notes": "{\n  \"acc_id\": \"{{ String($('accounts').item.json.acc_id || '').trim() }}\",\n  \"username\": \"{{ String($('accounts').item.json.username || '').trim() }}\",\n  \"public\": \"https://files.mohdasif.net/{{ $json.modified }}\",\n  \"access_token\": \"{{ String($('accounts').item.json.token || '').trim() }}\",\n  \"database_name\": \"{{ String($('accounts').item.json.database_name || '').trim() }}\",\n  \"status\": \"Pending\",\n  \"title\": \"{{ $('start').item.json.title === 'false' ? $('accounts').item.json.default_title : $('start').item.json.title }}\",\n  \"description\": {{ JSON.stringify(String($('start').item.json.description || $('accounts').item.json.default_des || '').trim()) }},\n  \"type\": \"{{ String($('start').item.json.type || '').trim() }}\",\n  \"id\": \"{{ $('pending_url').item.json.id }}\"\n}"
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "UPDATE {{ String($('Webhook').item.json.body.database_name).toLowerCase() }}\nSET public = 'https://files.mohdasif.net/{{ $('Webhook').item.json.body.folder }}/{{ $('Webhook').item.json.body.filename }}'\nWHERE id = {{ $('Webhook').item.json.body.id }};\n",
        "options": {}
      },
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.6,
      "position": [
        -2016,
        -656
      ],
      "id": "ca58fb49-375a-40e1-8457-ff4e16c87ce7",
      "name": "set_public_link1",
      "credentials": {
        "postgres": {
          "id": "NTm0aBQ2ka4qBTqV",
          "name": "Postgres account"
        }
      }
    },
    {
      "parameters": {
        "command": "=#!/bin/sh\nset -eu\n\n# Video composition script optimized for Hostinger KVM2 VPS / n8n automation\n#\n# PERFORMANCE OPTIMIZATION NOTES FOR VPS:\n# 1. ENCODING_PRESET=\"ultrafast\" - Fastest encoding (3-5x faster than default)\n# 2. ENCODING_CRF=28 - Lower quality but much faster (vs 23 = high quality)\n# 3. FFMPEG_THREADS=0 - Auto-detect CPU cores (or set to 2-4 for KVM2)\n# 4. Audio bitrate reduced to 128k (was 192k) - Faster audio encoding\n# 5. Reduced filter complexity - Single format conversion, removed redundant filters\n# 6. FPS fixed at 30 before overlays to reduce processing load\n#\n# SPEED EXPECTATIONS (10 sec video on KVM2):\n# - ultrafast preset: ~15-30 seconds\n# - veryfast preset: ~45-90 seconds\n# - medium preset: ~2-4 minutes\n#\n# To make even faster (lower quality):\n# - Set ENCODING_CRF=30-32\n# - Set ENCODING_PRESET=\"superfast\" or keep \"ultrafast\"\n# - Reduce TARGET_FPS to 24\n# - Disable OVERLAY_CHROMA_KEY_ENABLE if not needed\n#\n# OVERLAY CONFIGURATION EXAMPLES:\n#\n# Example 1: Green screen overlay at bottom\n#   OVERLAY_POSITION=\"bottom\"\n#   OVERLAY_CHROMA_KEY_ENABLE=true\n#   OVERLAY_CHROMA_KEY_COLOR=\"green\"\n#   OVERLAY_OPACITY=100\n#\n# Example 2: Small overlay at custom position\n#   OVERLAY_POSITION=\"custom\"\n#   OVERLAY_CUSTOM_X=50\n#   OVERLAY_CUSTOM_Y=1400\n#   OVERLAY_SCALE_PERCENT=50\n#   OVERLAY_OPACITY=80\n#\n# Example 3: Centered semi-transparent overlay\n#   OVERLAY_POSITION=\"center\"\n#   OVERLAY_OPACITY=70\n#   OVERLAY_WIDTH=800\n#   OVERLAY_HEIGHT=600\n#\n# Supported formats: MP4, MOV, AVI, GIF (animated GIF supported)\n\n# ---------------- CONFIG ----------------\nSCRIPT_DIR=\"{{ $json.SCRIPT_DIR }}\"\nINPUT_URL=\"{{ $json.INPUT_URL }}\"\nOVERLAY_FILE=\"{{ $json.OVERLAY_FILE }}\"\nOVERLAY_2=\"\"\nOVERLAY_2_LENGTH_SECONDS=\"\"\nOVERLAY_2_START_SEC=\"0\"\nOVERLAY_TRANSITION_DURATION=\"0.6\"\n\nTRIM_DURATION=\"{{ $json.TRIM_DURATION }}\"  # Reduced to 10 seconds for quick testing\nOUTRO_FILE=\"\"\nOUTRO_TRANSITION_DURATION=\"0.5\"\n\n# RANDOM INSERT with AUDIO support (leave empty to disable)\nRANDOM_INSERT_FILE=\"\"\nRANDOM_INSERT_TRANSITION=\"0.2\"\n\n# NEW: Overlay audio settings\nOVERLAY_AUDIO_ENABLE=true        # Enable overlay audio preservation\nOVERLAY_AUDIO_VOLUME=80          # Volume level 1-100 (100 = original, 50 = half)\n\n# ========== OVERLAY POSITIONING & SIZING ==========\n# Position: \"top\", \"bottom\", \"center\", \"custom\"\nOVERLAY_POSITION=\"bottom\"\n# For custom position: X and Y coordinates (0-1920 for Y, 0-1080 for X)\nOVERLAY_CUSTOM_X=0\nOVERLAY_CUSTOM_Y=1200\n# Overlay size settings\nOVERLAY_WIDTH=\"100%\"               # Width in pixels (max 1080 for full width)\nOVERLAY_HEIGHT=\"50%\"             # Height in pixels (leave empty for auto based on aspect ratio)\nOVERLAY_SCALE_PERCENT=100        # Scale as percentage (100 = original size, 50 = half size)\nOVERLAY_LOOP_ENABLE=true         # Repeat overlay when shorter than main\n\n# Overlay effects\nOVERLAY_OPACITY={{ $json.OVERLAY_OPACITY }}  # Opacity 0-100 (100 = fully opaque, 0 = transparent)\nOVERLAY_CHROMA_KEY_ENABLE=true   # Enable green screen removal\nOVERLAY_CHROMA_KEY_COLOR=\"green\" # Using \"green\" keyword for chromakey filter\nOVERLAY_CHROMA_KEY_SIMILARITY=0.12 # 0.0-1.0, tuned to keep subject visible\nOVERLAY_CHROMA_KEY_BLEND=0.05     # 0.0-1.0, mild blend to soften edges\n# Optional manual edge trims (pixels). Set to >0 to remove borders after chroma key.\nOVERLAY_EDGE_TRIM=\"LEFT/RIGHT\"   # deprecated: use LEFT/RIGHT below\nOVERLAY_EDGE_TRIM_LEFT=\"{{ $json.OVERLAY_EDGE_TRIM_LEFT }}\"    # Pixels to crop from left edge or \"auto\"\nOVERLAY_EDGE_TRIM_RIGHT=\"{{ $json.OVERLAY_EDGE_TRIM_RIGHT }}\"   # Pixels to crop from right edge or \"auto\"\nOVERLAY_AUTO_TRIM_THRESHOLD=25   # Brightness threshold for auto edge trim (0-255)\nOVERLAY_AUTO_TRIM_MARGIN=6       # Extra pixels to trim beyond detected edge (safety buffer)\nOVERLAY_SPEED_FACTOR=\"{{ $json.OVERLAY_SPEED_FACTOR }}\"        # Overlay-only speed multiplier (1.0 = original)\n\n# ========== END OVERLAY SETTINGS ==========\n\nCANVAS_WIDTH=1080\nCANVAS_HEIGHT=1920\n\n# Crop settings: enable independent top/bottom cropping\nCROP_ENABLE=true\nCROP_TOP_ENABLE=true\nCROP_TOP_PERCENT={{ $json.CROP_TOP_PERCENT }}\nCROP_BOTTOM_ENABLE=true\nCROP_BOTTOM_PERCENT={{ $json.CROP_BOTTOM_PERCENT }}\n\nMAIN_POSITION=\"top\"           # Position main background: top, bottom, center, or custom\nMAIN_CUSTOM_Y=0                # Used when MAIN_POSITION=\"custom\"\n\n# Default crop values\nDEFAULT_CROP_TOP_PERCENT={{ $json.CROP_TOP_PERCENT }}\nDEFAULT_CROP_BOTTOM_PERCENT={{ $json.CROP_BOTTOM_PERCENT }}\n\n# Mirror/flip main video horizontally\nMIRROR_ENABLE=false\n\n# Speed factor (applies to composed main video + main audio)\nSPEED_FACTOR=\"1\"\n\n# Brightness adjustment for final output (-1.0 .. 1.0)\nBRIGHTNESS=\"0.1\"\n\n# Force Instagram-friendly fps\nTARGET_FPS=30\n\n# FFmpeg performance settings for VPS/cloud hosting\n# Number of CPU threads to use (0 = auto-detect, or set to specific number like 2, 4)\nFFMPEG_THREADS=0\n# Encoding preset: ultrafast, superfast, veryfast, faster, fast, medium\n# ultrafast = fastest encoding, larger file size\n# veryfast = good balance for VPS\nENCODING_PRESET=\"ultrafast\"\n# CRF quality: 18-28 (lower = better quality, slower; 23-28 recommended for VPS)\nENCODING_CRF=28\n\nCAPTION_ENABLE=false\nCAPTION_FONT_PATH=\"/System/Library/Fonts/Supplemental/Arial Bold.ttf\"  # macOS default\nCAPTION_POS_X_PERCENT=50\nCAPTION_POS_Y_PERCENT=35\nCAPTION_TEXT=\"à¤¯à¤¹ à¤à¤• à¤Ÿà¥‡à¤¸à¥à¤Ÿ à¤¹à¥ˆ ðŸŽ¬\nTest Caption\"  # Hindi + emoji test\nCAPTION_FONT_SIZE=45\nCAPTION_FONT_COLOR=\"white\"\nTEXT_BG_ENABLE=true\nTEXT_BG_COLOR=\"black\"\nTEXT_BG_OPACITY=150\nTEXT_BG_PADDING=25\n\n# ---------------- OUTPUT (FIXED) ----------------\nOUT_FILE=\"{{ $json.OUT_FILE }}\"\nmkdir -p \"$(dirname \"$OUT_FILE\")\"\n\nOUT_DIR=\"$(dirname \"$OUT_FILE\")\"\nCAPTION_PNG=\"${OUT_DIR}/caption_image.png\"\nMERGED_OVERLAY_TMP=\"${OUT_DIR}/overlay_merged_$(date +%s)_$$.mp4\"\nCOMPOSED_MAIN_TMP=\"${OUT_DIR}/main_composed_$(date +%s)_$$.mp4\"\n\nFFMPEG_TIMEOUT=\"5m\"\n# --------------- end config --------------\n\necho \"=== Start: enhanced video composition with overlay audio support ===\" >&2\n\n# Validate overlay audio volume\nif [ \"$OVERLAY_AUDIO_ENABLE\" = \"true\" ]; then\n  if [ -z \"${OVERLAY_AUDIO_VOLUME:-}\" ] || [ \"$OVERLAY_AUDIO_VOLUME\" -lt 1 ] || [ \"$OVERLAY_AUDIO_VOLUME\" -gt 100 ]; then\n    echo \"WARN: Invalid OVERLAY_AUDIO_VOLUME ($OVERLAY_AUDIO_VOLUME), using 100\" >&2\n    OVERLAY_AUDIO_VOLUME=100\n  fi\n  # Convert 1-100 scale to 0.01-1.0 for FFmpeg volume filter\n  OVERLAY_VOLUME_FLOAT=$(awk -v v=\"$OVERLAY_AUDIO_VOLUME\" 'BEGIN{ printf(\"%.2f\", v/100.0) }')\n  echo \"Overlay audio: ENABLED at ${OVERLAY_AUDIO_VOLUME}% volume (${OVERLAY_VOLUME_FLOAT})\" >&2\nelse\n  echo \"Overlay audio: DISABLED\" >&2\nfi\n\n# Resolve INPUT_FILE from INPUT_URL\nINPUT_FILE=\"$INPUT_URL\"\n\necho \"Main background: $INPUT_FILE\" >&2\necho \"Overlay primary: $OVERLAY_FILE\" >&2\n[ -n \"$OVERLAY_2\" ] && echo \"Overlay secondary: $OVERLAY_2\" >&2\n[ -n \"$OUTRO_FILE\" ] && echo \"Outro file: $OUTRO_FILE\" >&2\n[ -n \"$RANDOM_INSERT_FILE\" ] && echo \"Random insert file: $RANDOM_INSERT_FILE\" >&2\n[ -n \"$TRIM_DURATION\" ] && echo \"Trim duration: $TRIM_DURATION seconds\" >&2\necho \"SPEED_FACTOR: $SPEED_FACTOR, BRIGHTNESS: $BRIGHTNESS, TARGET_FPS: $TARGET_FPS\" >&2\n\n# Helper functions\nprobe_duration() { ffprobe -v error -show_entries format=duration -of default=noprint_wrappers=1:nokey=1 \"$1\" 2>/dev/null || printf \"\"; }\nprobe_resolution() { ffprobe -v error -select_streams v:0 -show_entries stream=width,height -of csv=p=0:s=x \"$1\" 2>/dev/null || printf \"\"; }\nprobe_framerate() { ffprobe -v error -select_streams v:0 -show_entries stream=r_frame_rate -of default=nw=1:nk=1 \"$1\" 2>/dev/null || printf \"\"; }\nhas_audio() { ffprobe -v error -select_streams a:0 -show_entries stream=codec_type -of default=nw=1:nk=1 \"$1\" 2>/dev/null | grep -q \"audio\" && echo \"yes\" || echo \"no\"; }\n\n# Validate files\nif [ ! -f \"$INPUT_FILE\" ]; then echo \"ERR: main input missing: $INPUT_FILE\" >&2; exit 1; fi\nif [ ! -f \"$OVERLAY_FILE\" ]; then echo \"ERR: overlay primary missing: $OVERLAY_FILE\" >&2; exit 1; fi\nif [ -n \"$OVERLAY_2\" ] && [ ! -f \"$OVERLAY_2\" ]; then echo \"ERR: overlay secondary missing: $OVERLAY_2\" >&2; exit 1; fi\n\n# Check if overlay has audio\nOVERLAY_HAS_AUDIO=$(has_audio \"$OVERLAY_FILE\")\nif [ \"$OVERLAY_AUDIO_ENABLE\" = \"true\" ] && [ \"$OVERLAY_HAS_AUDIO\" = \"no\" ]; then\n  echo \"WARN: Overlay audio enabled but overlay file has no audio stream. Disabling overlay audio.\" >&2\n  OVERLAY_AUDIO_ENABLE=false\nfi\n\nif [ -n \"$OUTRO_FILE\" ] && [ ! -f \"$OUTRO_FILE\" ]; then\n  echo \"WARN: outro path provided but file not found: $OUTRO_FILE â€” skipping outro.\" >&2\n  OUTRO_FILE=\"\"\nfi\n\nif [ -n \"$RANDOM_INSERT_FILE\" ] && [ ! -f \"$RANDOM_INSERT_FILE\" ]; then\n  echo \"ERR: random insert file missing: $RANDOM_INSERT_FILE\" >&2; exit 1;\nfi\n\nif [ -z \"${OUTRO_FILE:-}\" ]; then\n  OUTRO_FILE=\"\"\n  OUTRO_INDEX=\"\"\n  echo \"No valid outro â€” outro processing disabled.\" >&2\nfi\n\n# Probe overlay durations\nOV1_DUR=$(probe_duration \"$OVERLAY_FILE\"); OV1_DUR=${OV1_DUR:-0}; OV1_DUR=$(awk -v v=\"$OV1_DUR\" 'BEGIN{printf(\"%.3f\", v+0)}')\necho \"Overlay1 duration: $OV1_DUR\" >&2\nif [ -n \"$OVERLAY_2\" ]; then\n  OV2_DUR=$(probe_duration \"$OVERLAY_2\"); OV2_DUR=${OV2_DUR:-0}; OV2_DUR=$(awk -v v=\"$OV2_DUR\" 'BEGIN{printf(\"%.3f\", v+0)}')\n  echo \"Overlay2 duration: $OV2_DUR\" >&2\nfi\n\n# Determine overlay resolution and FPS\nIN_RES=$(probe_resolution \"$OVERLAY_FILE\" || true)\nif [ -n \"$IN_RES\" ]; then\n  O_W=$(printf \"%s\" \"$IN_RES\" | awk -Fx '{print $1}')\n  O_H=$(printf \"%s\" \"$IN_RES\" | awk -Fx '{print $2}')\nelse\n  O_W=720; O_H=1280\nfi\nFPS_RAW=$(probe_framerate \"$OVERLAY_FILE\" || true)\necho \"Overlay native resolution: ${O_W}x${O_H} native-fps:${FPS_RAW} -> using TARGET_FPS=${TARGET_FPS}\" >&2\nif [ \"$OVERLAY_LOOP_ENABLE\" = \"true\" ]; then\n  echo \"Overlay looping: enabled\" >&2\nelse\n  echo \"Overlay looping: disabled\" >&2\nfi\n\n# Auto-detect edge trims if requested\nif { [ \"${OVERLAY_EDGE_TRIM_LEFT}\" = \"auto\" ] || [ \"${OVERLAY_EDGE_TRIM_RIGHT}\" = \"auto\" ]; }; then\n  echo \"Auto-detecting overlay side trims...\" >&2\n  export OVERLAY_FILE OVERLAY_FINAL_WIDTH OVERLAY_AUTO_TRIM_THRESHOLD OVERLAY_AUTO_TRIM_MARGIN OV1_DUR\n  AUTO_TRIMS=$(python3 - <<'PY'\nimport os\nimport subprocess\nimport tempfile\nfrom PIL import Image\n\noverlay = os.environ[\"OVERLAY_FILE\"]\nwidth = int(os.environ.get(\"OVERLAY_FINAL_WIDTH\", \"0\") or \"0\")\nthreshold = int(os.environ.get(\"OVERLAY_AUTO_TRIM_THRESHOLD\", \"25\"))\nmargin = int(os.environ.get(\"OVERLAY_AUTO_TRIM_MARGIN\", \"0\") or \"0\")\nduration = float(os.environ.get(\"OV1_DUR\", \"0\") or \"0\")\n\nif width <= 0:\n    print(\"0,0\")\n    raise SystemExit\n\ndef analyze_frame(path):\n    img = Image.open(path).convert(\"RGB\")\n    w, h = img.size\n    def column_avg(x):\n        total = 0\n        for y in range(h):\n            r, g, b = img.getpixel((x, y))\n            total += r + g + b\n        return total / (3 * h)\n    left = 0\n    while left < w:\n        if column_avg(left) > threshold:\n            break\n        left += 1\n    right = 0\n    while right < (w - left):\n        if column_avg(w - 1 - right) > threshold:\n            break\n        right += 1\n    img.close()\n    return left, right\n\ndef extract_frame(time_pos):\n    with tempfile.NamedTemporaryFile(suffix=\".png\", delete=False) as tmp:\n        tmp_path = tmp.name\n    cmd = [\n        \"ffmpeg\", \"-v\", \"error\", \"-y\",\n        \"-ss\", f\"{max(time_pos, 0):.3f}\",\n        \"-i\", overlay,\n        \"-vf\", f\"scale={width}:-1\",\n        \"-frames:v\", \"1\",\n        tmp_path\n    ]\n    subprocess.run(cmd, check=True)\n    return tmp_path\n\nsample_times = [0.0]\nif duration > 1.0:\n    sample_times.append(duration * 0.5)\n    sample_times.append(max(duration - 0.5, 0.0))\n\nmax_left = 0\nmax_right = 0\ntemp_paths = []\n\ntry:\n    for t in sample_times:\n        path = extract_frame(t)\n        temp_paths.append(path)\n        left, right = analyze_frame(path)\n        if left > max_left:\n            max_left = left\n        if right > max_right:\n            max_right = right\nfinally:\n    for p in temp_paths:\n        if p and os.path.exists(p):\n            os.unlink(p)\n\nleft = max_left + margin\nright = max_right + margin\n\nwith tempfile.NamedTemporaryFile(suffix=\".png\", delete=False) as tmp:\n    tmp_path = tmp.name\ncmd = [\n    \"ffmpeg\", \"-v\", \"error\", \"-y\",\n    \"-i\", overlay,\n    \"-vf\", f\"scale={width}:-1\",\n    \"-frames:v\", \"1\",\n    tmp_path\n]\nsubprocess.run(cmd, check=True)\nimg = Image.open(tmp_path)\nw = img.width\nimg.close()\nos.unlink(tmp_path)\n\nif left + right >= w:\n    keep = max(w - 2, 1)\n    ratio = left / (left + right) if (left + right) else 0.5\n    left = int(keep * ratio)\n    right = keep - left\n\nprint(f\"{left},{right}\")\nPY\n)\n  AUTO_LEFT=$(printf \"%s\" \"$AUTO_TRIMS\" | cut -d',' -f1)\n  AUTO_RIGHT=$(printf \"%s\" \"$AUTO_TRIMS\" | cut -d',' -f2)\n  echo \"Auto trim detected: left=${AUTO_LEFT}px right=${AUTO_RIGHT}px\" >&2\n  [ \"${OVERLAY_EDGE_TRIM_LEFT}\" = \"auto\" ] && OVERLAY_EDGE_TRIM_LEFT=\"$AUTO_LEFT\"\n  [ \"${OVERLAY_EDGE_TRIM_RIGHT}\" = \"auto\" ] && OVERLAY_EDGE_TRIM_RIGHT=\"$AUTO_RIGHT\"\nfi\n\n# Build overlay effects filter chain\nOVERLAY_PRE_EFFECTS=\"\"\nOVERLAY_EFFECTS=\"\"\n\n# Chroma key (green screen removal)\nif [ \"$OVERLAY_CHROMA_KEY_ENABLE\" = \"true\" ]; then\n  echo \"Chroma key enabled: removing ${OVERLAY_CHROMA_KEY_COLOR}\" >&2\n  # Use chromakey filter - format conversion done once in pre-effects\n  OVERLAY_EFFECTS=\"${OVERLAY_EFFECTS}chromakey=${OVERLAY_CHROMA_KEY_COLOR}:${OVERLAY_CHROMA_KEY_SIMILARITY}:${OVERLAY_CHROMA_KEY_BLEND},\"\nfi\n\n# Optional edge trim to remove matte seams\nOVERLAY_TRIM_LEFT=\"${OVERLAY_EDGE_TRIM_LEFT:-}\"\nOVERLAY_TRIM_RIGHT=\"${OVERLAY_EDGE_TRIM_RIGHT:-}\"\n\n# Backward compatibility if legacy OVERLAY_EDGE_TRIM is set\nif [ -n \"${OVERLAY_EDGE_TRIM:-}\" ]; then\n  case \"$OVERLAY_EDGE_TRIM\" in\n    ''|*[!0-9]*)\n      echo \"WARN: OVERLAY_EDGE_TRIM is not a number (${OVERLAY_EDGE_TRIM}) â€” ignoring legacy setting.\" >&2\n      ;;\n    *)\n      OVERLAY_TRIM_LEFT=\"$OVERLAY_EDGE_TRIM\"\n      OVERLAY_TRIM_RIGHT=\"$OVERLAY_EDGE_TRIM\"\n      ;;\n  esac\nfi\n\nvalidate_trim() {\n  local value=\"$1\"\n  case \"$value\" in\n    ''|*[!0-9]*)\n      echo \"\"\n      ;;\n    *)\n      echo \"$value\"\n      ;;\n  esac\n}\n\nOVERLAY_TRIM_LEFT=$(validate_trim \"$OVERLAY_TRIM_LEFT\")\nOVERLAY_TRIM_RIGHT=$(validate_trim \"$OVERLAY_TRIM_RIGHT\")\n\nif [ -n \"$OVERLAY_TRIM_LEFT\" ] || [ -n \"$OVERLAY_TRIM_RIGHT\" ]; then\n  LEFT_VAL=${OVERLAY_TRIM_LEFT:-0}\n  RIGHT_VAL=${OVERLAY_TRIM_RIGHT:-0}\n  if [ \"$LEFT_VAL\" -gt 0 ] || [ \"$RIGHT_VAL\" -gt 0 ]; then\n    echo \"Overlay edge trim: left=${LEFT_VAL}px right=${RIGHT_VAL}px\" >&2\n    OVERLAY_PRE_EFFECTS=\"${OVERLAY_PRE_EFFECTS}crop=in_w-${LEFT_VAL}-${RIGHT_VAL}:in_h:${LEFT_VAL}:0,\"\n  fi\nfi\n\n# Opacity/transparency\nif [ \"$OVERLAY_OPACITY\" -lt 100 ]; then\n  OPACITY_VALUE=$(awk -v o=\"$OVERLAY_OPACITY\" 'BEGIN{printf(\"%.2f\", o/100.0)}')\n  echo \"Overlay opacity: ${OVERLAY_OPACITY}% (${OPACITY_VALUE})\" >&2\n  OVERLAY_EFFECTS=\"${OVERLAY_EFFECTS}colorchannelmixer=aa=${OPACITY_VALUE},\"\nfi\n\necho \"Overlay effects chain: ${OVERLAY_EFFECTS:-none}\" >&2\n# ========== END overlay calculations ==========\n\n# Merge overlays if needed (VIDEO + AUDIO)\nif [ -z \"$OVERLAY_2\" ]; then\n  echo \"No overlay2 provided â€” using overlay primary as-is.\" >&2\n  MERGED_OVERLAY=\"$OVERLAY_FILE\"\nelse\n  if [ -n \"$OVERLAY_2_LENGTH_SECONDS\" ]; then\n    OVERLAY_2_LENGTH_SECONDS=$(awk -v v=\"$OVERLAY_2_LENGTH_SECONDS\" 'BEGIN{printf(\"%.3f\", v+0)}')\n    FIRST_END_SEC=$(awk -v d=\"$OV1_DUR\" -v s=\"$OVERLAY_2_LENGTH_SECONDS\" 'BEGIN{printf(\"%.3f\", d - s)}')\n  else\n    FIRST_END_SEC=$(awk -v d=\"$OV1_DUR\" 'BEGIN{printf(\"%.3f\", d*0.70)}')\n  fi\n\n  TRANS=$(awk -v v=\"$OVERLAY_TRANSITION_DURATION\" 'BEGIN{printf(\"%.3f\", v+0)}')\n  OFFSET=$(awk -v f=\"$FIRST_END_SEC\" -v t=\"$TRANS\" 'BEGIN{printf(\"%.3f\", f - t)}')\n\n  # Merge video AND audio (optimized for VPS speed)\n  ffmpeg -y -hide_banner -loglevel error \\\n    -i \"$OVERLAY_FILE\" -i \"$OVERLAY_2\" \\\n    -filter_complex \"\\\n[0:v]trim=start=0:end=${FIRST_END_SEC},setpts=PTS-STARTPTS,scale=${O_W}:${O_H},fps=${TARGET_FPS},setsar=1,format=yuv420p[v0]; \\\n[1:v]trim=start=${OVERLAY_2_START_SEC},setpts=PTS-STARTPTS,scale=${O_W}:${O_H},fps=${TARGET_FPS},setsar=1,format=yuv420p[v1]; \\\n[v0][v1]xfade=transition=fade:duration=${TRANS}:offset=${OFFSET}[vxf]; \\\n[0:a]atrim=start=0:end=${FIRST_END_SEC},asetpts=PTS-STARTPTS[a0]; \\\n[1:a]atrim=start=${OVERLAY_2_START_SEC},asetpts=PTS-STARTPTS[a1]; \\\n[a0][a1]acrossfade=d=${TRANS}:o=${OFFSET}[axf]\" \\\n    -map \"[vxf]\" -map \"[axf]\" -c:v libx264 -crf ${ENCODING_CRF} -preset ${ENCODING_PRESET} -threads ${FFMPEG_THREADS} -c:a aac -b:a 128k -movflags +faststart \\\n    \"$MERGED_OVERLAY_TMP\"\n\n  MERGED_OVERLAY=\"$MERGED_OVERLAY_TMP\"\nfi\n\n# Generate caption if enabled\nif [ \"$CAPTION_ENABLE\" = \"true\" ]; then\n  rm -f \"${CAPTION_PNG}\" || true\n  export CAPTION_PNG CAPTION_TEXT CAPTION_FONT_PATH CAPTION_FONT_SIZE CAPTION_FONT_COLOR CAPTION_POS_X_PERCENT CAPTION_POS_Y_PERCENT TEXT_BG_ENABLE TEXT_BG_COLOR TEXT_BG_OPACITY TEXT_BG_PADDING SCRIPT_DIR\n  python3 - <<'PY' 1>&2\nimport os\nimport re\nimport sys\nfrom PIL import Image, ImageDraw, ImageFont\nimport urllib.request\nimport io\n\nSCRIPT_DIR = os.environ.get(\"SCRIPT_DIR\", \"\")\n\n# Emoji rendering using Twemoji PNG images\ndef get_emoji_image(emoji_char, size):\n    \"\"\"Download and return emoji image from Twemoji CDN\"\"\"\n    try:\n        # Get Unicode codepoint(s) for the emoji\n        codepoints = '-'.join(f'{ord(c):x}' for c in emoji_char)\n        # Twemoji CDN URL (72x72 PNG)\n        url = f'https://cdn.jsdelivr.net/gh/twitter/twemoji@14.0.2/assets/72x72/{codepoints}.png'\n\n        with urllib.request.urlopen(url, timeout=3) as response:\n            img_data = response.read()\n            emoji_img = Image.open(io.BytesIO(img_data)).convert(\"RGBA\")\n            # Resize to match font size\n            emoji_img = emoji_img.resize((size, size), Image.Resampling.LANCZOS)\n            return emoji_img\n    except Exception as e:\n        print(f\"Could not fetch emoji {emoji_char} ({codepoints}): {e}\", file=sys.stderr, flush=True)\n        return None\n\nout_path = os.environ[\"CAPTION_PNG\"]\ntext = os.environ.get(\"CAPTION_TEXT\", \"\")\nfont_path = os.environ.get(\"CAPTION_FONT_PATH\", \"/usr/share/fonts/truetype/dejavu/DejaVuSans-Bold.ttf\")\ntry:\n    font_size = int(os.environ.get(\"CAPTION_FONT_SIZE\", \"64\"))\nexcept Exception:\n    font_size = 64\nfont_color = os.environ.get(\"CAPTION_FONT_COLOR\", \"white\")\ntry:\n    pos_x_pct = int(os.environ.get(\"CAPTION_POS_X_PERCENT\", \"50\"))\nexcept Exception:\n    pos_x_pct = 50\ntry:\n    pos_y_pct = int(os.environ.get(\"CAPTION_POS_Y_PERCENT\", \"50\"))\nexcept Exception:\n    pos_y_pct = 50\nbg_enable = os.environ.get(\"TEXT_BG_ENABLE\", \"true\").lower() == 'true'\ntry:\n    bg_opacity = int(os.environ.get(\"TEXT_BG_OPACITY\", \"150\"))\nexcept Exception:\n    bg_opacity = 150\ntry:\n    bg_padding = int(os.environ.get(\"TEXT_BG_PADDING\", \"20\"))\nexcept Exception:\n    bg_padding = 20\n\ncanvas_w, canvas_h = 1080, 1920\n\n# Font loading with multi-script support\ndef load_font(path, size):\n    \"\"\"Try to load a font, return None if failed\"\"\"\n    try:\n        font = ImageFont.truetype(path, size)\n        # Test if font can actually render (some emoji fonts need SVG support)\n        test_draw = ImageDraw.Draw(Image.new(\"RGBA\", (10, 10)))\n        try:\n            test_draw.textbbox((0, 0), \"A\", font=font)\n            return font\n        except (OSError, RuntimeError):\n            # Font loaded but can't render (likely SVG-based emoji font)\n            print(f\"WARNING: {path} requires SVG support, skipping\", flush=True)\n            return None\n    except Exception:\n        return None\n\n# Define font candidates for different scripts\nhindi_font_paths = [\n    os.path.join(SCRIPT_DIR, \"Noto_Sans_Devanagari\", \"static\", \"NotoSansDevanagari-Bold.ttf\"),\n    os.path.join(SCRIPT_DIR, \"Noto_Sans_Devanagari\", \"NotoSansDevanagari-VariableFont_wdth,wght.ttf\"),\n    \"/usr/share/fonts/truetype/noto/NotoSansDevanagari-Bold.ttf\",\n    \"/usr/share/fonts/truetype/noto/NotoSansDevanagari.ttf\",\n    \"/System/Library/Fonts/Devanagari Sangam MN.ttc\",\n    \"/usr/share/fonts/truetype/lohit-devanagari/Lohit-Devanagari.ttf\",\n    \"/usr/share/fonts/truetype/fonts-noto-devanagari/NotoSansDevanagari-Bold.ttf\"\n]\n\nlatin_font_paths = [\n    font_path,  # User-specified font\n    os.path.join(SCRIPT_DIR, \"Noto_Sans_Devanagari\", \"static\", \"NotoSansDevanagari-Regular.ttf\"),\n    \"/usr/share/fonts/truetype/dejavu/DejaVuSans-Bold.ttf\",\n    \"/usr/share/fonts/truetype/liberation/LiberationSans-Bold.ttf\",\n    \"/System/Library/Fonts/Supplemental/Arial Bold.ttf\"\n]\n\nemoji_font_paths = [\n    os.path.join(SCRIPT_DIR, \"Noto_Color_Emoji\", \"NotoColorEmoji-Regular.ttf\"),\n    \"/System/Library/Fonts/Apple Color Emoji.ttc\"\n]\n\n# Load fonts\nlatin_font = None\nfor p in latin_font_paths:\n    if os.path.isfile(p):\n        latin_font = load_font(p, font_size)\n        if latin_font:\n            break\n\nhindi_font = None\nfor p in hindi_font_paths:\n    if os.path.isfile(p):\n        hindi_font = load_font(p, font_size)\n        if hindi_font:\n            print(f\"Loaded Hindi font: {p}\", flush=True)\n            break\n\ndef supports_color_glyphs(font):\n    \"\"\"Detect if a font actually renders emoji glyphs with non-zero alpha.\"\"\"\n    if font is None:\n        return False\n    test_img = Image.new(\"RGBA\", (font_size * 2, font_size * 2), (0, 0, 0, 0))\n    test_draw = ImageDraw.Draw(test_img)\n    # Use a representative emoji that should exist in most sets\n    test_draw.text((0, 0), \"ðŸ˜€\", font=font, fill=(255, 255, 255, 255))\n    return any(pixel[3] > 0 for pixel in test_img.getdata())\n\nemoji_font = None\nfor p in emoji_font_paths:\n    if os.path.isfile(p):\n        candidate = load_font(p, font_size)\n        if candidate and supports_color_glyphs(candidate):\n            emoji_font = candidate\n            print(f\"Loaded emoji font: {p}\", flush=True)\n            break\n        elif candidate:\n            print(f\"WARNING: {p} loaded but produced empty glyphs â€” falling back\", flush=True)\n\nif emoji_font is None:\n    print(\"Emoji font not available â€” will fetch Twemoji PNGs\", flush=True)\n\nprint(\"Emoji rendering: prefer local emoji font, fallback to Twemoji CDN\", flush=True)\n\n# Fallback to default if no fonts loaded\nif latin_font is None:\n    latin_font = ImageFont.load_default()\n\n# Use Hindi font as fallback if available, otherwise use latin\nprimary_font = hindi_font if hindi_font else latin_font\n\ntext = text or \" \"\nlines = text.splitlines() if \"\\n\" in text else [text]\n\n# Detect script type for each character\ndef get_char_type(char):\n    \"\"\"Detect if character is Hindi (Devanagari), emoji, or latin\"\"\"\n    code = ord(char)\n    # Devanagari Unicode range: 0x0900-0x097F\n    if 0x0900 <= code <= 0x097F:\n        return 'hindi'\n    # Emoji ranges (expanded for better coverage)\n    elif (0x1F300 <= code <= 0x1FAFF or  # Misc symbols, pictographs, and extended\n          0x2600 <= code <= 0x26FF or    # Misc symbols\n          0x2700 <= code <= 0x27BF or    # Dingbats\n          0xFE00 <= code <= 0xFE0F or    # Variation selectors\n          0x1F000 <= code <= 0x1F0FF or  # Mahjong tiles\n          0x1F100 <= code <= 0x1F1FF or  # Enclosed alphanumeric supplement\n          0x1F200 <= code <= 0x1F2FF or  # Enclosed ideographic supplement\n          0x2300 <= code <= 0x23FF or    # Miscellaneous Technical\n          0x25A0 <= code <= 0x25FF or    # Geometric Shapes\n          0x2B00 <= code <= 0x2BFF or    # Miscellaneous Symbols and Arrows\n          0x1F900 <= code <= 0x1F9FF):   # Supplemental Symbols and Pictographs\n        return 'emoji'\n    else:\n        return 'latin'\n\n# Render text with proper font switching\ndef render_multiline_text(canvas, lines, start_y, font_color):\n    \"\"\"Render text with automatic font switching for Hindi and emoji\"\"\"\n    draw = ImageDraw.Draw(canvas)\n    cur_y = start_y\n    line_spacing = int(font_size * 0.3)\n\n    for line in lines:\n        # Calculate line width for centering\n        line_width = 0\n        segments = []\n        current_segment = \"\"\n        current_type = None\n\n        # Split line into segments by script type\n        for char in line:\n            char_type = get_char_type(char)\n            if char_type != current_type:\n                if current_segment:\n                    segments.append((current_segment, current_type))\n                current_segment = char\n                current_type = char_type\n            else:\n                current_segment += char\n\n        if current_segment:\n            segments.append((current_segment, current_type))\n\n        # Calculate total line width\n        for segment, seg_type in segments:\n            if seg_type == 'hindi' and hindi_font:\n                bbox = draw.textbbox((0, 0), segment, font=hindi_font)\n                line_width += bbox[2] - bbox[0]\n            elif seg_type == 'emoji':\n                if emoji_font:\n                    bbox = draw.textbbox((0, 0), segment, font=emoji_font)\n                    line_width += bbox[2] - bbox[0]\n                else:\n                    line_width += int(font_size * 1.2) * len(segment)\n            else:\n                bbox = draw.textbbox((0, 0), segment, font=latin_font)\n                line_width += bbox[2] - bbox[0]\n\n        # Calculate starting x position (centered)\n        x = (canvas_w * pos_x_pct / 100.0) - (line_width / 2.0)\n\n        # Draw each segment with appropriate font\n        for segment, seg_type in segments:\n            if seg_type == 'hindi' and hindi_font:\n                draw.text((x, cur_y), segment, font=hindi_font, fill=font_color)\n                bbox = draw.textbbox((x, cur_y), segment, font=hindi_font)\n                x += bbox[2] - bbox[0]\n            elif seg_type == 'emoji':\n                # Render emojis as downloaded images\n                if emoji_font:\n                    draw.text((x, cur_y), segment, font=emoji_font, fill=font_color)\n                    bbox = draw.textbbox((x, cur_y), segment, font=emoji_font)\n                    x += bbox[2] - bbox[0]\n                else:\n                    for emoji_char in segment:\n                        emoji_img = get_emoji_image(emoji_char, int(font_size * 1.2))\n                        if emoji_img:\n                            # Paste emoji image with transparency\n                            y_offset = int(cur_y - font_size * 0.1)  # Slight vertical adjustment\n                            canvas.paste(emoji_img, (int(x), y_offset), emoji_img if emoji_img.mode == 'RGBA' else None)\n                            x += int(font_size * 1.2)\n                        else:\n                            # Fallback: skip emoji with space\n                            x += int(font_size * 0.6)\n            else:\n                draw.text((x, cur_y), segment, font=latin_font, fill=font_color)\n                bbox = draw.textbbox((x, cur_y), segment, font=latin_font)\n                x += bbox[2] - bbox[0]\n\n        cur_y += font_size + line_spacing\n\n    return cur_y\n\n# Calculate bounding boxes for background\ncanvas = Image.new(\"RGBA\", (canvas_w, canvas_h), (0, 0, 0, 0))\ntemp_draw = ImageDraw.Draw(canvas)\nline_spacing = int(font_size * 0.3)\n\nline_bboxes = []\nmax_w = 0\n\nfor line in lines:\n    # Calculate width using multi-font approach\n    line_width = 0\n    segments = []\n    current_segment = \"\"\n    current_type = None\n\n    for char in line:\n        char_type = get_char_type(char)\n        if char_type != current_type:\n            if current_segment:\n                segments.append((current_segment, current_type))\n            current_segment = char\n            current_type = char_type\n        else:\n            current_segment += char\n\n    if current_segment:\n        segments.append((current_segment, current_type))\n\n    for segment, seg_type in segments:\n        if seg_type == 'hindi' and hindi_font:\n            bbox = temp_draw.textbbox((0, 0), segment, font=hindi_font)\n            line_width += bbox[2] - bbox[0]\n        elif seg_type == 'emoji':\n            if emoji_font:\n                bbox = temp_draw.textbbox((0, 0), segment, font=emoji_font)\n                line_width += bbox[2] - bbox[0]\n            else:\n                line_width += int(font_size * 1.2) * len(segment)\n        else:\n            bbox = temp_draw.textbbox((0, 0), segment, font=latin_font)\n            line_width += bbox[2] - bbox[0]\n\n    line_bboxes.append((line, line_width, font_size))\n    if line_width > max_w:\n        max_w = line_width\n\ntotal_h = sum(h for _, _, h in line_bboxes) + (len(lines) - 1) * line_spacing\n\ny = (canvas_h * pos_y_pct / 100.0) - (total_h / 2.0)\n\n# Draw rounded backgrounds\nif bg_enable:\n    bg_layer = Image.new(\"RGBA\", (canvas_w, canvas_h), (0, 0, 0, 0))\n    bg_draw = ImageDraw.Draw(bg_layer)\n\n    cur_y = y\n    for ln, w, h in line_bboxes:\n        line_x = (canvas_w * pos_x_pct / 100.0) - (w / 2.0)\n        left = int(line_x - bg_padding)\n        top = int(cur_y - bg_padding)\n        right = int(line_x + w + bg_padding)\n        bottom = int(cur_y + h + bg_padding)\n\n        radius = min(int(h * 0.5), bg_padding)\n        bg_draw.rounded_rectangle([left, top, right, bottom], radius=radius, fill=(0, 0, 0, bg_opacity))\n        cur_y += h + line_spacing\n\n    canvas = Image.alpha_composite(canvas, bg_layer)\n\n# Draw text with multi-font support and Twemoji image rendering\nrender_multiline_text(canvas, lines, y, font_color)\n\nos.makedirs(os.path.dirname(out_path), exist_ok=True)\ncanvas.save(out_path)\nprint(f\"Caption saved: {out_path}\", flush=True)\nPY\n  if [ ! -f \"$CAPTION_PNG\" ]; then echo \"ERR: caption generation failed.\" >&2; exit 1; fi\nfi\n\n# [Rest of the script continues exactly as original script.sh from line 458 onwards]\n# Due to length, I'm including the reference to continue from the original\n# The processing logic remains identical\n\n# Probe main duration\nMAIN_VID_DURATION=$(probe_duration \"$INPUT_FILE\" || printf \"\")\nMAIN_VID_DURATION=${MAIN_VID_DURATION:-10}\nMAIN_VID_DURATION=$(awk -v v=\"$MAIN_VID_DURATION\" 'BEGIN{ if(v==0) v=10; printf(\"%.3f\", v+0)}')\necho \"Main video duration (original): $MAIN_VID_DURATION\" >&2\n\n# Calculate proper INPUT_READ_DURATION based on SPEED_FACTOR\nSPEED_FACTOR_N=$(awk -v s=\"$SPEED_FACTOR\" 'BEGIN{ if(s<=0) s=1.0; printf(\"%.6f\", s+0) }')\nOVERLAY_SPEED_FACTOR_N=$(awk -v s=\"$OVERLAY_SPEED_FACTOR\" 'BEGIN{ if(s<=0) s=1.0; printf(\"%.6f\", s+0) }')\n\n# Apply trim with speed factor consideration\nINPUT_READ_DURATION=\"\"\nif [ -n \"$TRIM_DURATION\" ]; then\n    INPUT_READ_DURATION=$(awk -v t=\"$TRIM_DURATION\" -v s=\"$SPEED_FACTOR_N\" 'BEGIN{ printf(\"%.3f\", t*s) }')\n    if [ \"$(awk -v i=\"$INPUT_READ_DURATION\" -v m=\"$MAIN_VID_DURATION\" 'BEGIN{ if(i>m) print 1; else print 0 }')\" = \"1\" ]; then\n        echo \"WARNING: Requested duration exceeds available. Adjusting...\" >&2\n        INPUT_READ_DURATION=\"$MAIN_VID_DURATION\"\n        EFFECTIVE_DURATION=$(awk -v i=\"$INPUT_READ_DURATION\" -v s=\"$SPEED_FACTOR_N\" 'BEGIN{ printf(\"%.3f\", i/s) }')\n    else\n        EFFECTIVE_DURATION=\"$TRIM_DURATION\"\n    fi\nelse\n    INPUT_READ_DURATION=\"$MAIN_VID_DURATION\"\n    EFFECTIVE_DURATION=$(awk -v m=\"$MAIN_VID_DURATION\" -v s=\"$SPEED_FACTOR_N\" 'BEGIN{ printf(\"%.3f\", m/s) }')\nfi\n\necho \"SPEED_FACTOR: $SPEED_FACTOR_N\" >&2\necho \"OVERLAY_SPEED_FACTOR: $OVERLAY_SPEED_FACTOR_N\" >&2\necho \"INPUT_READ_DURATION: $INPUT_READ_DURATION (amount to read from files)\" >&2\necho \"EFFECTIVE_DURATION: $EFFECTIVE_DURATION (output duration after speed change)\" >&2\n\nOVERLAY_READ_DURATION=$(awk -v d=\"$INPUT_READ_DURATION\" -v s=\"$OVERLAY_SPEED_FACTOR_N\" 'BEGIN{ printf(\"%.3f\", d*s) }')\necho \"OVERLAY_READ_DURATION: $OVERLAY_READ_DURATION (source duration before overlay speed adjustment)\" >&2\n\n# Rotation and crop filters\nROTATE_TAG=$(ffprobe -v error -select_streams v:0 -show_entries stream_tags=rotate -of default=nw=1:nk=1 \"$INPUT_FILE\" 2>/dev/null || printf \"0\")\nROTATION_FILTER=\"\"\ncase \"$ROTATE_TAG\" in\n  90) ROTATION_FILTER=\"transpose=1,\" ;;\n  270) ROTATION_FILTER=\"transpose=2,\" ;;\nesac\n\n# Build crop filter\nCROP_FILTER=\"\"\nif [ \"$CROP_ENABLE\" = \"true\" ]; then\n  CROP_TOP_PCT=0\n  CROP_BOTTOM_PCT=0\n\n  if [ \"$CROP_TOP_ENABLE\" = \"true\" ]; then\n    if [ -z \"${CROP_TOP_PERCENT:-}\" ]; then\n      CROP_TOP_PCT=$DEFAULT_CROP_TOP_PERCENT\n      echo \"CROP_TOP_PERCENT not set, using default: ${DEFAULT_CROP_TOP_PERCENT}%\" >&2\n    else\n      case \"$CROP_TOP_PERCENT\" in\n        ''|*[!0-9]*)\n          CROP_TOP_PCT=$DEFAULT_CROP_TOP_PERCENT\n          echo \"CROP_TOP_PERCENT invalid, using default: ${DEFAULT_CROP_TOP_PERCENT}%\" >&2\n          ;;\n        *)\n          CROP_TOP_PCT=$CROP_TOP_PERCENT\n          ;;\n      esac\n    fi\n  fi\n\n  if [ \"$CROP_BOTTOM_ENABLE\" = \"true\" ]; then\n    if [ -z \"${CROP_BOTTOM_PERCENT:-}\" ]; then\n      CROP_BOTTOM_PCT=$DEFAULT_CROP_BOTTOM_PERCENT\n      echo \"CROP_BOTTOM_PERCENT not set, using default: ${DEFAULT_CROP_BOTTOM_PERCENT}%\" >&2\n    else\n      case \"$CROP_BOTTOM_PERCENT\" in\n        ''|*[!0-9]*)\n          CROP_BOTTOM_PCT=$DEFAULT_CROP_BOTTOM_PERCENT\n          echo \"CROP_BOTTOM_PERCENT invalid, using default: ${DEFAULT_CROP_BOTTOM_PERCENT}%\" >&2\n          ;;\n        *)\n          CROP_BOTTOM_PCT=$CROP_BOTTOM_PERCENT\n          ;;\n      esac\n    fi\n  fi\n\n  TOTAL_CROP_PCT=$((CROP_TOP_PCT + CROP_BOTTOM_PCT))\n\n  if [ \"$TOTAL_CROP_PCT\" -gt 0 ] && [ \"$TOTAL_CROP_PCT\" -lt 100 ]; then\n    KEEP_PCT=$((100 - TOTAL_CROP_PCT))\n    echo \"Crop settings: Top=${CROP_TOP_PCT}%, Bottom=${CROP_BOTTOM_PCT}%, Keeping=${KEEP_PCT}%\" >&2\n    CROP_FILTER=\"crop=in_w:in_h*${KEEP_PCT}/100:0:in_h*${CROP_TOP_PCT}/100,\"\n  elif [ \"$TOTAL_CROP_PCT\" -ge 100 ]; then\n    echo \"WARNING: Total crop percentage >= 100%, disabling crop\" >&2\n    CROP_FILTER=\"\"\n  fi\nfi\n\n# Determine available canvas space for overlay\nMAIN_RES=$(probe_resolution \"$INPUT_FILE\" || true)\nif [ -n \"$MAIN_RES\" ]; then\n  MAIN_SRC_W=$(printf \"%s\" \"$MAIN_RES\" | awk -Fx '{print $1}')\n  MAIN_SRC_H=$(printf \"%s\" \"$MAIN_RES\" | awk -Fx '{print $2}')\nelse\n  MAIN_SRC_W=1920; MAIN_SRC_H=1080\nfi\n\nMAIN_KEEP_PCT=100\nif [ \"$CROP_ENABLE\" = \"true\" ]; then\n  MAIN_KEEP_PCT=$((100 - ${CROP_TOP_PCT:-0} - ${CROP_BOTTOM_PCT:-0}))\n  if [ \"$MAIN_KEEP_PCT\" -le 0 ]; then MAIN_KEEP_PCT=100; fi\nfi\n\nMAIN_POST_HEIGHT=$(awk -v h=\"$MAIN_SRC_H\" -v pct=\"$MAIN_KEEP_PCT\" 'BEGIN{ printf(\"%.6f\", h*pct/100.0) }')\nMAIN_SCALED_HEIGHT=$(awk -v cw=\"$CANVAS_WIDTH\" -v mh=\"$MAIN_POST_HEIGHT\" -v mw=\"$MAIN_SRC_W\" 'BEGIN{ if(mw<=0) printf(\"%.6f\", 0); else printf(\"%.6f\", cw*mh/mw) }')\nAVAILABLE_HEIGHT=$(awk -v ch=\"$CANVAS_HEIGHT\" -v mh=\"$MAIN_SCALED_HEIGHT\" 'BEGIN{ v=ch-mh; if (v<0.0) v=ch*0.35; if (v<50) v=ch*0.35; if (v<1) v=1; printf(\"%.6f\", v) }')\nAVAILABLE_HEIGHT_INT=$(awk -v v=\"$AVAILABLE_HEIGHT\" 'BEGIN{ if(v<1) v=1; printf(\"%d\", v) }')\n\n# Overlay aspect after trimming\nTRIM_LEFT_VAL=${OVERLAY_TRIM_LEFT:-0}\nTRIM_RIGHT_VAL=${OVERLAY_TRIM_RIGHT:-0}\nOVERLAY_TRIMMED_WIDTH=$(awk -v w=\"$O_W\" -v l=\"$TRIM_LEFT_VAL\" -v r=\"$TRIM_RIGHT_VAL\" 'BEGIN{ val=w-l-r; if (val<1) val=1; printf(\"%.6f\", val) }')\nOVERLAY_TRIMMED_HEIGHT=$(awk -v h=\"$O_H\" 'BEGIN{ if(h<1) h=1; printf(\"%.6f\", h) }')\nOVERLAY_ASPECT=$(awk -v w=\"$OVERLAY_TRIMMED_WIDTH\" -v h=\"$OVERLAY_TRIMMED_HEIGHT\" 'BEGIN{ if(h<=0) printf(\"1.0\"); else printf(\"%.6f\", w/h) }')\n\n# Resolve user-provided overlay dimensions (pixels, percent, or auto)\nOVERLAY_WIDTH_EXPLICIT=0\nRAW_OVERLAY_WIDTH=\"$OVERLAY_WIDTH\"\ncase \"$RAW_OVERLAY_WIDTH\" in\n  \"\"|auto|AUTO|Auto)\n    RAW_OVERLAY_WIDTH=\"\"\n    ;;\n  *%)\n    PCT=${RAW_OVERLAY_WIDTH%%%}\n    if [ -n \"$PCT\" ]; then\n      RAW_OVERLAY_WIDTH=$(awk -v base=\"$CANVAS_WIDTH\" -v pct=\"$PCT\" 'BEGIN{ printf(\"%.6f\", base*pct/100.0) }')\n      OVERLAY_WIDTH_EXPLICIT=1\n    else\n      RAW_OVERLAY_WIDTH=\"\"\n    fi\n    ;;\n  *)\n    RAW_OVERLAY_WIDTH=$(awk -v v=\"$RAW_OVERLAY_WIDTH\" 'BEGIN{ printf(\"%.6f\", v+0) }')\n    OVERLAY_WIDTH_EXPLICIT=1\n    ;;\nesac\n\nOVERLAY_HEIGHT_EXPLICIT=0\nRAW_OVERLAY_HEIGHT=\"$OVERLAY_HEIGHT\"\ncase \"$RAW_OVERLAY_HEIGHT\" in\n  \"\"|auto|AUTO|Auto)\n    RAW_OVERLAY_HEIGHT=\"\"\n    ;;\n  *%)\n    PCT=${RAW_OVERLAY_HEIGHT%%%}\n    if [ -n \"$PCT\" ]; then\n      RAW_OVERLAY_HEIGHT=$(awk -v base=\"$CANVAS_HEIGHT\" -v pct=\"$PCT\" 'BEGIN{ printf(\"%.6f\", base*pct/100.0) }')\n      OVERLAY_HEIGHT_EXPLICIT=1\n    else\n      RAW_OVERLAY_HEIGHT=\"\"\n    fi\n    ;;\n  *)\n    RAW_OVERLAY_HEIGHT=$(awk -v v=\"$RAW_OVERLAY_HEIGHT\" 'BEGIN{ printf(\"%.6f\", v+0) }')\n    OVERLAY_HEIGHT_EXPLICIT=1\n    ;;\nesac\n\nWIDTH_BASE=\"$RAW_OVERLAY_WIDTH\"\nHEIGHT_BASE=\"$RAW_OVERLAY_HEIGHT\"\n\nif [ -z \"$WIDTH_BASE\" ] && [ -z \"$HEIGHT_BASE\" ]; then\n  HEIGHT_BASE=$AVAILABLE_HEIGHT_INT\n  if [ -z \"$HEIGHT_BASE\" ] || [ \"$HEIGHT_BASE\" -le 0 ]; then\n    HEIGHT_BASE=$(awk -v ch=\"$CANVAS_HEIGHT\" 'BEGIN{ printf(\"%.6f\", ch*0.35) }')\n  fi\n  WIDTH_BASE=$(awk -v h=\"$HEIGHT_BASE\" -v aspect=\"$OVERLAY_ASPECT\" 'BEGIN{ printf(\"%.6f\", h*aspect) }')\nelif [ -z \"$HEIGHT_BASE\" ]; then\n  HEIGHT_BASE=$(awk -v w=\"$WIDTH_BASE\" -v aspect=\"$OVERLAY_ASPECT\" 'BEGIN{ if(aspect<=0) aspect=1; printf(\"%.6f\", w/aspect) }')\nelif [ -z \"$WIDTH_BASE\" ]; then\n  WIDTH_BASE=$(awk -v h=\"$HEIGHT_BASE\" -v aspect=\"$OVERLAY_ASPECT\" 'BEGIN{ printf(\"%.6f\", h*aspect) }')\nfi\n\nOVERLAY_FINAL_WIDTH=$(awk -v w=\"$WIDTH_BASE\" -v s=\"$OVERLAY_SCALE_PERCENT\" 'BEGIN{ printf(\"%.6f\", w*s/100.0) }')\nOVERLAY_FINAL_HEIGHT=$(awk -v h=\"$HEIGHT_BASE\" -v s=\"$OVERLAY_SCALE_PERCENT\" 'BEGIN{ printf(\"%.6f\", h*s/100.0) }')\n\nOVERLAY_ALLOW_OVERFLOW=$(awk -v s=\"$OVERLAY_SCALE_PERCENT\" 'BEGIN{ if(s==\"\") s=100; if(s+0>100) print 1; else print 0 }')\nOVERLAY_FINAL_WIDTH_INT=$(awk -v w=\"$OVERLAY_FINAL_WIDTH\" 'BEGIN{ if(w<1) w=1; printf(\"%d\", w) }')\nOVERLAY_FINAL_HEIGHT_INT=$(awk -v h=\"$OVERLAY_FINAL_HEIGHT\" 'BEGIN{ if(h<1) h=1; printf(\"%d\", h) }')\n\nif [ \"$OVERLAY_FINAL_WIDTH_INT\" -gt \"$CANVAS_WIDTH\" ]; then\n  if [ \"$OVERLAY_WIDTH_EXPLICIT\" -eq 0 ]; then\n    OVERLAY_FINAL_WIDTH_INT=$CANVAS_WIDTH\n    OVERLAY_FINAL_HEIGHT_INT=$(awk -v w=\"$OVERLAY_FINAL_WIDTH_INT\" -v aspect=\"$OVERLAY_ASPECT\" 'BEGIN{ if(aspect<=0) aspect=1; val=w/aspect; if(val<1) val=1; printf(\"%d\", val) }')\n  else\n    echo \"WARN: overlay width (${OVERLAY_FINAL_WIDTH_INT}px) exceeds canvas width; overlay may spill horizontally.\" >&2\n  fi\nfi\n\nif [ \"$OVERLAY_ALLOW_OVERFLOW\" -eq 0 ] && [ \"$OVERLAY_HEIGHT_EXPLICIT\" -eq 0 ]; then\n  if [ \"$AVAILABLE_HEIGHT_INT\" -gt 0 ] && [ \"$OVERLAY_FINAL_HEIGHT_INT\" -gt \"$AVAILABLE_HEIGHT_INT\" ]; then\n    OVERLAY_FINAL_HEIGHT_INT=$AVAILABLE_HEIGHT_INT\n    OVERLAY_FINAL_WIDTH_INT=$(awk -v h=\"$OVERLAY_FINAL_HEIGHT_INT\" -v aspect=\"$OVERLAY_ASPECT\" 'BEGIN{ val=h*aspect; if(val<1) val=1; printf(\"%d\", val) }')\n    if [ \"$OVERLAY_FINAL_WIDTH_INT\" -gt \"$CANVAS_WIDTH\" ]; then\n      OVERLAY_FINAL_WIDTH_INT=$CANVAS_WIDTH\n    fi\n  fi\nfi\n\nif [ \"$OVERLAY_FINAL_HEIGHT_INT\" -gt \"$CANVAS_HEIGHT\" ]; then\n  OVERLAY_FINAL_HEIGHT_INT=$CANVAS_HEIGHT\n  if [ \"$OVERLAY_HEIGHT_EXPLICIT\" -eq 0 ]; then\n    OVERLAY_FINAL_WIDTH_INT=$(awk -v h=\"$OVERLAY_FINAL_HEIGHT_INT\" -v aspect=\"$OVERLAY_ASPECT\" 'BEGIN{ val=h*aspect; if(val<1) val=1; printf(\"%d\", val) }')\n    if [ \"$OVERLAY_FINAL_WIDTH_INT\" -gt \"$CANVAS_WIDTH\" ]; then\n      OVERLAY_FINAL_WIDTH_INT=$CANVAS_WIDTH\n    fi\n  fi\nfi\n\nif [ \"$OVERLAY_FINAL_WIDTH_INT\" -lt 1 ]; then OVERLAY_FINAL_WIDTH_INT=1; fi\nif [ \"$OVERLAY_FINAL_HEIGHT_INT\" -lt 1 ]; then OVERLAY_FINAL_HEIGHT_INT=1; fi\n\nOVERLAY_SIZE_FILTER=\"scale=${OVERLAY_FINAL_WIDTH_INT}:${OVERLAY_FINAL_HEIGHT_INT}\"\n\n# Calculate position based on OVERLAY_POSITION setting\ncase \"$OVERLAY_POSITION\" in\n  top)\n    OVERLAY_X=\"(W-w)/2\"\n    OVERLAY_Y=\"0\"\n    ;;\n  bottom)\n    OVERLAY_X=\"(W-w)/2\"\n    OVERLAY_Y=\"H-h\"\n    ;;\n  center)\n    OVERLAY_X=\"(W-w)/2\"\n    OVERLAY_Y=\"(H-h)/2\"\n    ;;\n  custom)\n    OVERLAY_X=\"$OVERLAY_CUSTOM_X\"\n    OVERLAY_Y=\"$OVERLAY_CUSTOM_Y\"\n    ;;\n  *)\n    echo \"WARN: Invalid OVERLAY_POSITION, using bottom\" >&2\n    OVERLAY_X=\"(W-w)/2\"\n    OVERLAY_Y=\"H-h\"\n    ;;\nesac\n\necho \"Overlay positioning: ${OVERLAY_POSITION} at X=${OVERLAY_X}, Y=${OVERLAY_Y}, size=${OVERLAY_FINAL_WIDTH_INT}x${OVERLAY_FINAL_HEIGHT_INT}\" >&2\n\n# Calculate position based on OVERLAY_POSITION setting\ncase \"$OVERLAY_POSITION\" in\n  top)\n    OVERLAY_X=\"(W-w)/2\"\n    OVERLAY_Y=\"0\"\n    ;;\n  bottom)\n    OVERLAY_X=\"(W-w)/2\"\n    OVERLAY_Y=\"H-h\"\n    ;;\n  center)\n    OVERLAY_X=\"(W-w)/2\"\n    OVERLAY_Y=\"(H-h)/2\"\n    ;;\n  custom)\n    OVERLAY_X=\"$OVERLAY_CUSTOM_X\"\n    OVERLAY_Y=\"$OVERLAY_CUSTOM_Y\"\n    ;;\n  *)\n    echo \"WARN: Invalid OVERLAY_POSITION, using bottom\" >&2\n    OVERLAY_X=\"(W-w)/2\"\n    OVERLAY_Y=\"H-h\"\n    ;;\nesac\n\necho \"Overlay positioning: ${OVERLAY_POSITION} at X=${OVERLAY_X}, Y=${OVERLAY_Y}, size=${OVERLAY_FINAL_WIDTH_INT}x${OVERLAY_FINAL_HEIGHT_INT}\" >&2\n\n# Main video vertical position\ncase \"$MAIN_POSITION\" in\n  top)\n    MAIN_Y=\"0\"\n    ;;\n  bottom)\n    MAIN_Y=\"H-h\"\n    ;;\n  center)\n    MAIN_Y=\"(H-h)/2\"\n    ;;\n  custom)\n    MAIN_Y=\"$MAIN_CUSTOM_Y\"\n    ;;\n  *)\n    echo \"WARN: Invalid MAIN_POSITION, using top\" >&2\n    MAIN_Y=\"0\"\n    ;;\nesac\n\necho \"Main positioning: ${MAIN_POSITION} at Y=${MAIN_Y}\" >&2\n\n# Mirror filter\nMIRROR_FILTER=\"\"\nif [ \"$MIRROR_ENABLE\" = \"true\" ]; then\n  MIRROR_FILTER=\"hflip,\"\nfi\n\n# Calculate input indices\nINPUT_INDEX=0\nOVERLAY_INDEX=1\nCAPTION_INDEX=\"\"\nRANDOM_INSERT_INDEX=\"\"\nOUTRO_INDEX=\"\"\n\nif [ \"$CAPTION_ENABLE\" = \"true\" ]; then\n  CAPTION_INDEX=2\n  NEXT_INDEX=3\nelse\n  NEXT_INDEX=2\nfi\n\nif [ -n \"$RANDOM_INSERT_FILE\" ]; then\n  RANDOM_INSERT_INDEX=$NEXT_INDEX\n  NEXT_INDEX=$((NEXT_INDEX + 1))\nfi\n\nif [ -n \"$OUTRO_FILE\" ]; then\n  OUTRO_INDEX=$NEXT_INDEX\nfi\n\n# Build main composition base - optimized for VPS performance\n# Format conversion done once, reduced filter complexity\nif [ \"$CAPTION_ENABLE\" = \"true\" ]; then\n  BASE_FILTER=\"color=c=black:s=1080x1920:d=${EFFECTIVE_DURATION}[canvas]; \\\n[${INPUT_INDEX}:v]trim=duration=${INPUT_READ_DURATION},setpts=PTS-STARTPTS,${ROTATION_FILTER}${CROP_FILTER}scale=1080:-1,${MIRROR_FILTER}fps=${TARGET_FPS},format=yuv420p[main_video]; \\\n[${OVERLAY_INDEX}:v]trim=duration=${OVERLAY_READ_DURATION},setpts=PTS-STARTPTS,${OVERLAY_PRE_EFFECTS}${OVERLAY_SIZE_FILTER},format=yuva420p,${OVERLAY_EFFECTS}fps=${TARGET_FPS},setpts=PTS/${OVERLAY_SPEED_FACTOR_N},tpad=stop_mode=clone:stop_duration=${INPUT_READ_DURATION}[overlay_video]; \\\n[canvas][main_video]overlay=(W-w)/2:${MAIN_Y}[bg_with_main]; \\\n[bg_with_main][overlay_video]overlay=${OVERLAY_X}:${OVERLAY_Y}:format=auto:eof_action=repeat[layout_complete]; \\\n[layout_complete][${CAPTION_INDEX}:v]overlay=0:0,setsar=1,setpts=PTS/${SPEED_FACTOR_N}[composed_main]\"\nelse\n  BASE_FILTER=\"color=c=black:s=1080x1920:d=${EFFECTIVE_DURATION}[canvas]; \\\n[${INPUT_INDEX}:v]trim=duration=${INPUT_READ_DURATION},setpts=PTS-STARTPTS,${ROTATION_FILTER}${CROP_FILTER}scale=1080:-1,${MIRROR_FILTER}fps=${TARGET_FPS},format=yuv420p[main_video]; \\\n[${OVERLAY_INDEX}:v]trim=duration=${OVERLAY_READ_DURATION},setpts=PTS-STARTPTS,${OVERLAY_PRE_EFFECTS}${OVERLAY_SIZE_FILTER},format=yuva420p,${OVERLAY_EFFECTS}fps=${TARGET_FPS},setpts=PTS/${OVERLAY_SPEED_FACTOR_N},tpad=stop_mode=clone:stop_duration=${INPUT_READ_DURATION}[overlay_video]; \\\n[canvas][main_video]overlay=(W-w)/2:${MAIN_Y}[bg_with_main]; \\\n[bg_with_main][overlay_video]overlay=${OVERLAY_X}:${OVERLAY_Y}:format=auto:eof_action=repeat,setsar=1,setpts=PTS/${SPEED_FACTOR_N}[composed_main]\"\nfi\n\n# Assemble filter complex incrementally\nFILTER_LINES=\"\"\nappend_filter() {\n  if [ -z \"$FILTER_LINES\" ]; then\n    FILTER_LINES=\"$1\"\n  else\n    FILTER_LINES=\"${FILTER_LINES}; ${1}\"\n  fi\n}\n\nappend_filter \"$BASE_FILTER\"\n\n# Build the audio tempo chain for main audio\nAUDIO_TEMPO_CHAIN=\"\"\nif [ \"$SPEED_FACTOR_N\" != \"1.000000\" ]; then\n  export SPEED_FACTOR_N\n  AUDIO_TEMPO_CHAIN=$(python3 - <<'PY'\nimport os\ns = float(os.environ.get('SPEED_FACTOR_N','1'))\nif s <= 0:\n    print(\"atempo=1.0\")\nelse:\n    factors = []\n    tmp = s\n    while tmp > 2.0000001:\n        factors.append(2.0)\n        tmp = tmp / 2.0\n    while tmp < 0.5 - 1e-12:\n        factors.append(0.5)\n        tmp = tmp / 0.5\n    factors.append(round(tmp, 6))\n    out = \",\".join(f\"atempo={f:.6f}\" for f in factors)\n    print(out)\nPY\n)\n  echo \"AUDIO_TEMPO_CHAIN: $AUDIO_TEMPO_CHAIN\" >&2\nfi\n\nOVERLAY_ATEMPO_CHAIN=\"\"\nif [ \"$OVERLAY_SPEED_FACTOR_N\" != \"1.000000\" ]; then\n  export OVERLAY_SPEED_FACTOR_N\n  OVERLAY_ATEMPO_CHAIN=$(python3 - <<'PY'\nimport os\ns = float(os.environ.get('OVERLAY_SPEED_FACTOR_N','1'))\nif s <= 0:\n    print(\"atempo=1.0\")\nelse:\n    factors = []\n    tmp = s\n    while tmp > 2.0000001:\n        factors.append(2.0)\n        tmp = tmp / 2.0\n    while tmp < 0.5 - 1e-12:\n        factors.append(0.5)\n        tmp = tmp / 0.5\n    factors.append(round(tmp, 6))\n    out = \",\".join(f\"atempo={f:.6f}\" for f in factors)\n    print(out)\nPY\n)\n  echo \"OVERLAY_ATEMPO_CHAIN: $OVERLAY_ATEMPO_CHAIN\" >&2\nfi\n\nOVERLAY_AUDIO_RATE_FILTER=\"asetpts=PTS-STARTPTS\"\nif [ -n \"$OVERLAY_ATEMPO_CHAIN\" ]; then\n  OVERLAY_AUDIO_RATE_FILTER=\"$OVERLAY_AUDIO_RATE_FILTER,$OVERLAY_ATEMPO_CHAIN\"\nfi\n\n# ========== AUDIO HANDLING ==========\nAUDIO_FILTER=\"\"\nAUDIO_MAP=\"0:a?\"\n\n# NEW: Mix main audio with overlay audio FIRST (before random insert)\nif [ \"$OVERLAY_AUDIO_ENABLE\" = \"true\" ]; then\n  echo \"=== Mixing main audio with overlay audio at ${OVERLAY_AUDIO_VOLUME}% ===\" >&2\n\n  # Build base mixed audio (main + overlay) - use amerge with proper volume normalization\n  if [ -n \"$AUDIO_TEMPO_CHAIN\" ]; then\n    BASE_AUDIO_MIX=\"[0:a]atrim=duration=${INPUT_READ_DURATION},asetpts=PTS-STARTPTS,${AUDIO_TEMPO_CHAIN}[main_tempo]; \\\n[${OVERLAY_INDEX}:a]atrim=duration=${OVERLAY_READ_DURATION},${OVERLAY_AUDIO_RATE_FILTER},apad=pad_dur=${INPUT_READ_DURATION},volume=${OVERLAY_VOLUME_FLOAT}[overlay_vol]; \\\n[main_tempo][overlay_vol]amix=inputs=2:duration=longest:dropout_transition=2,volume=2[base_mixed]\"\n  else\n    BASE_AUDIO_MIX=\"[0:a]atrim=duration=${INPUT_READ_DURATION},asetpts=PTS-STARTPTS[main_a]; \\\n[${OVERLAY_INDEX}:a]atrim=duration=${OVERLAY_READ_DURATION},${OVERLAY_AUDIO_RATE_FILTER},apad=pad_dur=${INPUT_READ_DURATION},volume=${OVERLAY_VOLUME_FLOAT}[overlay_vol]; \\\n[main_a][overlay_vol]amix=inputs=2:duration=longest:dropout_transition=2,volume=2[base_mixed]\"\n  fi\n\n  AUDIO_FILTER=\"$BASE_AUDIO_MIX\"\n  MIXED_AUDIO_LABEL=\"[base_mixed]\"\nelse\n  # No overlay audio - just use main audio\n  if [ -n \"$AUDIO_TEMPO_CHAIN\" ]; then\n    AUDIO_FILTER=\"[0:a]atrim=duration=${INPUT_READ_DURATION},asetpts=PTS-STARTPTS,${AUDIO_TEMPO_CHAIN}[base_mixed]\"\n    MIXED_AUDIO_LABEL=\"[base_mixed]\"\n  else\n    MIXED_AUDIO_LABEL=\"0:a\"\n  fi\nfi\n\n# ========== RANDOM INSERT (video + audio) ==========\nif [ -n \"$RANDOM_INSERT_FILE\" ]; then\n  INSERT_DURATION=$(probe_duration \"$RANDOM_INSERT_FILE\" || printf \"2\")\n  INSERT_DURATION=$(awk -v v=\"$INSERT_DURATION\" 'BEGIN{ printf(\"%.3f\", v+0)}')\n  echo \"Random insert duration: $INSERT_DURATION seconds\" >&2\n\n  export EFFECTIVE_DURATION INSERT_DURATION\n  RANDOM_POS=$(python3 - <<'PY'\nimport os, struct\nefd = float(os.environ.get('EFFECTIVE_DURATION','0'))\nidur = float(os.environ.get('INSERT_DURATION','0'))\nminpos = 3.0\nmaxpos = efd - idur - 1.0\nif maxpos < minpos:\n    maxpos = minpos\nr = struct.unpack(\">I\", os.urandom(4))[0] / 4294967295.0\nv = minpos + r * (maxpos - minpos)\nprint(f\"{v:.3f}\")\nPY\n)\n  echo \"Random insert at: ${RANDOM_POS}s\" >&2\n\n  BEFORE_INSERT=$(awk -v p=\"$RANDOM_POS\" 'BEGIN{ printf(\"%.3f\", p) }')\n  NEW_DURATION=$(awk -v e=\"$EFFECTIVE_DURATION\" -v i=\"$INSERT_DURATION\" 'BEGIN{ printf(\"%.3f\", e+i) }')\n\n  # VIDEO insert\n  VIDEO_INSERT_BLOCK=\"[composed_main]fps=${TARGET_FPS},split=2[main1][main2]; \\\n[main1]trim=start=0:end=${BEFORE_INSERT},setpts=PTS-STARTPTS[seg1]; \\\n[main2]trim=start=${BEFORE_INSERT},setpts=PTS-STARTPTS[seg3]; \\\n[${RANDOM_INSERT_INDEX}:v]scale=1080:1920:force_original_aspect_ratio=decrease,pad=1080:1920:(ow-iw)/2:(oh-ih)/2,setsar=1,fps=${TARGET_FPS},setpts=PTS-STARTPTS[insert_scaled]; \\\n[seg1][insert_scaled][seg3]concat=n=3:v=1:a=0[concat_v]; \\\n[concat_v]fps=${TARGET_FPS}[final_v]\"\n\n  append_filter \"$VIDEO_INSERT_BLOCK\"\n\n  # AUDIO insert - split the mixed audio\n  if [ -n \"$AUDIO_FILTER\" ]; then\n    AUDIO_FILTER=\"${AUDIO_FILTER}; \\\n${MIXED_AUDIO_LABEL}asplit=2[mix1][mix2]; \\\n[mix1]atrim=start=0:end=${BEFORE_INSERT},asetpts=PTS-STARTPTS[a1]; \\\n[mix2]atrim=start=${BEFORE_INSERT},asetpts=PTS-STARTPTS[a3]; \\\n[${RANDOM_INSERT_INDEX}:a]asetpts=PTS-STARTPTS[insert_audio]; \\\n[a1][insert_audio][a3]concat=n=3:v=0:a=1[final_audio]\"\n  fi\n\n  EFFECTIVE_DURATION=\"$NEW_DURATION\"\n  AUDIO_MAP=\"[final_audio]\"\nelse\n  # No random insert - use the base mixed audio\n  if [ -n \"$AUDIO_FILTER\" ]; then\n    AUDIO_FILTER=\"${AUDIO_FILTER}; ${MIXED_AUDIO_LABEL}acopy[final_audio]\"\n    AUDIO_MAP=\"[final_audio]\"\n  else\n    AUDIO_MAP=\"${MIXED_AUDIO_LABEL}\"\n  fi\nfi\n\n# ========== OUTRO (video + audio) ==========\nif [ -n \"$OUTRO_FILE\" ] && [ -n \"$OUTRO_INDEX\" ]; then\n  OUTRO_START=$(awk -v d=\"$EFFECTIVE_DURATION\" -v t=\"$OUTRO_TRANSITION_DURATION\" 'BEGIN{ printf(\"%.3f\", d-t) }')\n\n  # VIDEO outro\n  if [ -n \"$RANDOM_INSERT_FILE\" ]; then\n    OUTRO_VIDEO_BLOCK=\"[${OUTRO_INDEX}:v]scale=1080:1920:force_original_aspect_ratio=decrease,pad=1080:1920:(ow-iw)/2:(oh-ih)/2,setsar=1,setpts=PTS-STARTPTS[outro_scaled]; \\\n[final_v]fps=${TARGET_FPS},setsar=1,setpts=PTS-STARTPTS[main_normalized]; \\\n[main_normalized]fps=${TARGET_FPS}[main_normalized_fps]; \\\n[outro_scaled]fps=${TARGET_FPS}[outro_scaled_fps]; \\\n[main_normalized_fps][outro_scaled_fps]xfade=transition=fade:duration=${OUTRO_TRANSITION_DURATION}:offset=${OUTRO_START}[final_v]\"\n    append_filter \"$OUTRO_VIDEO_BLOCK\"\n  else\n    OUTRO_VIDEO_BLOCK=\"[${OUTRO_INDEX}:v]scale=1080:1920:force_original_aspect_ratio=decrease,pad=1080:1920:(ow-iw)/2:(oh-ih)/2,setsar=1,setpts=PTS-STARTPTS[outro_scaled]; \\\n[composed_main]fps=${TARGET_FPS},setsar=1,setpts=PTS-STARTPTS[main_normalized]; \\\n[main_normalized]fps=${TARGET_FPS}[main_normalized_fps]; \\\n[outro_scaled]fps=${TARGET_FPS}[outro_scaled_fps]; \\\n[main_normalized_fps][outro_scaled_fps]xfade=transition=fade:duration=${OUTRO_TRANSITION_DURATION}:offset=${OUTRO_START}[final_v]\"\n    append_filter \"$OUTRO_VIDEO_BLOCK\"\n  fi\n\n  # AUDIO outro\n  if [ -n \"$AUDIO_FILTER\" ]; then\n    AUDIO_FILTER=\"${AUDIO_FILTER}; \\\n[${OUTRO_INDEX}:a]asetpts=PTS-STARTPTS[outro_a]; \\\n[final_audio][outro_a]concat=n=2:v=0:a=1[final_audio]\"\n  fi\n\n  OUTPUT_LABEL=\"[final_v]\"\nelse\n  if [ -n \"$RANDOM_INSERT_FILE\" ]; then\n    OUTPUT_LABEL=\"[final_v]\"\n  else\n    append_filter \"[composed_main]fps=${TARGET_FPS}[final_v]\"\n    OUTPUT_LABEL=\"[final_v]\"\n  fi\nfi\n\n# Final brightness application\nif [ \"$(awk -v b=\"$BRIGHTNESS\" 'BEGIN{ if (b==0) print \"0\"; else print \"1\" }')\" = \"1\" ]; then\n  append_filter \"[final_v]eq=brightness=${BRIGHTNESS}[final_v_out]\"\n  FINAL_OUTPUT_LABEL=\"[final_v_out]\"\nelse\n  FINAL_OUTPUT_LABEL=\"${OUTPUT_LABEL}\"\nfi\n\n# Combine all filters\nif [ -n \"$AUDIO_FILTER\" ]; then\n  COMPLETE_FILTER=\"${FILTER_LINES}; ${AUDIO_FILTER}\"\nelse\n  COMPLETE_FILTER=\"${FILTER_LINES}\"\nfi\n\n# Build input args\nINPUT_ARGS=\"\"\nOVERLAY_LOOP_PREFIX=\"\"\nif [ \"$OVERLAY_LOOP_ENABLE\" = \"true\" ]; then\n  OVERLAY_LOOP_PREFIX=\"-stream_loop -1 \"\nfi\nif [ -n \"$TRIM_DURATION\" ]; then\n  INPUT_ARGS=\"-t ${INPUT_READ_DURATION} -i \\\"$INPUT_FILE\\\" ${OVERLAY_LOOP_PREFIX}-t ${OVERLAY_READ_DURATION} -i \\\"$MERGED_OVERLAY\\\"\"\nelse\n  INPUT_ARGS=\"-i \\\"$INPUT_FILE\\\" ${OVERLAY_LOOP_PREFIX}-i \\\"$MERGED_OVERLAY\\\"\"\nfi\n\nif [ \"$CAPTION_ENABLE\" = \"true\" ]; then\n  INPUT_ARGS=\"$INPUT_ARGS -i \\\"$CAPTION_PNG\\\"\"\nfi\n\nif [ -n \"$RANDOM_INSERT_FILE\" ]; then\n  INPUT_ARGS=\"$INPUT_ARGS -i \\\"$RANDOM_INSERT_FILE\\\"\"\nfi\n\nif [ -n \"$OUTRO_FILE\" ]; then\n  INPUT_ARGS=\"$INPUT_ARGS -i \\\"$OUTRO_FILE\\\"\"\nfi\n\n# Build final ffmpeg command\nCMD=\"ffmpeg -hide_banner -y -progress pipe:2 -loglevel warning $INPUT_ARGS -filter_complex \\\"${COMPLETE_FILTER}\\\" -map \\\"${FINAL_OUTPUT_LABEL}\\\"\"\n\nif [ -n \"$AUDIO_FILTER\" ]; then\n  CMD=\"$CMD -map \\\"${AUDIO_MAP}\\\"\"\nelse\n  CMD=\"$CMD -map ${AUDIO_MAP}\"\nfi\n\nCMD=\"$CMD -c:v libx264 -crf ${ENCODING_CRF} -preset ${ENCODING_PRESET} -threads ${FFMPEG_THREADS} -c:a aac -b:a 128k -r ${TARGET_FPS} -aspect 9:16\"\n\nif [ -n \"$TRIM_DURATION\" ] && [ -z \"$OUTRO_FILE\" ]; then\n  CMD=\"$CMD -t ${EFFECTIVE_DURATION}\"\nfi\n\nCMD=\"$CMD \\\"$OUT_FILE\\\"\"\n\n# Debug output\necho \"=== DEBUG: filter_complex ===\" >&2\necho \"$COMPLETE_FILTER\" >&2\necho \"=== DEBUG: ffmpeg cmd ===\" >&2\necho \"$CMD\" >&2\n\n# Execute\necho \"Executing final render with overlay audio support...\" >&2\necho \"Progress will be shown below:\" >&2\n\nif sh -c \"$CMD\" < /dev/null; then\n  [ \"$CAPTION_ENABLE\" = \"true\" ] && rm -f \"$CAPTION_PNG\" || true\n  [ -n \"$MERGED_OVERLAY_TMP\" ] && [ -f \"$MERGED_OVERLAY_TMP\" ] && rm -f \"$MERGED_OVERLAY_TMP\" || true\n  [ -n \"$COMPOSED_MAIN_TMP\" ] && [ -f \"$COMPOSED_MAIN_TMP\" ] && rm -f \"$COMPOSED_MAIN_TMP\" || true\n  echo \"Success! Output file: $OUT_FILE\" >&2\n  printf '%s\\n' \"$(basename \"$OUT_FILE\")\"\n  exit 0\nelse\n  echo \"ERR: ffmpeg failed or timed out.\" >&2\n  echo \"Check the debug output above for details.\" >&2\n  exit 1\nfi\n"
      },
      "type": "n8n-nodes-base.executeCommand",
      "typeVersion": 1,
      "position": [
        -2544,
        -1440
      ],
      "id": "7aa6a58f-b5d1-4497-9654-debdc6ffba9a",
      "name": "Reaction1"
    },
    {
      "parameters": {
        "mode": "raw",
        "jsonOutput": "={\n  \"SCRIPT_DIR\": \"{{ $json.body.root_dir }}/files/reaction/\",\n  \"TRIM_DURATION\":\"120\",\n  \"INPUT_URL\": \"{{ $json.body.root_dir }}{{ $json.body.folder }}{{ $json.body.filename }}\",\n  \"MAIN_POSITION\": \"top\",\n  \"MAIN_CUSTOM_Y\": 0,\n  \"CROP_ENABLE\": true,\n  \"CROP_TOP_ENABLE\": true,\n  \"CROP_TOP_PERCENT\": 15,\n  \"CROP_BOTTOM_ENABLE\": true,\n  \"CROP_BOTTOM_PERCENT\": 35,\n\n  \"SPEED_FACTOR\": 1,\n  \"OVERLAY_FILE\": \"{{ $json.body.root_dir }}/files/reaction/asif.mp4\",\n  \"OVERLAY_OPACITY\":\"70\",\n  \"OVERLAY_SPEED_FACTOR\": 1.5,\n\n  \"OVERLAY_WIDTH\": \"100%\",\n  \"OVERLAY_HEIGHT\": \"50%\",\n  \"OVERLAY_CHROMA_KEY_ENABLE\": false,\n  \"OVERLAY_EDGE_TRIM\": \"LEFT/RIGHT\",\n  \"OVERLAY_EDGE_TRIM_LEFT\": \"550\",\n  \"OVERLAY_EDGE_TRIM_RIGHT\": \"\",\n  \"OVERLAY_CROP_ENABLE\": true,\n  \"OVERLAY_CROP_TOP_PERCENT\": 0,\n  \"OVERLAY_CROP_BOTTOM_PERCENT\": 0,\n  \"OVERLAY_CROP_LEFT_PERCENT\": 0,\n  \"OVERLAY_CROP_RIGHT_PERCENT\": 0,\n  \"OVERLAY_TRIM_START\": 0,\n  \"OVERLAY_TRIM_DURATION\": 0,\n  \"OVERLAY_AUDIO_ENABLE\": true,\n  \"OVERLAY_AUDIO_VOLUME\": 50,\n  \"OVERLAY_2\": \"\",\n  \"OVERLAY_2_DURATION\": 3,\n  \"OVERLAY_2_POSITION\": \"start\",\n  \"CAPTION_ENABLE\": true,\n  \"CAPTION_TEXT\": \"Your caption text here\\nSupports Hindi: à¤¨à¤®à¤¸à¥à¤¤à¥‡\\nAnd emojis: ðŸŽ¬ðŸŽ¥\",\n  \"CAPTION_FONT_PATH\": \"\",\n  \"CAPTION_FONT_SIZE\": 60,\n  \"CAPTION_POS_X_PERCENT\": 50,\n  \"CAPTION_POS_Y_PERCENT\": 75,\n  \"TEXT_BG_ENABLE\": true,\n  \"TEXT_BG_OPACITY\": 0.7,\n  \"RANDOM_INSERT_FILE\": \"\",\n  \"RANDOM_INSERT_DURATION\": 3,\n  \"OUTRO_FILE\": \"\",\n  \"OUTRO_DURATION\": 2,\n  \"TARGET_FPS\": 30,\n  \"OUT_FILE\": \"{{ $json.body.root_dir }}/{{ $json.body.folder }}output/{{ $json.body.filename }}\"\n}",
        "options": {}
      },
      "type": "n8n-nodes-base.set",
      "typeVersion": 3.4,
      "position": [
        -2752,
        -1440
      ],
      "id": "7ddabbdd-9ede-4f54-b051-5cc7013a6a2b",
      "name": "Edit Fields"
    },
    {
      "parameters": {
        "command": "=#!/bin/sh\nset -eu\n\n# Video composition script optimized for Hostinger KVM2 VPS / n8n automation\n#\n# PERFORMANCE OPTIMIZATION NOTES FOR VPS:\n# 1. ENCODING_PRESET=\"ultrafast\" - Fastest encoding (3-5x faster than default)\n# 2. ENCODING_CRF=28 - Lower quality but much faster (vs 23 = high quality)\n# 3. FFMPEG_THREADS=2 - Explicitly set for dual-core VPS (KVM2 has 2 CPU cores)\n# 4. Audio bitrate reduced to 128k (was 192k) - Faster audio encoding\n# 5. Reduced filter complexity - Single format conversion, removed redundant filters\n# 6. FPS fixed at 30 before overlays to reduce processing load\n# 7. MULTI-THREADING OPTIMIZATIONS:\n#    - THREAD_QUEUE_SIZE=512 - Buffer for each input stream (prevents thread starvation)\n#    - FILTER_THREADS=2 - Parallel processing of filter chains on dual-core CPU\n#    - SLICED_THREADS=true - Enables x264 slice-based threading (better for 2 cores)\n#    - These settings maximize utilization of both CPU cores simultaneously\n#\n# SPEED MODES AVAILABLE:\n# ----------------------\n# NORMAL MODE (default):\n#   - ENCODING_CRF=28, ENCODING_PRESET=\"ultrafast\"\n#   - 10 sec video: ~15-30 seconds on KVM2\n#   - Good quality, fast processing\n#\n# AGGRESSIVE MODE (set SPEED_MODE_AGGRESSIVE=true):\n#   - Processes at 720p then upscales to 1080p (2x faster scaling)\n#   - Uses fast_bilinear algorithm (faster than lanczos)\n#   - Applies aggressive x264 encoder tuning\n#   - 10 sec video: ~8-15 seconds on KVM2 (40-50% faster!)\n#   - Trade-off: Slightly softer/lower quality output\n#\n# MAXIMUM SPEED (for emergencies):\n#   - SPEED_MODE_AGGRESSIVE=true\n#   - ENCODING_CRF=30\n#   - TARGET_FPS=24\n#   - OVERLAY_CHROMA_KEY_ENABLE=false (if possible)\n#   - 10 sec video: ~5-10 seconds on KVM2\n#   - Trade-off: Noticeable quality reduction\n#\n# OVERLAY CONFIGURATION EXAMPLES:\n#\n# Example 1: Green screen overlay at bottom\n#   OVERLAY_POSITION=\"bottom\"\n#   OVERLAY_CHROMA_KEY_ENABLE=true\n#   OVERLAY_CHROMA_KEY_COLOR=\"green\"\n#   OVERLAY_OPACITY=100\n#\n# Example 2: Small overlay at custom position\n#   OVERLAY_POSITION=\"custom\"\n#   OVERLAY_CUSTOM_X=50\n#   OVERLAY_CUSTOM_Y=1400\n#   OVERLAY_SCALE_PERCENT=50\n#   OVERLAY_OPACITY=80\n#\n# Example 3: Centered semi-transparent overlay\n#   OVERLAY_POSITION=\"center\"\n#   OVERLAY_OPACITY=70\n#   OVERLAY_WIDTH=800\n#   OVERLAY_HEIGHT=600\n#\n# Supported formats: MP4, MOV, AVI, GIF (animated GIF supported)\n\n# ---------------- CONFIG ----------------\nSCRIPT_DIR=\"{{ $json.SCRIPT_DIR }}\"\nINPUT_URL=\"{{ $json.INPUT_URL }}\"\nOVERLAY_FILE=\"{{ $json.OVERLAY_FILE }}\"\nOVERLAY_2=\"\"\nOVERLAY_2_LENGTH_SECONDS=\"\"\nOVERLAY_2_START_SEC=\"0\"\nOVERLAY_TRANSITION_DURATION=\"0.6\"\n\nTRIM_DURATION=\"{{ $json.TRIM_DURATION }}\"  # Reduced to 10 seconds for quick testing\nOUTRO_FILE=\"\"\nOUTRO_TRANSITION_DURATION=\"0.5\"\n\n# RANDOM INSERT with AUDIO support (leave empty to disable)\nRANDOM_INSERT_FILE=\"\"\nRANDOM_INSERT_TRANSITION=\"0.2\"\n\n# NEW: Overlay audio settings\nOVERLAY_AUDIO_ENABLE=true        # Enable overlay audio preservation\nOVERLAY_AUDIO_VOLUME=80          # Volume level 1-100 (100 = original, 50 = half)\n\n# ========== OVERLAY POSITIONING & SIZING ==========\n# Position: \"top\", \"bottom\", \"center\", \"custom\"\nOVERLAY_POSITION=\"bottom\"\n# For custom position: X and Y coordinates (0-1920 for Y, 0-1080 for X)\nOVERLAY_CUSTOM_X=0\nOVERLAY_CUSTOM_Y=1200\n# Overlay size settings\nOVERLAY_WIDTH=\"100%\"               # Width in pixels (max 1080 for full width)\nOVERLAY_HEIGHT=\"50%\"             # Height in pixels (leave empty for auto based on aspect ratio)\nOVERLAY_SCALE_PERCENT=100        # Scale as percentage (100 = original size, 50 = half size)\nOVERLAY_LOOP_ENABLE=true         # Repeat overlay when shorter than main\n\n# Overlay effects\nOVERLAY_OPACITY={{ $json.OVERLAY_OPACITY }}  # Opacity 0-100 (100 = fully opaque, 0 = transparent)\nOVERLAY_CHROMA_KEY_ENABLE=true   # Enable green screen removal\nOVERLAY_CHROMA_KEY_COLOR=\"green\" # Using \"green\" keyword for chromakey filter\nOVERLAY_CHROMA_KEY_SIMILARITY=0.12 # 0.0-1.0, tuned to keep subject visible\nOVERLAY_CHROMA_KEY_BLEND=0.05     # 0.0-1.0, mild blend to soften edges\n# Optional manual edge trims (pixels). Set to >0 to remove borders after chroma key.\nOVERLAY_EDGE_TRIM=\"LEFT/RIGHT\"   # deprecated: use LEFT/RIGHT below\nOVERLAY_EDGE_TRIM_LEFT=\"{{ $json.OVERLAY_EDGE_TRIM_LEFT }}\"    # Pixels to crop from left edge or \"auto\"\nOVERLAY_EDGE_TRIM_RIGHT=\"{{ $json.OVERLAY_EDGE_TRIM_RIGHT }}\"   # Pixels to crop from right edge or \"auto\"\nOVERLAY_AUTO_TRIM_THRESHOLD=25   # Brightness threshold for auto edge trim (0-255)\nOVERLAY_AUTO_TRIM_MARGIN=6       # Extra pixels to trim beyond detected edge (safety buffer)\nOVERLAY_SPEED_FACTOR=\"{{ $json.OVERLAY_SPEED_FACTOR }}\"        # Overlay-only speed multiplier (1.0 = original)\n\n# ========== END OVERLAY SETTINGS ==========\n\nCANVAS_WIDTH=1080\nCANVAS_HEIGHT=1920\n\n# Crop settings: enable independent top/bottom cropping\nCROP_ENABLE=true\nCROP_TOP_ENABLE=true\nCROP_TOP_PERCENT={{ $json.CROP_TOP_PERCENT }}\nCROP_BOTTOM_ENABLE=true\nCROP_BOTTOM_PERCENT={{ $json.CROP_BOTTOM_PERCENT }}\n\nMAIN_POSITION=\"top\"           # Position main background: top, bottom, center, or custom\nMAIN_CUSTOM_Y=0                # Used when MAIN_POSITION=\"custom\"\n\n# Default crop values\nDEFAULT_CROP_TOP_PERCENT={{ $json.CROP_TOP_PERCENT }}\nDEFAULT_CROP_BOTTOM_PERCENT={{ $json.CROP_BOTTOM_PERCENT }}\n\n# Mirror/flip main video horizontally\nMIRROR_ENABLE=false\n\n# Speed factor (applies to composed main video + main audio)\nSPEED_FACTOR=\"1\"\n\n# Brightness adjustment for final output (-1.0 .. 1.0)\nBRIGHTNESS=\"0.1\"\n\n# Force Instagram-friendly fps\nTARGET_FPS=30\n\n# FFmpeg performance settings for VPS/cloud hosting\n# Number of CPU threads to use (0 = auto-detect, or set to specific number like 2, 4)\n# For KVM2 (2 cores): Set to 2 for optimal performance\nFFMPEG_THREADS=2\n# Encoding preset: ultrafast, superfast, veryfast, faster, fast, medium\n# ultrafast = fastest encoding, larger file size\n# veryfast = good balance for VPS\nENCODING_PRESET=\"ultrafast\"\n# CRF quality: 18-28 (lower = better quality, slower; 23-28 recommended for VPS)\nENCODING_CRF=28\n\n# Multi-threading optimizations for dual-core VPS\nTHREAD_QUEUE_SIZE=512        # Input thread queue (higher = smoother parallel processing)\nFILTER_THREADS=2             # Parallel filter processing threads\nSLICED_THREADS=true          # Enable slice-based multithreading (better CPU utilization)\n\n# ADVANCED SPEED OPTIMIZATIONS (set to true for maximum speed)\n# These provide 20-40% additional speed boost but with quality trade-offs\nSPEED_MODE_AGGRESSIVE=false  # Enable all aggressive optimizations below\nREDUCE_RESOLUTION=false      # Scale to 720p before processing, then upscale (2x faster)\nSKIP_DEINTERLACE=true       # Skip deinterlacing checks (minor speed gain)\nUSE_FAST_BILINEAR=false     # Use faster but lower quality scaling algorithm\n\nCAPTION_ENABLE=false\nCAPTION_FONT_PATH=\"/System/Library/Fonts/Supplemental/Arial Bold.ttf\"  # macOS default\nCAPTION_POS_X_PERCENT=50\nCAPTION_POS_Y_PERCENT=35\nCAPTION_TEXT=\"à¤¯à¤¹ à¤à¤• à¤Ÿà¥‡à¤¸à¥à¤Ÿ à¤¹à¥ˆ ðŸŽ¬\nTest Caption\"  # Hindi + emoji test\nCAPTION_FONT_SIZE=45\nCAPTION_FONT_COLOR=\"white\"\nTEXT_BG_ENABLE=true\nTEXT_BG_COLOR=\"black\"\nTEXT_BG_OPACITY=150\nTEXT_BG_PADDING=25\n\n# ---------------- OUTPUT (FIXED) ----------------\nOUT_FILE=\"{{ $json.OUT_FILE }}\"\nmkdir -p \"$(dirname \"$OUT_FILE\")\"\n\nOUT_DIR=\"$(dirname \"$OUT_FILE\")\"\nCAPTION_PNG=\"${OUT_DIR}/caption_image.png\"\nMERGED_OVERLAY_TMP=\"${OUT_DIR}/overlay_merged_$(date +%s)_$$.mp4\"\nCOMPOSED_MAIN_TMP=\"${OUT_DIR}/main_composed_$(date +%s)_$$.mp4\"\n\nFFMPEG_TIMEOUT=\"5m\"\n# --------------- end config --------------\n\necho \"=== Start: enhanced video composition with overlay audio support ===\" >&2\n\n# Validate overlay audio volume\nif [ \"$OVERLAY_AUDIO_ENABLE\" = \"true\" ]; then\n  if [ -z \"${OVERLAY_AUDIO_VOLUME:-}\" ] || [ \"$OVERLAY_AUDIO_VOLUME\" -lt 1 ] || [ \"$OVERLAY_AUDIO_VOLUME\" -gt 100 ]; then\n    echo \"WARN: Invalid OVERLAY_AUDIO_VOLUME ($OVERLAY_AUDIO_VOLUME), using 100\" >&2\n    OVERLAY_AUDIO_VOLUME=100\n  fi\n  # Convert 1-100 scale to 0.01-1.0 for FFmpeg volume filter\n  OVERLAY_VOLUME_FLOAT=$(awk -v v=\"$OVERLAY_AUDIO_VOLUME\" 'BEGIN{ printf(\"%.2f\", v/100.0) }')\n  echo \"Overlay audio: ENABLED at ${OVERLAY_AUDIO_VOLUME}% volume (${OVERLAY_VOLUME_FLOAT})\" >&2\nelse\n  echo \"Overlay audio: DISABLED\" >&2\nfi\n\n# Resolve INPUT_FILE from INPUT_URL\nINPUT_FILE=\"$INPUT_URL\"\n\necho \"Main background: $INPUT_FILE\" >&2\necho \"Overlay primary: $OVERLAY_FILE\" >&2\n[ -n \"$OVERLAY_2\" ] && echo \"Overlay secondary: $OVERLAY_2\" >&2\n[ -n \"$OUTRO_FILE\" ] && echo \"Outro file: $OUTRO_FILE\" >&2\n[ -n \"$RANDOM_INSERT_FILE\" ] && echo \"Random insert file: $RANDOM_INSERT_FILE\" >&2\n[ -n \"$TRIM_DURATION\" ] && echo \"Trim duration: $TRIM_DURATION seconds\" >&2\necho \"SPEED_FACTOR: $SPEED_FACTOR, BRIGHTNESS: $BRIGHTNESS, TARGET_FPS: $TARGET_FPS\" >&2\n\n# Helper functions\nprobe_duration() { ffprobe -v error -show_entries format=duration -of default=noprint_wrappers=1:nokey=1 \"$1\" 2>/dev/null || printf \"\"; }\nprobe_resolution() { ffprobe -v error -select_streams v:0 -show_entries stream=width,height -of csv=p=0:s=x \"$1\" 2>/dev/null || printf \"\"; }\nprobe_framerate() { ffprobe -v error -select_streams v:0 -show_entries stream=r_frame_rate -of default=nw=1:nk=1 \"$1\" 2>/dev/null || printf \"\"; }\nhas_audio() { ffprobe -v error -select_streams a:0 -show_entries stream=codec_type -of default=nw=1:nk=1 \"$1\" 2>/dev/null | grep -q \"audio\" && echo \"yes\" || echo \"no\"; }\n\n# Validate files\nif [ ! -f \"$INPUT_FILE\" ]; then echo \"ERR: main input missing: $INPUT_FILE\" >&2; exit 1; fi\nif [ ! -f \"$OVERLAY_FILE\" ]; then echo \"ERR: overlay primary missing: $OVERLAY_FILE\" >&2; exit 1; fi\nif [ -n \"$OVERLAY_2\" ] && [ ! -f \"$OVERLAY_2\" ]; then echo \"ERR: overlay secondary missing: $OVERLAY_2\" >&2; exit 1; fi\n\n# Check if overlay has audio\nOVERLAY_HAS_AUDIO=$(has_audio \"$OVERLAY_FILE\")\nif [ \"$OVERLAY_AUDIO_ENABLE\" = \"true\" ] && [ \"$OVERLAY_HAS_AUDIO\" = \"no\" ]; then\n  echo \"WARN: Overlay audio enabled but overlay file has no audio stream. Disabling overlay audio.\" >&2\n  OVERLAY_AUDIO_ENABLE=false\nfi\n\nif [ -n \"$OUTRO_FILE\" ] && [ ! -f \"$OUTRO_FILE\" ]; then\n  echo \"WARN: outro path provided but file not found: $OUTRO_FILE â€” skipping outro.\" >&2\n  OUTRO_FILE=\"\"\nfi\n\nif [ -n \"$RANDOM_INSERT_FILE\" ] && [ ! -f \"$RANDOM_INSERT_FILE\" ]; then\n  echo \"ERR: random insert file missing: $RANDOM_INSERT_FILE\" >&2; exit 1;\nfi\n\nif [ -z \"${OUTRO_FILE:-}\" ]; then\n  OUTRO_FILE=\"\"\n  OUTRO_INDEX=\"\"\n  echo \"No valid outro â€” outro processing disabled.\" >&2\nfi\n\n# Probe overlay durations\nOV1_DUR=$(probe_duration \"$OVERLAY_FILE\"); OV1_DUR=${OV1_DUR:-0}; OV1_DUR=$(awk -v v=\"$OV1_DUR\" 'BEGIN{printf(\"%.3f\", v+0)}')\necho \"Overlay1 duration: $OV1_DUR\" >&2\nif [ -n \"$OVERLAY_2\" ]; then\n  OV2_DUR=$(probe_duration \"$OVERLAY_2\"); OV2_DUR=${OV2_DUR:-0}; OV2_DUR=$(awk -v v=\"$OV2_DUR\" 'BEGIN{printf(\"%.3f\", v+0)}')\n  echo \"Overlay2 duration: $OV2_DUR\" >&2\nfi\n\n# Determine overlay resolution and FPS\nIN_RES=$(probe_resolution \"$OVERLAY_FILE\" || true)\nif [ -n \"$IN_RES\" ]; then\n  O_W=$(printf \"%s\" \"$IN_RES\" | awk -Fx '{print $1}')\n  O_H=$(printf \"%s\" \"$IN_RES\" | awk -Fx '{print $2}')\nelse\n  O_W=720; O_H=1280\nfi\nFPS_RAW=$(probe_framerate \"$OVERLAY_FILE\" || true)\necho \"Overlay native resolution: ${O_W}x${O_H} native-fps:${FPS_RAW} -> using TARGET_FPS=${TARGET_FPS}\" >&2\nif [ \"$OVERLAY_LOOP_ENABLE\" = \"true\" ]; then\n  echo \"Overlay looping: enabled\" >&2\nelse\n  echo \"Overlay looping: disabled\" >&2\nfi\n\n# Auto-detect edge trims if requested\nif { [ \"${OVERLAY_EDGE_TRIM_LEFT}\" = \"auto\" ] || [ \"${OVERLAY_EDGE_TRIM_RIGHT}\" = \"auto\" ]; }; then\n  echo \"Auto-detecting overlay side trims...\" >&2\n  export OVERLAY_FILE OVERLAY_FINAL_WIDTH OVERLAY_AUTO_TRIM_THRESHOLD OVERLAY_AUTO_TRIM_MARGIN OV1_DUR\n  AUTO_TRIMS=$(python3 - <<'PY'\nimport os\nimport subprocess\nimport tempfile\nfrom PIL import Image\n\noverlay = os.environ[\"OVERLAY_FILE\"]\nwidth = int(os.environ.get(\"OVERLAY_FINAL_WIDTH\", \"0\") or \"0\")\nthreshold = int(os.environ.get(\"OVERLAY_AUTO_TRIM_THRESHOLD\", \"25\"))\nmargin = int(os.environ.get(\"OVERLAY_AUTO_TRIM_MARGIN\", \"0\") or \"0\")\nduration = float(os.environ.get(\"OV1_DUR\", \"0\") or \"0\")\n\nif width <= 0:\n    print(\"0,0\")\n    raise SystemExit\n\ndef analyze_frame(path):\n    img = Image.open(path).convert(\"RGB\")\n    w, h = img.size\n    def column_avg(x):\n        total = 0\n        for y in range(h):\n            r, g, b = img.getpixel((x, y))\n            total += r + g + b\n        return total / (3 * h)\n    left = 0\n    while left < w:\n        if column_avg(left) > threshold:\n            break\n        left += 1\n    right = 0\n    while right < (w - left):\n        if column_avg(w - 1 - right) > threshold:\n            break\n        right += 1\n    img.close()\n    return left, right\n\ndef extract_frame(time_pos):\n    with tempfile.NamedTemporaryFile(suffix=\".png\", delete=False) as tmp:\n        tmp_path = tmp.name\n    cmd = [\n        \"ffmpeg\", \"-v\", \"error\", \"-y\",\n        \"-ss\", f\"{max(time_pos, 0):.3f}\",\n        \"-i\", overlay,\n        \"-vf\", f\"scale={width}:-1\",\n        \"-frames:v\", \"1\",\n        tmp_path\n    ]\n    subprocess.run(cmd, check=True)\n    return tmp_path\n\nsample_times = [0.0]\nif duration > 1.0:\n    sample_times.append(duration * 0.5)\n    sample_times.append(max(duration - 0.5, 0.0))\n\nmax_left = 0\nmax_right = 0\ntemp_paths = []\n\ntry:\n    for t in sample_times:\n        path = extract_frame(t)\n        temp_paths.append(path)\n        left, right = analyze_frame(path)\n        if left > max_left:\n            max_left = left\n        if right > max_right:\n            max_right = right\nfinally:\n    for p in temp_paths:\n        if p and os.path.exists(p):\n            os.unlink(p)\n\nleft = max_left + margin\nright = max_right + margin\n\nwith tempfile.NamedTemporaryFile(suffix=\".png\", delete=False) as tmp:\n    tmp_path = tmp.name\ncmd = [\n    \"ffmpeg\", \"-v\", \"error\", \"-y\",\n    \"-i\", overlay,\n    \"-vf\", f\"scale={width}:-1\",\n    \"-frames:v\", \"1\",\n    tmp_path\n]\nsubprocess.run(cmd, check=True)\nimg = Image.open(tmp_path)\nw = img.width\nimg.close()\nos.unlink(tmp_path)\n\nif left + right >= w:\n    keep = max(w - 2, 1)\n    ratio = left / (left + right) if (left + right) else 0.5\n    left = int(keep * ratio)\n    right = keep - left\n\nprint(f\"{left},{right}\")\nPY\n)\n  AUTO_LEFT=$(printf \"%s\" \"$AUTO_TRIMS\" | cut -d',' -f1)\n  AUTO_RIGHT=$(printf \"%s\" \"$AUTO_TRIMS\" | cut -d',' -f2)\n  echo \"Auto trim detected: left=${AUTO_LEFT}px right=${AUTO_RIGHT}px\" >&2\n  [ \"${OVERLAY_EDGE_TRIM_LEFT}\" = \"auto\" ] && OVERLAY_EDGE_TRIM_LEFT=\"$AUTO_LEFT\"\n  [ \"${OVERLAY_EDGE_TRIM_RIGHT}\" = \"auto\" ] && OVERLAY_EDGE_TRIM_RIGHT=\"$AUTO_RIGHT\"\nfi\n\n# Build overlay effects filter chain\nOVERLAY_PRE_EFFECTS=\"\"\nOVERLAY_EFFECTS=\"\"\n\n# Chroma key (green screen removal)\nif [ \"$OVERLAY_CHROMA_KEY_ENABLE\" = \"true\" ]; then\n  echo \"Chroma key enabled: removing ${OVERLAY_CHROMA_KEY_COLOR}\" >&2\n  # Use chromakey filter - format conversion done once in pre-effects\n  OVERLAY_EFFECTS=\"${OVERLAY_EFFECTS}chromakey=${OVERLAY_CHROMA_KEY_COLOR}:${OVERLAY_CHROMA_KEY_SIMILARITY}:${OVERLAY_CHROMA_KEY_BLEND},\"\nfi\n\n# Optional edge trim to remove matte seams\nOVERLAY_TRIM_LEFT=\"${OVERLAY_EDGE_TRIM_LEFT:-}\"\nOVERLAY_TRIM_RIGHT=\"${OVERLAY_EDGE_TRIM_RIGHT:-}\"\n\n# Backward compatibility if legacy OVERLAY_EDGE_TRIM is set\nif [ -n \"${OVERLAY_EDGE_TRIM:-}\" ]; then\n  case \"$OVERLAY_EDGE_TRIM\" in\n    ''|*[!0-9]*)\n      echo \"WARN: OVERLAY_EDGE_TRIM is not a number (${OVERLAY_EDGE_TRIM}) â€” ignoring legacy setting.\" >&2\n      ;;\n    *)\n      OVERLAY_TRIM_LEFT=\"$OVERLAY_EDGE_TRIM\"\n      OVERLAY_TRIM_RIGHT=\"$OVERLAY_EDGE_TRIM\"\n      ;;\n  esac\nfi\n\nvalidate_trim() {\n  local value=\"$1\"\n  case \"$value\" in\n    ''|*[!0-9]*)\n      echo \"\"\n      ;;\n    *)\n      echo \"$value\"\n      ;;\n  esac\n}\n\nOVERLAY_TRIM_LEFT=$(validate_trim \"$OVERLAY_TRIM_LEFT\")\nOVERLAY_TRIM_RIGHT=$(validate_trim \"$OVERLAY_TRIM_RIGHT\")\n\nif [ -n \"$OVERLAY_TRIM_LEFT\" ] || [ -n \"$OVERLAY_TRIM_RIGHT\" ]; then\n  LEFT_VAL=${OVERLAY_TRIM_LEFT:-0}\n  RIGHT_VAL=${OVERLAY_TRIM_RIGHT:-0}\n  if [ \"$LEFT_VAL\" -gt 0 ] || [ \"$RIGHT_VAL\" -gt 0 ]; then\n    echo \"Overlay edge trim: left=${LEFT_VAL}px right=${RIGHT_VAL}px\" >&2\n    OVERLAY_PRE_EFFECTS=\"${OVERLAY_PRE_EFFECTS}crop=in_w-${LEFT_VAL}-${RIGHT_VAL}:in_h:${LEFT_VAL}:0,\"\n  fi\nfi\n\n# Opacity/transparency\nif [ \"$OVERLAY_OPACITY\" -lt 100 ]; then\n  OPACITY_VALUE=$(awk -v o=\"$OVERLAY_OPACITY\" 'BEGIN{printf(\"%.2f\", o/100.0)}')\n  echo \"Overlay opacity: ${OVERLAY_OPACITY}% (${OPACITY_VALUE})\" >&2\n  OVERLAY_EFFECTS=\"${OVERLAY_EFFECTS}colorchannelmixer=aa=${OPACITY_VALUE},\"\nfi\n\necho \"Overlay effects chain: ${OVERLAY_EFFECTS:-none}\" >&2\n# ========== END overlay calculations ==========\n\n# Merge overlays if needed (VIDEO + AUDIO)\nif [ -z \"$OVERLAY_2\" ]; then\n  echo \"No overlay2 provided â€” using overlay primary as-is.\" >&2\n  MERGED_OVERLAY=\"$OVERLAY_FILE\"\nelse\n  if [ -n \"$OVERLAY_2_LENGTH_SECONDS\" ]; then\n    OVERLAY_2_LENGTH_SECONDS=$(awk -v v=\"$OVERLAY_2_LENGTH_SECONDS\" 'BEGIN{printf(\"%.3f\", v+0)}')\n    FIRST_END_SEC=$(awk -v d=\"$OV1_DUR\" -v s=\"$OVERLAY_2_LENGTH_SECONDS\" 'BEGIN{printf(\"%.3f\", d - s)}')\n  else\n    FIRST_END_SEC=$(awk -v d=\"$OV1_DUR\" 'BEGIN{printf(\"%.3f\", d*0.70)}')\n  fi\n\n  TRANS=$(awk -v v=\"$OVERLAY_TRANSITION_DURATION\" 'BEGIN{printf(\"%.3f\", v+0)}')\n  OFFSET=$(awk -v f=\"$FIRST_END_SEC\" -v t=\"$TRANS\" 'BEGIN{printf(\"%.3f\", f - t)}')\n\n  # Merge video AND audio (optimized for VPS speed)\n  ffmpeg -y -hide_banner -loglevel error \\\n    -i \"$OVERLAY_FILE\" -i \"$OVERLAY_2\" \\\n    -filter_complex \"\\\n[0:v]trim=start=0:end=${FIRST_END_SEC},setpts=PTS-STARTPTS,scale=${O_W}:${O_H},fps=${TARGET_FPS},setsar=1,format=yuv420p[v0]; \\\n[1:v]trim=start=${OVERLAY_2_START_SEC},setpts=PTS-STARTPTS,scale=${O_W}:${O_H},fps=${TARGET_FPS},setsar=1,format=yuv420p[v1]; \\\n[v0][v1]xfade=transition=fade:duration=${TRANS}:offset=${OFFSET}[vxf]; \\\n[0:a]atrim=start=0:end=${FIRST_END_SEC},asetpts=PTS-STARTPTS[a0]; \\\n[1:a]atrim=start=${OVERLAY_2_START_SEC},asetpts=PTS-STARTPTS[a1]; \\\n[a0][a1]acrossfade=d=${TRANS}:o=${OFFSET}[axf]\" \\\n    -map \"[vxf]\" -map \"[axf]\" -c:v libx264 -crf ${ENCODING_CRF} -preset ${ENCODING_PRESET} -threads ${FFMPEG_THREADS} -c:a aac -b:a 128k -movflags +faststart \\\n    \"$MERGED_OVERLAY_TMP\"\n\n  MERGED_OVERLAY=\"$MERGED_OVERLAY_TMP\"\nfi\n\n# Generate caption if enabled\nif [ \"$CAPTION_ENABLE\" = \"true\" ]; then\n  rm -f \"${CAPTION_PNG}\" || true\n  export CAPTION_PNG CAPTION_TEXT CAPTION_FONT_PATH CAPTION_FONT_SIZE CAPTION_FONT_COLOR CAPTION_POS_X_PERCENT CAPTION_POS_Y_PERCENT TEXT_BG_ENABLE TEXT_BG_COLOR TEXT_BG_OPACITY TEXT_BG_PADDING SCRIPT_DIR\n  python3 - <<'PY' 1>&2\nimport os\nimport re\nimport sys\nfrom PIL import Image, ImageDraw, ImageFont\nimport urllib.request\nimport io\n\nSCRIPT_DIR = os.environ.get(\"SCRIPT_DIR\", \"\")\n\n# Emoji rendering using Twemoji PNG images\ndef get_emoji_image(emoji_char, size):\n    \"\"\"Download and return emoji image from Twemoji CDN\"\"\"\n    try:\n        # Get Unicode codepoint(s) for the emoji\n        codepoints = '-'.join(f'{ord(c):x}' for c in emoji_char)\n        # Twemoji CDN URL (72x72 PNG)\n        url = f'https://cdn.jsdelivr.net/gh/twitter/twemoji@14.0.2/assets/72x72/{codepoints}.png'\n\n        with urllib.request.urlopen(url, timeout=3) as response:\n            img_data = response.read()\n            emoji_img = Image.open(io.BytesIO(img_data)).convert(\"RGBA\")\n            # Resize to match font size\n            emoji_img = emoji_img.resize((size, size), Image.Resampling.LANCZOS)\n            return emoji_img\n    except Exception as e:\n        print(f\"Could not fetch emoji {emoji_char} ({codepoints}): {e}\", file=sys.stderr, flush=True)\n        return None\n\nout_path = os.environ[\"CAPTION_PNG\"]\ntext = os.environ.get(\"CAPTION_TEXT\", \"\")\nfont_path = os.environ.get(\"CAPTION_FONT_PATH\", \"/usr/share/fonts/truetype/dejavu/DejaVuSans-Bold.ttf\")\ntry:\n    font_size = int(os.environ.get(\"CAPTION_FONT_SIZE\", \"64\"))\nexcept Exception:\n    font_size = 64\nfont_color = os.environ.get(\"CAPTION_FONT_COLOR\", \"white\")\ntry:\n    pos_x_pct = int(os.environ.get(\"CAPTION_POS_X_PERCENT\", \"50\"))\nexcept Exception:\n    pos_x_pct = 50\ntry:\n    pos_y_pct = int(os.environ.get(\"CAPTION_POS_Y_PERCENT\", \"50\"))\nexcept Exception:\n    pos_y_pct = 50\nbg_enable = os.environ.get(\"TEXT_BG_ENABLE\", \"true\").lower() == 'true'\ntry:\n    bg_opacity = int(os.environ.get(\"TEXT_BG_OPACITY\", \"150\"))\nexcept Exception:\n    bg_opacity = 150\ntry:\n    bg_padding = int(os.environ.get(\"TEXT_BG_PADDING\", \"20\"))\nexcept Exception:\n    bg_padding = 20\n\ncanvas_w, canvas_h = 1080, 1920\n\n# Font loading with multi-script support\ndef load_font(path, size):\n    \"\"\"Try to load a font, return None if failed\"\"\"\n    try:\n        font = ImageFont.truetype(path, size)\n        # Test if font can actually render (some emoji fonts need SVG support)\n        test_draw = ImageDraw.Draw(Image.new(\"RGBA\", (10, 10)))\n        try:\n            test_draw.textbbox((0, 0), \"A\", font=font)\n            return font\n        except (OSError, RuntimeError):\n            # Font loaded but can't render (likely SVG-based emoji font)\n            print(f\"WARNING: {path} requires SVG support, skipping\", flush=True)\n            return None\n    except Exception:\n        return None\n\n# Define font candidates for different scripts\nhindi_font_paths = [\n    os.path.join(SCRIPT_DIR, \"Noto_Sans_Devanagari\", \"static\", \"NotoSansDevanagari-Bold.ttf\"),\n    os.path.join(SCRIPT_DIR, \"Noto_Sans_Devanagari\", \"NotoSansDevanagari-VariableFont_wdth,wght.ttf\"),\n    \"/usr/share/fonts/truetype/noto/NotoSansDevanagari-Bold.ttf\",\n    \"/usr/share/fonts/truetype/noto/NotoSansDevanagari.ttf\",\n    \"/System/Library/Fonts/Devanagari Sangam MN.ttc\",\n    \"/usr/share/fonts/truetype/lohit-devanagari/Lohit-Devanagari.ttf\",\n    \"/usr/share/fonts/truetype/fonts-noto-devanagari/NotoSansDevanagari-Bold.ttf\"\n]\n\nlatin_font_paths = [\n    font_path,  # User-specified font\n    os.path.join(SCRIPT_DIR, \"Noto_Sans_Devanagari\", \"static\", \"NotoSansDevanagari-Regular.ttf\"),\n    \"/usr/share/fonts/truetype/dejavu/DejaVuSans-Bold.ttf\",\n    \"/usr/share/fonts/truetype/liberation/LiberationSans-Bold.ttf\",\n    \"/System/Library/Fonts/Supplemental/Arial Bold.ttf\"\n]\n\nemoji_font_paths = [\n    os.path.join(SCRIPT_DIR, \"Noto_Color_Emoji\", \"NotoColorEmoji-Regular.ttf\"),\n    \"/System/Library/Fonts/Apple Color Emoji.ttc\"\n]\n\n# Load fonts\nlatin_font = None\nfor p in latin_font_paths:\n    if os.path.isfile(p):\n        latin_font = load_font(p, font_size)\n        if latin_font:\n            break\n\nhindi_font = None\nfor p in hindi_font_paths:\n    if os.path.isfile(p):\n        hindi_font = load_font(p, font_size)\n        if hindi_font:\n            print(f\"Loaded Hindi font: {p}\", flush=True)\n            break\n\ndef supports_color_glyphs(font):\n    \"\"\"Detect if a font actually renders emoji glyphs with non-zero alpha.\"\"\"\n    if font is None:\n        return False\n    test_img = Image.new(\"RGBA\", (font_size * 2, font_size * 2), (0, 0, 0, 0))\n    test_draw = ImageDraw.Draw(test_img)\n    # Use a representative emoji that should exist in most sets\n    test_draw.text((0, 0), \"ðŸ˜€\", font=font, fill=(255, 255, 255, 255))\n    return any(pixel[3] > 0 for pixel in test_img.getdata())\n\nemoji_font = None\nfor p in emoji_font_paths:\n    if os.path.isfile(p):\n        candidate = load_font(p, font_size)\n        if candidate and supports_color_glyphs(candidate):\n            emoji_font = candidate\n            print(f\"Loaded emoji font: {p}\", flush=True)\n            break\n        elif candidate:\n            print(f\"WARNING: {p} loaded but produced empty glyphs â€” falling back\", flush=True)\n\nif emoji_font is None:\n    print(\"Emoji font not available â€” will fetch Twemoji PNGs\", flush=True)\n\nprint(\"Emoji rendering: prefer local emoji font, fallback to Twemoji CDN\", flush=True)\n\n# Fallback to default if no fonts loaded\nif latin_font is None:\n    latin_font = ImageFont.load_default()\n\n# Use Hindi font as fallback if available, otherwise use latin\nprimary_font = hindi_font if hindi_font else latin_font\n\ntext = text or \" \"\nlines = text.splitlines() if \"\\n\" in text else [text]\n\n# Detect script type for each character\ndef get_char_type(char):\n    \"\"\"Detect if character is Hindi (Devanagari), emoji, or latin\"\"\"\n    code = ord(char)\n    # Devanagari Unicode range: 0x0900-0x097F\n    if 0x0900 <= code <= 0x097F:\n        return 'hindi'\n    # Emoji ranges (expanded for better coverage)\n    elif (0x1F300 <= code <= 0x1FAFF or  # Misc symbols, pictographs, and extended\n          0x2600 <= code <= 0x26FF or    # Misc symbols\n          0x2700 <= code <= 0x27BF or    # Dingbats\n          0xFE00 <= code <= 0xFE0F or    # Variation selectors\n          0x1F000 <= code <= 0x1F0FF or  # Mahjong tiles\n          0x1F100 <= code <= 0x1F1FF or  # Enclosed alphanumeric supplement\n          0x1F200 <= code <= 0x1F2FF or  # Enclosed ideographic supplement\n          0x2300 <= code <= 0x23FF or    # Miscellaneous Technical\n          0x25A0 <= code <= 0x25FF or    # Geometric Shapes\n          0x2B00 <= code <= 0x2BFF or    # Miscellaneous Symbols and Arrows\n          0x1F900 <= code <= 0x1F9FF):   # Supplemental Symbols and Pictographs\n        return 'emoji'\n    else:\n        return 'latin'\n\n# Render text with proper font switching\ndef render_multiline_text(canvas, lines, start_y, font_color):\n    \"\"\"Render text with automatic font switching for Hindi and emoji\"\"\"\n    draw = ImageDraw.Draw(canvas)\n    cur_y = start_y\n    line_spacing = int(font_size * 0.3)\n\n    for line in lines:\n        # Calculate line width for centering\n        line_width = 0\n        segments = []\n        current_segment = \"\"\n        current_type = None\n\n        # Split line into segments by script type\n        for char in line:\n            char_type = get_char_type(char)\n            if char_type != current_type:\n                if current_segment:\n                    segments.append((current_segment, current_type))\n                current_segment = char\n                current_type = char_type\n            else:\n                current_segment += char\n\n        if current_segment:\n            segments.append((current_segment, current_type))\n\n        # Calculate total line width\n        for segment, seg_type in segments:\n            if seg_type == 'hindi' and hindi_font:\n                bbox = draw.textbbox((0, 0), segment, font=hindi_font)\n                line_width += bbox[2] - bbox[0]\n            elif seg_type == 'emoji':\n                if emoji_font:\n                    bbox = draw.textbbox((0, 0), segment, font=emoji_font)\n                    line_width += bbox[2] - bbox[0]\n                else:\n                    line_width += int(font_size * 1.2) * len(segment)\n            else:\n                bbox = draw.textbbox((0, 0), segment, font=latin_font)\n                line_width += bbox[2] - bbox[0]\n\n        # Calculate starting x position (centered)\n        x = (canvas_w * pos_x_pct / 100.0) - (line_width / 2.0)\n\n        # Draw each segment with appropriate font\n        for segment, seg_type in segments:\n            if seg_type == 'hindi' and hindi_font:\n                draw.text((x, cur_y), segment, font=hindi_font, fill=font_color)\n                bbox = draw.textbbox((x, cur_y), segment, font=hindi_font)\n                x += bbox[2] - bbox[0]\n            elif seg_type == 'emoji':\n                # Render emojis as downloaded images\n                if emoji_font:\n                    draw.text((x, cur_y), segment, font=emoji_font, fill=font_color)\n                    bbox = draw.textbbox((x, cur_y), segment, font=emoji_font)\n                    x += bbox[2] - bbox[0]\n                else:\n                    for emoji_char in segment:\n                        emoji_img = get_emoji_image(emoji_char, int(font_size * 1.2))\n                        if emoji_img:\n                            # Paste emoji image with transparency\n                            y_offset = int(cur_y - font_size * 0.1)  # Slight vertical adjustment\n                            canvas.paste(emoji_img, (int(x), y_offset), emoji_img if emoji_img.mode == 'RGBA' else None)\n                            x += int(font_size * 1.2)\n                        else:\n                            # Fallback: skip emoji with space\n                            x += int(font_size * 0.6)\n            else:\n                draw.text((x, cur_y), segment, font=latin_font, fill=font_color)\n                bbox = draw.textbbox((x, cur_y), segment, font=latin_font)\n                x += bbox[2] - bbox[0]\n\n        cur_y += font_size + line_spacing\n\n    return cur_y\n\n# Calculate bounding boxes for background\ncanvas = Image.new(\"RGBA\", (canvas_w, canvas_h), (0, 0, 0, 0))\ntemp_draw = ImageDraw.Draw(canvas)\nline_spacing = int(font_size * 0.3)\n\nline_bboxes = []\nmax_w = 0\n\nfor line in lines:\n    # Calculate width using multi-font approach\n    line_width = 0\n    segments = []\n    current_segment = \"\"\n    current_type = None\n\n    for char in line:\n        char_type = get_char_type(char)\n        if char_type != current_type:\n            if current_segment:\n                segments.append((current_segment, current_type))\n            current_segment = char\n            current_type = char_type\n        else:\n            current_segment += char\n\n    if current_segment:\n        segments.append((current_segment, current_type))\n\n    for segment, seg_type in segments:\n        if seg_type == 'hindi' and hindi_font:\n            bbox = temp_draw.textbbox((0, 0), segment, font=hindi_font)\n            line_width += bbox[2] - bbox[0]\n        elif seg_type == 'emoji':\n            if emoji_font:\n                bbox = temp_draw.textbbox((0, 0), segment, font=emoji_font)\n                line_width += bbox[2] - bbox[0]\n            else:\n                line_width += int(font_size * 1.2) * len(segment)\n        else:\n            bbox = temp_draw.textbbox((0, 0), segment, font=latin_font)\n            line_width += bbox[2] - bbox[0]\n\n    line_bboxes.append((line, line_width, font_size))\n    if line_width > max_w:\n        max_w = line_width\n\ntotal_h = sum(h for _, _, h in line_bboxes) + (len(lines) - 1) * line_spacing\n\ny = (canvas_h * pos_y_pct / 100.0) - (total_h / 2.0)\n\n# Draw rounded backgrounds\nif bg_enable:\n    bg_layer = Image.new(\"RGBA\", (canvas_w, canvas_h), (0, 0, 0, 0))\n    bg_draw = ImageDraw.Draw(bg_layer)\n\n    cur_y = y\n    for ln, w, h in line_bboxes:\n        line_x = (canvas_w * pos_x_pct / 100.0) - (w / 2.0)\n        left = int(line_x - bg_padding)\n        top = int(cur_y - bg_padding)\n        right = int(line_x + w + bg_padding)\n        bottom = int(cur_y + h + bg_padding)\n\n        radius = min(int(h * 0.5), bg_padding)\n        bg_draw.rounded_rectangle([left, top, right, bottom], radius=radius, fill=(0, 0, 0, bg_opacity))\n        cur_y += h + line_spacing\n\n    canvas = Image.alpha_composite(canvas, bg_layer)\n\n# Draw text with multi-font support and Twemoji image rendering\nrender_multiline_text(canvas, lines, y, font_color)\n\nos.makedirs(os.path.dirname(out_path), exist_ok=True)\ncanvas.save(out_path)\nprint(f\"Caption saved: {out_path}\", flush=True)\nPY\n  if [ ! -f \"$CAPTION_PNG\" ]; then echo \"ERR: caption generation failed.\" >&2; exit 1; fi\nfi\n\n# [Rest of the script continues exactly as original script.sh from line 458 onwards]\n# Due to length, I'm including the reference to continue from the original\n# The processing logic remains identical\n\n# Probe main duration\nMAIN_VID_DURATION=$(probe_duration \"$INPUT_FILE\" || printf \"\")\nMAIN_VID_DURATION=${MAIN_VID_DURATION:-10}\nMAIN_VID_DURATION=$(awk -v v=\"$MAIN_VID_DURATION\" 'BEGIN{ if(v==0) v=10; printf(\"%.3f\", v+0)}')\necho \"Main video duration (original): $MAIN_VID_DURATION\" >&2\n\n# Calculate proper INPUT_READ_DURATION based on SPEED_FACTOR\nSPEED_FACTOR_N=$(awk -v s=\"$SPEED_FACTOR\" 'BEGIN{ if(s<=0) s=1.0; printf(\"%.6f\", s+0) }')\nOVERLAY_SPEED_FACTOR_N=$(awk -v s=\"$OVERLAY_SPEED_FACTOR\" 'BEGIN{ if(s<=0) s=1.0; printf(\"%.6f\", s+0) }')\n\n# Apply trim with speed factor consideration\nINPUT_READ_DURATION=\"\"\nif [ -n \"$TRIM_DURATION\" ]; then\n    INPUT_READ_DURATION=$(awk -v t=\"$TRIM_DURATION\" -v s=\"$SPEED_FACTOR_N\" 'BEGIN{ printf(\"%.3f\", t*s) }')\n    if [ \"$(awk -v i=\"$INPUT_READ_DURATION\" -v m=\"$MAIN_VID_DURATION\" 'BEGIN{ if(i>m) print 1; else print 0 }')\" = \"1\" ]; then\n        echo \"WARNING: Requested duration exceeds available. Adjusting...\" >&2\n        INPUT_READ_DURATION=\"$MAIN_VID_DURATION\"\n        EFFECTIVE_DURATION=$(awk -v i=\"$INPUT_READ_DURATION\" -v s=\"$SPEED_FACTOR_N\" 'BEGIN{ printf(\"%.3f\", i/s) }')\n    else\n        EFFECTIVE_DURATION=\"$TRIM_DURATION\"\n    fi\nelse\n    INPUT_READ_DURATION=\"$MAIN_VID_DURATION\"\n    EFFECTIVE_DURATION=$(awk -v m=\"$MAIN_VID_DURATION\" -v s=\"$SPEED_FACTOR_N\" 'BEGIN{ printf(\"%.3f\", m/s) }')\nfi\n\necho \"SPEED_FACTOR: $SPEED_FACTOR_N\" >&2\necho \"OVERLAY_SPEED_FACTOR: $OVERLAY_SPEED_FACTOR_N\" >&2\necho \"INPUT_READ_DURATION: $INPUT_READ_DURATION (amount to read from files)\" >&2\necho \"EFFECTIVE_DURATION: $EFFECTIVE_DURATION (output duration after speed change)\" >&2\n\nOVERLAY_READ_DURATION=$(awk -v d=\"$INPUT_READ_DURATION\" -v s=\"$OVERLAY_SPEED_FACTOR_N\" 'BEGIN{ printf(\"%.3f\", d*s) }')\necho \"OVERLAY_READ_DURATION: $OVERLAY_READ_DURATION (source duration before overlay speed adjustment)\" >&2\n\n# Rotation and crop filters\nROTATE_TAG=$(ffprobe -v error -select_streams v:0 -show_entries stream_tags=rotate -of default=nw=1:nk=1 \"$INPUT_FILE\" 2>/dev/null || printf \"0\")\nROTATION_FILTER=\"\"\ncase \"$ROTATE_TAG\" in\n  90) ROTATION_FILTER=\"transpose=1,\" ;;\n  270) ROTATION_FILTER=\"transpose=2,\" ;;\nesac\n\n# Build crop filter\nCROP_FILTER=\"\"\nif [ \"$CROP_ENABLE\" = \"true\" ]; then\n  CROP_TOP_PCT=0\n  CROP_BOTTOM_PCT=0\n\n  if [ \"$CROP_TOP_ENABLE\" = \"true\" ]; then\n    if [ -z \"${CROP_TOP_PERCENT:-}\" ]; then\n      CROP_TOP_PCT=$DEFAULT_CROP_TOP_PERCENT\n      echo \"CROP_TOP_PERCENT not set, using default: ${DEFAULT_CROP_TOP_PERCENT}%\" >&2\n    else\n      case \"$CROP_TOP_PERCENT\" in\n        ''|*[!0-9]*)\n          CROP_TOP_PCT=$DEFAULT_CROP_TOP_PERCENT\n          echo \"CROP_TOP_PERCENT invalid, using default: ${DEFAULT_CROP_TOP_PERCENT}%\" >&2\n          ;;\n        *)\n          CROP_TOP_PCT=$CROP_TOP_PERCENT\n          ;;\n      esac\n    fi\n  fi\n\n  if [ \"$CROP_BOTTOM_ENABLE\" = \"true\" ]; then\n    if [ -z \"${CROP_BOTTOM_PERCENT:-}\" ]; then\n      CROP_BOTTOM_PCT=$DEFAULT_CROP_BOTTOM_PERCENT\n      echo \"CROP_BOTTOM_PERCENT not set, using default: ${DEFAULT_CROP_BOTTOM_PERCENT}%\" >&2\n    else\n      case \"$CROP_BOTTOM_PERCENT\" in\n        ''|*[!0-9]*)\n          CROP_BOTTOM_PCT=$DEFAULT_CROP_BOTTOM_PERCENT\n          echo \"CROP_BOTTOM_PERCENT invalid, using default: ${DEFAULT_CROP_BOTTOM_PERCENT}%\" >&2\n          ;;\n        *)\n          CROP_BOTTOM_PCT=$CROP_BOTTOM_PERCENT\n          ;;\n      esac\n    fi\n  fi\n\n  TOTAL_CROP_PCT=$((CROP_TOP_PCT + CROP_BOTTOM_PCT))\n\n  if [ \"$TOTAL_CROP_PCT\" -gt 0 ] && [ \"$TOTAL_CROP_PCT\" -lt 100 ]; then\n    KEEP_PCT=$((100 - TOTAL_CROP_PCT))\n    echo \"Crop settings: Top=${CROP_TOP_PCT}%, Bottom=${CROP_BOTTOM_PCT}%, Keeping=${KEEP_PCT}%\" >&2\n    CROP_FILTER=\"crop=in_w:in_h*${KEEP_PCT}/100:0:in_h*${CROP_TOP_PCT}/100,\"\n  elif [ \"$TOTAL_CROP_PCT\" -ge 100 ]; then\n    echo \"WARNING: Total crop percentage >= 100%, disabling crop\" >&2\n    CROP_FILTER=\"\"\n  fi\nfi\n\n# Determine available canvas space for overlay\nMAIN_RES=$(probe_resolution \"$INPUT_FILE\" || true)\nif [ -n \"$MAIN_RES\" ]; then\n  MAIN_SRC_W=$(printf \"%s\" \"$MAIN_RES\" | awk -Fx '{print $1}')\n  MAIN_SRC_H=$(printf \"%s\" \"$MAIN_RES\" | awk -Fx '{print $2}')\nelse\n  MAIN_SRC_W=1920; MAIN_SRC_H=1080\nfi\n\nMAIN_KEEP_PCT=100\nif [ \"$CROP_ENABLE\" = \"true\" ]; then\n  MAIN_KEEP_PCT=$((100 - ${CROP_TOP_PCT:-0} - ${CROP_BOTTOM_PCT:-0}))\n  if [ \"$MAIN_KEEP_PCT\" -le 0 ]; then MAIN_KEEP_PCT=100; fi\nfi\n\nMAIN_POST_HEIGHT=$(awk -v h=\"$MAIN_SRC_H\" -v pct=\"$MAIN_KEEP_PCT\" 'BEGIN{ printf(\"%.6f\", h*pct/100.0) }')\nMAIN_SCALED_HEIGHT=$(awk -v cw=\"$CANVAS_WIDTH\" -v mh=\"$MAIN_POST_HEIGHT\" -v mw=\"$MAIN_SRC_W\" 'BEGIN{ if(mw<=0) printf(\"%.6f\", 0); else printf(\"%.6f\", cw*mh/mw) }')\nAVAILABLE_HEIGHT=$(awk -v ch=\"$CANVAS_HEIGHT\" -v mh=\"$MAIN_SCALED_HEIGHT\" 'BEGIN{ v=ch-mh; if (v<0.0) v=ch*0.35; if (v<50) v=ch*0.35; if (v<1) v=1; printf(\"%.6f\", v) }')\nAVAILABLE_HEIGHT_INT=$(awk -v v=\"$AVAILABLE_HEIGHT\" 'BEGIN{ if(v<1) v=1; printf(\"%d\", v) }')\n\n# Overlay aspect after trimming\nTRIM_LEFT_VAL=${OVERLAY_TRIM_LEFT:-0}\nTRIM_RIGHT_VAL=${OVERLAY_TRIM_RIGHT:-0}\nOVERLAY_TRIMMED_WIDTH=$(awk -v w=\"$O_W\" -v l=\"$TRIM_LEFT_VAL\" -v r=\"$TRIM_RIGHT_VAL\" 'BEGIN{ val=w-l-r; if (val<1) val=1; printf(\"%.6f\", val) }')\nOVERLAY_TRIMMED_HEIGHT=$(awk -v h=\"$O_H\" 'BEGIN{ if(h<1) h=1; printf(\"%.6f\", h) }')\nOVERLAY_ASPECT=$(awk -v w=\"$OVERLAY_TRIMMED_WIDTH\" -v h=\"$OVERLAY_TRIMMED_HEIGHT\" 'BEGIN{ if(h<=0) printf(\"1.0\"); else printf(\"%.6f\", w/h) }')\n\n# Resolve user-provided overlay dimensions (pixels, percent, or auto)\nOVERLAY_WIDTH_EXPLICIT=0\nRAW_OVERLAY_WIDTH=\"$OVERLAY_WIDTH\"\ncase \"$RAW_OVERLAY_WIDTH\" in\n  \"\"|auto|AUTO|Auto)\n    RAW_OVERLAY_WIDTH=\"\"\n    ;;\n  *%)\n    PCT=${RAW_OVERLAY_WIDTH%%%}\n    if [ -n \"$PCT\" ]; then\n      RAW_OVERLAY_WIDTH=$(awk -v base=\"$CANVAS_WIDTH\" -v pct=\"$PCT\" 'BEGIN{ printf(\"%.6f\", base*pct/100.0) }')\n      OVERLAY_WIDTH_EXPLICIT=1\n    else\n      RAW_OVERLAY_WIDTH=\"\"\n    fi\n    ;;\n  *)\n    RAW_OVERLAY_WIDTH=$(awk -v v=\"$RAW_OVERLAY_WIDTH\" 'BEGIN{ printf(\"%.6f\", v+0) }')\n    OVERLAY_WIDTH_EXPLICIT=1\n    ;;\nesac\n\nOVERLAY_HEIGHT_EXPLICIT=0\nRAW_OVERLAY_HEIGHT=\"$OVERLAY_HEIGHT\"\ncase \"$RAW_OVERLAY_HEIGHT\" in\n  \"\"|auto|AUTO|Auto)\n    RAW_OVERLAY_HEIGHT=\"\"\n    ;;\n  *%)\n    PCT=${RAW_OVERLAY_HEIGHT%%%}\n    if [ -n \"$PCT\" ]; then\n      RAW_OVERLAY_HEIGHT=$(awk -v base=\"$CANVAS_HEIGHT\" -v pct=\"$PCT\" 'BEGIN{ printf(\"%.6f\", base*pct/100.0) }')\n      OVERLAY_HEIGHT_EXPLICIT=1\n    else\n      RAW_OVERLAY_HEIGHT=\"\"\n    fi\n    ;;\n  *)\n    RAW_OVERLAY_HEIGHT=$(awk -v v=\"$RAW_OVERLAY_HEIGHT\" 'BEGIN{ printf(\"%.6f\", v+0) }')\n    OVERLAY_HEIGHT_EXPLICIT=1\n    ;;\nesac\n\nWIDTH_BASE=\"$RAW_OVERLAY_WIDTH\"\nHEIGHT_BASE=\"$RAW_OVERLAY_HEIGHT\"\n\nif [ -z \"$WIDTH_BASE\" ] && [ -z \"$HEIGHT_BASE\" ]; then\n  HEIGHT_BASE=$AVAILABLE_HEIGHT_INT\n  if [ -z \"$HEIGHT_BASE\" ] || [ \"$HEIGHT_BASE\" -le 0 ]; then\n    HEIGHT_BASE=$(awk -v ch=\"$CANVAS_HEIGHT\" 'BEGIN{ printf(\"%.6f\", ch*0.35) }')\n  fi\n  WIDTH_BASE=$(awk -v h=\"$HEIGHT_BASE\" -v aspect=\"$OVERLAY_ASPECT\" 'BEGIN{ printf(\"%.6f\", h*aspect) }')\nelif [ -z \"$HEIGHT_BASE\" ]; then\n  HEIGHT_BASE=$(awk -v w=\"$WIDTH_BASE\" -v aspect=\"$OVERLAY_ASPECT\" 'BEGIN{ if(aspect<=0) aspect=1; printf(\"%.6f\", w/aspect) }')\nelif [ -z \"$WIDTH_BASE\" ]; then\n  WIDTH_BASE=$(awk -v h=\"$HEIGHT_BASE\" -v aspect=\"$OVERLAY_ASPECT\" 'BEGIN{ printf(\"%.6f\", h*aspect) }')\nfi\n\nOVERLAY_FINAL_WIDTH=$(awk -v w=\"$WIDTH_BASE\" -v s=\"$OVERLAY_SCALE_PERCENT\" 'BEGIN{ printf(\"%.6f\", w*s/100.0) }')\nOVERLAY_FINAL_HEIGHT=$(awk -v h=\"$HEIGHT_BASE\" -v s=\"$OVERLAY_SCALE_PERCENT\" 'BEGIN{ printf(\"%.6f\", h*s/100.0) }')\n\nOVERLAY_ALLOW_OVERFLOW=$(awk -v s=\"$OVERLAY_SCALE_PERCENT\" 'BEGIN{ if(s==\"\") s=100; if(s+0>100) print 1; else print 0 }')\nOVERLAY_FINAL_WIDTH_INT=$(awk -v w=\"$OVERLAY_FINAL_WIDTH\" 'BEGIN{ if(w<1) w=1; printf(\"%d\", w) }')\nOVERLAY_FINAL_HEIGHT_INT=$(awk -v h=\"$OVERLAY_FINAL_HEIGHT\" 'BEGIN{ if(h<1) h=1; printf(\"%d\", h) }')\n\nif [ \"$OVERLAY_FINAL_WIDTH_INT\" -gt \"$CANVAS_WIDTH\" ]; then\n  if [ \"$OVERLAY_WIDTH_EXPLICIT\" -eq 0 ]; then\n    OVERLAY_FINAL_WIDTH_INT=$CANVAS_WIDTH\n    OVERLAY_FINAL_HEIGHT_INT=$(awk -v w=\"$OVERLAY_FINAL_WIDTH_INT\" -v aspect=\"$OVERLAY_ASPECT\" 'BEGIN{ if(aspect<=0) aspect=1; val=w/aspect; if(val<1) val=1; printf(\"%d\", val) }')\n  else\n    echo \"WARN: overlay width (${OVERLAY_FINAL_WIDTH_INT}px) exceeds canvas width; overlay may spill horizontally.\" >&2\n  fi\nfi\n\nif [ \"$OVERLAY_ALLOW_OVERFLOW\" -eq 0 ] && [ \"$OVERLAY_HEIGHT_EXPLICIT\" -eq 0 ]; then\n  if [ \"$AVAILABLE_HEIGHT_INT\" -gt 0 ] && [ \"$OVERLAY_FINAL_HEIGHT_INT\" -gt \"$AVAILABLE_HEIGHT_INT\" ]; then\n    OVERLAY_FINAL_HEIGHT_INT=$AVAILABLE_HEIGHT_INT\n    OVERLAY_FINAL_WIDTH_INT=$(awk -v h=\"$OVERLAY_FINAL_HEIGHT_INT\" -v aspect=\"$OVERLAY_ASPECT\" 'BEGIN{ val=h*aspect; if(val<1) val=1; printf(\"%d\", val) }')\n    if [ \"$OVERLAY_FINAL_WIDTH_INT\" -gt \"$CANVAS_WIDTH\" ]; then\n      OVERLAY_FINAL_WIDTH_INT=$CANVAS_WIDTH\n    fi\n  fi\nfi\n\nif [ \"$OVERLAY_FINAL_HEIGHT_INT\" -gt \"$CANVAS_HEIGHT\" ]; then\n  OVERLAY_FINAL_HEIGHT_INT=$CANVAS_HEIGHT\n  if [ \"$OVERLAY_HEIGHT_EXPLICIT\" -eq 0 ]; then\n    OVERLAY_FINAL_WIDTH_INT=$(awk -v h=\"$OVERLAY_FINAL_HEIGHT_INT\" -v aspect=\"$OVERLAY_ASPECT\" 'BEGIN{ val=h*aspect; if(val<1) val=1; printf(\"%d\", val) }')\n    if [ \"$OVERLAY_FINAL_WIDTH_INT\" -gt \"$CANVAS_WIDTH\" ]; then\n      OVERLAY_FINAL_WIDTH_INT=$CANVAS_WIDTH\n    fi\n  fi\nfi\n\nif [ \"$OVERLAY_FINAL_WIDTH_INT\" -lt 1 ]; then OVERLAY_FINAL_WIDTH_INT=1; fi\nif [ \"$OVERLAY_FINAL_HEIGHT_INT\" -lt 1 ]; then OVERLAY_FINAL_HEIGHT_INT=1; fi\n\nOVERLAY_SIZE_FILTER=\"scale=${OVERLAY_FINAL_WIDTH_INT}:${OVERLAY_FINAL_HEIGHT_INT}\"\n\n# Calculate position based on OVERLAY_POSITION setting\ncase \"$OVERLAY_POSITION\" in\n  top)\n    OVERLAY_X=\"(W-w)/2\"\n    OVERLAY_Y=\"0\"\n    ;;\n  bottom)\n    OVERLAY_X=\"(W-w)/2\"\n    OVERLAY_Y=\"H-h\"\n    ;;\n  center)\n    OVERLAY_X=\"(W-w)/2\"\n    OVERLAY_Y=\"(H-h)/2\"\n    ;;\n  custom)\n    OVERLAY_X=\"$OVERLAY_CUSTOM_X\"\n    OVERLAY_Y=\"$OVERLAY_CUSTOM_Y\"\n    ;;\n  *)\n    echo \"WARN: Invalid OVERLAY_POSITION, using bottom\" >&2\n    OVERLAY_X=\"(W-w)/2\"\n    OVERLAY_Y=\"H-h\"\n    ;;\nesac\n\necho \"Overlay positioning: ${OVERLAY_POSITION} at X=${OVERLAY_X}, Y=${OVERLAY_Y}, size=${OVERLAY_FINAL_WIDTH_INT}x${OVERLAY_FINAL_HEIGHT_INT}\" >&2\n\n# Calculate position based on OVERLAY_POSITION setting\ncase \"$OVERLAY_POSITION\" in\n  top)\n    OVERLAY_X=\"(W-w)/2\"\n    OVERLAY_Y=\"0\"\n    ;;\n  bottom)\n    OVERLAY_X=\"(W-w)/2\"\n    OVERLAY_Y=\"H-h\"\n    ;;\n  center)\n    OVERLAY_X=\"(W-w)/2\"\n    OVERLAY_Y=\"(H-h)/2\"\n    ;;\n  custom)\n    OVERLAY_X=\"$OVERLAY_CUSTOM_X\"\n    OVERLAY_Y=\"$OVERLAY_CUSTOM_Y\"\n    ;;\n  *)\n    echo \"WARN: Invalid OVERLAY_POSITION, using bottom\" >&2\n    OVERLAY_X=\"(W-w)/2\"\n    OVERLAY_Y=\"H-h\"\n    ;;\nesac\n\necho \"Overlay positioning: ${OVERLAY_POSITION} at X=${OVERLAY_X}, Y=${OVERLAY_Y}, size=${OVERLAY_FINAL_WIDTH_INT}x${OVERLAY_FINAL_HEIGHT_INT}\" >&2\n\n# Main video vertical position\ncase \"$MAIN_POSITION\" in\n  top)\n    MAIN_Y=\"0\"\n    ;;\n  bottom)\n    MAIN_Y=\"H-h\"\n    ;;\n  center)\n    MAIN_Y=\"(H-h)/2\"\n    ;;\n  custom)\n    MAIN_Y=\"$MAIN_CUSTOM_Y\"\n    ;;\n  *)\n    echo \"WARN: Invalid MAIN_POSITION, using top\" >&2\n    MAIN_Y=\"0\"\n    ;;\nesac\n\necho \"Main positioning: ${MAIN_POSITION} at Y=${MAIN_Y}\" >&2\n\n# Mirror filter\nMIRROR_FILTER=\"\"\nif [ \"$MIRROR_ENABLE\" = \"true\" ]; then\n  MIRROR_FILTER=\"hflip,\"\nfi\n\n# Calculate input indices\nINPUT_INDEX=0\nOVERLAY_INDEX=1\nCAPTION_INDEX=\"\"\nRANDOM_INSERT_INDEX=\"\"\nOUTRO_INDEX=\"\"\n\nif [ \"$CAPTION_ENABLE\" = \"true\" ]; then\n  CAPTION_INDEX=2\n  NEXT_INDEX=3\nelse\n  NEXT_INDEX=2\nfi\n\nif [ -n \"$RANDOM_INSERT_FILE\" ]; then\n  RANDOM_INSERT_INDEX=$NEXT_INDEX\n  NEXT_INDEX=$((NEXT_INDEX + 1))\nfi\n\nif [ -n \"$OUTRO_FILE\" ]; then\n  OUTRO_INDEX=$NEXT_INDEX\nfi\n\n# Apply aggressive speed mode if enabled\nif [ \"$SPEED_MODE_AGGRESSIVE\" = \"true\" ]; then\n  REDUCE_RESOLUTION=true\n  USE_FAST_BILINEAR=true\n  echo \"AGGRESSIVE SPEED MODE: Enabled (quality reduced for maximum speed)\" >&2\nfi\n\n# Set scaling algorithm based on speed preference\nSCALE_ALGO=\"\"\nif [ \"$USE_FAST_BILINEAR\" = \"true\" ]; then\n  SCALE_ALGO=\"flags=fast_bilinear\"\n  echo \"Using fast_bilinear scaling (faster, lower quality)\" >&2\nelse\n  SCALE_ALGO=\"flags=lanczos\"\nfi\n\n# Determine working resolution\nWORK_WIDTH=1080\nWORK_HEIGHT=1920\nif [ \"$REDUCE_RESOLUTION\" = \"true\" ]; then\n  WORK_WIDTH=720\n  WORK_HEIGHT=1280\n  echo \"SPEED OPTIMIZATION: Processing at 720p, will upscale to 1080p at end\" >&2\nfi\n\n# Build main composition base - optimized for VPS performance\n# Format conversion done once, reduced filter complexity\nif [ \"$CAPTION_ENABLE\" = \"true\" ]; then\n  if [ \"$REDUCE_RESOLUTION\" = \"true\" ]; then\n    BASE_FILTER=\"color=c=black:s=${WORK_WIDTH}x${WORK_HEIGHT}:d=${EFFECTIVE_DURATION}[canvas]; \\\n[${INPUT_INDEX}:v]trim=duration=${INPUT_READ_DURATION},setpts=PTS-STARTPTS,${ROTATION_FILTER}${CROP_FILTER}scale=${WORK_WIDTH}:-1:${SCALE_ALGO},${MIRROR_FILTER}fps=${TARGET_FPS},format=yuv420p[main_video]; \\\n[${OVERLAY_INDEX}:v]trim=duration=${OVERLAY_READ_DURATION},setpts=PTS-STARTPTS,${OVERLAY_PRE_EFFECTS}scale=${OVERLAY_FINAL_WIDTH_INT}*2/3:${OVERLAY_FINAL_HEIGHT_INT}*2/3:${SCALE_ALGO},format=yuva420p,${OVERLAY_EFFECTS}fps=${TARGET_FPS},setpts=PTS/${OVERLAY_SPEED_FACTOR_N},tpad=stop_mode=clone:stop_duration=${INPUT_READ_DURATION}[overlay_video]; \\\n[canvas][main_video]overlay=(W-w)/2:${MAIN_Y}[bg_with_main]; \\\n[bg_with_main][overlay_video]overlay=${OVERLAY_X}:${OVERLAY_Y}:format=auto:eof_action=repeat[layout_complete]; \\\n[layout_complete][${CAPTION_INDEX}:v]overlay=0:0,setsar=1,setpts=PTS/${SPEED_FACTOR_N},scale=1080:1920:${SCALE_ALGO}[composed_main]\"\n  else\n    BASE_FILTER=\"color=c=black:s=1080x1920:d=${EFFECTIVE_DURATION}[canvas]; \\\n[${INPUT_INDEX}:v]trim=duration=${INPUT_READ_DURATION},setpts=PTS-STARTPTS,${ROTATION_FILTER}${CROP_FILTER}scale=1080:-1:${SCALE_ALGO},${MIRROR_FILTER}fps=${TARGET_FPS},format=yuv420p[main_video]; \\\n[${OVERLAY_INDEX}:v]trim=duration=${OVERLAY_READ_DURATION},setpts=PTS-STARTPTS,${OVERLAY_PRE_EFFECTS}${OVERLAY_SIZE_FILTER},format=yuva420p,${OVERLAY_EFFECTS}fps=${TARGET_FPS},setpts=PTS/${OVERLAY_SPEED_FACTOR_N},tpad=stop_mode=clone:stop_duration=${INPUT_READ_DURATION}[overlay_video]; \\\n[canvas][main_video]overlay=(W-w)/2:${MAIN_Y}[bg_with_main]; \\\n[bg_with_main][overlay_video]overlay=${OVERLAY_X}:${OVERLAY_Y}:format=auto:eof_action=repeat[layout_complete]; \\\n[layout_complete][${CAPTION_INDEX}:v]overlay=0:0,setsar=1,setpts=PTS/${SPEED_FACTOR_N}[composed_main]\"\n  fi\nelse\n  if [ \"$REDUCE_RESOLUTION\" = \"true\" ]; then\n    BASE_FILTER=\"color=c=black:s=${WORK_WIDTH}x${WORK_HEIGHT}:d=${EFFECTIVE_DURATION}[canvas]; \\\n[${INPUT_INDEX}:v]trim=duration=${INPUT_READ_DURATION},setpts=PTS-STARTPTS,${ROTATION_FILTER}${CROP_FILTER}scale=${WORK_WIDTH}:-1:${SCALE_ALGO},${MIRROR_FILTER}fps=${TARGET_FPS},format=yuv420p[main_video]; \\\n[${OVERLAY_INDEX}:v]trim=duration=${OVERLAY_READ_DURATION},setpts=PTS-STARTPTS,${OVERLAY_PRE_EFFECTS}scale=${OVERLAY_FINAL_WIDTH_INT}*2/3:${OVERLAY_FINAL_HEIGHT_INT}*2/3:${SCALE_ALGO},format=yuva420p,${OVERLAY_EFFECTS}fps=${TARGET_FPS},setpts=PTS/${OVERLAY_SPEED_FACTOR_N},tpad=stop_mode=clone:stop_duration=${INPUT_READ_DURATION}[overlay_video]; \\\n[canvas][main_video]overlay=(W-w)/2:${MAIN_Y}[bg_with_main]; \\\n[bg_with_main][overlay_video]overlay=${OVERLAY_X}:${OVERLAY_Y}:format=auto:eof_action=repeat,setsar=1,setpts=PTS/${SPEED_FACTOR_N},scale=1080:1920:${SCALE_ALGO}[composed_main]\"\n  else\n    BASE_FILTER=\"color=c=black:s=1080x1920:d=${EFFECTIVE_DURATION}[canvas]; \\\n[${INPUT_INDEX}:v]trim=duration=${INPUT_READ_DURATION},setpts=PTS-STARTPTS,${ROTATION_FILTER}${CROP_FILTER}scale=1080:-1:${SCALE_ALGO},${MIRROR_FILTER}fps=${TARGET_FPS},format=yuv420p[main_video]; \\\n[${OVERLAY_INDEX}:v]trim=duration=${OVERLAY_READ_DURATION},setpts=PTS-STARTPTS,${OVERLAY_PRE_EFFECTS}${OVERLAY_SIZE_FILTER},format=yuva420p,${OVERLAY_EFFECTS}fps=${TARGET_FPS},setpts=PTS/${OVERLAY_SPEED_FACTOR_N},tpad=stop_mode=clone:stop_duration=${INPUT_READ_DURATION}[overlay_video]; \\\n[canvas][main_video]overlay=(W-w)/2:${MAIN_Y}[bg_with_main]; \\\n[bg_with_main][overlay_video]overlay=${OVERLAY_X}:${OVERLAY_Y}:format=auto:eof_action=repeat,setsar=1,setpts=PTS/${SPEED_FACTOR_N}[composed_main]\"\n  fi\nfi\n\n# Assemble filter complex incrementally\nFILTER_LINES=\"\"\nappend_filter() {\n  if [ -z \"$FILTER_LINES\" ]; then\n    FILTER_LINES=\"$1\"\n  else\n    FILTER_LINES=\"${FILTER_LINES}; ${1}\"\n  fi\n}\n\nappend_filter \"$BASE_FILTER\"\n\n# Build the audio tempo chain for main audio\nAUDIO_TEMPO_CHAIN=\"\"\nif [ \"$SPEED_FACTOR_N\" != \"1.000000\" ]; then\n  export SPEED_FACTOR_N\n  AUDIO_TEMPO_CHAIN=$(python3 - <<'PY'\nimport os\ns = float(os.environ.get('SPEED_FACTOR_N','1'))\nif s <= 0:\n    print(\"atempo=1.0\")\nelse:\n    factors = []\n    tmp = s\n    while tmp > 2.0000001:\n        factors.append(2.0)\n        tmp = tmp / 2.0\n    while tmp < 0.5 - 1e-12:\n        factors.append(0.5)\n        tmp = tmp / 0.5\n    factors.append(round(tmp, 6))\n    out = \",\".join(f\"atempo={f:.6f}\" for f in factors)\n    print(out)\nPY\n)\n  echo \"AUDIO_TEMPO_CHAIN: $AUDIO_TEMPO_CHAIN\" >&2\nfi\n\nOVERLAY_ATEMPO_CHAIN=\"\"\nif [ \"$OVERLAY_SPEED_FACTOR_N\" != \"1.000000\" ]; then\n  export OVERLAY_SPEED_FACTOR_N\n  OVERLAY_ATEMPO_CHAIN=$(python3 - <<'PY'\nimport os\ns = float(os.environ.get('OVERLAY_SPEED_FACTOR_N','1'))\nif s <= 0:\n    print(\"atempo=1.0\")\nelse:\n    factors = []\n    tmp = s\n    while tmp > 2.0000001:\n        factors.append(2.0)\n        tmp = tmp / 2.0\n    while tmp < 0.5 - 1e-12:\n        factors.append(0.5)\n        tmp = tmp / 0.5\n    factors.append(round(tmp, 6))\n    out = \",\".join(f\"atempo={f:.6f}\" for f in factors)\n    print(out)\nPY\n)\n  echo \"OVERLAY_ATEMPO_CHAIN: $OVERLAY_ATEMPO_CHAIN\" >&2\nfi\n\nOVERLAY_AUDIO_RATE_FILTER=\"asetpts=PTS-STARTPTS\"\nif [ -n \"$OVERLAY_ATEMPO_CHAIN\" ]; then\n  OVERLAY_AUDIO_RATE_FILTER=\"$OVERLAY_AUDIO_RATE_FILTER,$OVERLAY_ATEMPO_CHAIN\"\nfi\n\n# ========== AUDIO HANDLING ==========\nAUDIO_FILTER=\"\"\nAUDIO_MAP=\"0:a?\"\n\n# NEW: Mix main audio with overlay audio FIRST (before random insert)\nif [ \"$OVERLAY_AUDIO_ENABLE\" = \"true\" ]; then\n  echo \"=== Mixing main audio with overlay audio at ${OVERLAY_AUDIO_VOLUME}% ===\" >&2\n\n  # Build base mixed audio (main + overlay) - use amerge with proper volume normalization\n  if [ -n \"$AUDIO_TEMPO_CHAIN\" ]; then\n    BASE_AUDIO_MIX=\"[0:a]atrim=duration=${INPUT_READ_DURATION},asetpts=PTS-STARTPTS,${AUDIO_TEMPO_CHAIN}[main_tempo]; \\\n[${OVERLAY_INDEX}:a]atrim=duration=${OVERLAY_READ_DURATION},${OVERLAY_AUDIO_RATE_FILTER},apad=pad_dur=${INPUT_READ_DURATION},volume=${OVERLAY_VOLUME_FLOAT}[overlay_vol]; \\\n[main_tempo][overlay_vol]amix=inputs=2:duration=longest:dropout_transition=2,volume=2[base_mixed]\"\n  else\n    BASE_AUDIO_MIX=\"[0:a]atrim=duration=${INPUT_READ_DURATION},asetpts=PTS-STARTPTS[main_a]; \\\n[${OVERLAY_INDEX}:a]atrim=duration=${OVERLAY_READ_DURATION},${OVERLAY_AUDIO_RATE_FILTER},apad=pad_dur=${INPUT_READ_DURATION},volume=${OVERLAY_VOLUME_FLOAT}[overlay_vol]; \\\n[main_a][overlay_vol]amix=inputs=2:duration=longest:dropout_transition=2,volume=2[base_mixed]\"\n  fi\n\n  AUDIO_FILTER=\"$BASE_AUDIO_MIX\"\n  MIXED_AUDIO_LABEL=\"[base_mixed]\"\nelse\n  # No overlay audio - just use main audio\n  if [ -n \"$AUDIO_TEMPO_CHAIN\" ]; then\n    AUDIO_FILTER=\"[0:a]atrim=duration=${INPUT_READ_DURATION},asetpts=PTS-STARTPTS,${AUDIO_TEMPO_CHAIN}[base_mixed]\"\n    MIXED_AUDIO_LABEL=\"[base_mixed]\"\n  else\n    MIXED_AUDIO_LABEL=\"0:a\"\n  fi\nfi\n\n# ========== RANDOM INSERT (video + audio) ==========\nif [ -n \"$RANDOM_INSERT_FILE\" ]; then\n  INSERT_DURATION=$(probe_duration \"$RANDOM_INSERT_FILE\" || printf \"2\")\n  INSERT_DURATION=$(awk -v v=\"$INSERT_DURATION\" 'BEGIN{ printf(\"%.3f\", v+0)}')\n  echo \"Random insert duration: $INSERT_DURATION seconds\" >&2\n\n  export EFFECTIVE_DURATION INSERT_DURATION\n  RANDOM_POS=$(python3 - <<'PY'\nimport os, struct\nefd = float(os.environ.get('EFFECTIVE_DURATION','0'))\nidur = float(os.environ.get('INSERT_DURATION','0'))\nminpos = 3.0\nmaxpos = efd - idur - 1.0\nif maxpos < minpos:\n    maxpos = minpos\nr = struct.unpack(\">I\", os.urandom(4))[0] / 4294967295.0\nv = minpos + r * (maxpos - minpos)\nprint(f\"{v:.3f}\")\nPY\n)\n  echo \"Random insert at: ${RANDOM_POS}s\" >&2\n\n  BEFORE_INSERT=$(awk -v p=\"$RANDOM_POS\" 'BEGIN{ printf(\"%.3f\", p) }')\n  NEW_DURATION=$(awk -v e=\"$EFFECTIVE_DURATION\" -v i=\"$INSERT_DURATION\" 'BEGIN{ printf(\"%.3f\", e+i) }')\n\n  # VIDEO insert\n  VIDEO_INSERT_BLOCK=\"[composed_main]fps=${TARGET_FPS},split=2[main1][main2]; \\\n[main1]trim=start=0:end=${BEFORE_INSERT},setpts=PTS-STARTPTS[seg1]; \\\n[main2]trim=start=${BEFORE_INSERT},setpts=PTS-STARTPTS[seg3]; \\\n[${RANDOM_INSERT_INDEX}:v]scale=1080:1920:force_original_aspect_ratio=decrease,pad=1080:1920:(ow-iw)/2:(oh-ih)/2,setsar=1,fps=${TARGET_FPS},setpts=PTS-STARTPTS[insert_scaled]; \\\n[seg1][insert_scaled][seg3]concat=n=3:v=1:a=0[concat_v]; \\\n[concat_v]fps=${TARGET_FPS}[final_v]\"\n\n  append_filter \"$VIDEO_INSERT_BLOCK\"\n\n  # AUDIO insert - split the mixed audio\n  if [ -n \"$AUDIO_FILTER\" ]; then\n    AUDIO_FILTER=\"${AUDIO_FILTER}; \\\n${MIXED_AUDIO_LABEL}asplit=2[mix1][mix2]; \\\n[mix1]atrim=start=0:end=${BEFORE_INSERT},asetpts=PTS-STARTPTS[a1]; \\\n[mix2]atrim=start=${BEFORE_INSERT},asetpts=PTS-STARTPTS[a3]; \\\n[${RANDOM_INSERT_INDEX}:a]asetpts=PTS-STARTPTS[insert_audio]; \\\n[a1][insert_audio][a3]concat=n=3:v=0:a=1[final_audio]\"\n  fi\n\n  EFFECTIVE_DURATION=\"$NEW_DURATION\"\n  AUDIO_MAP=\"[final_audio]\"\nelse\n  # No random insert - use the base mixed audio\n  if [ -n \"$AUDIO_FILTER\" ]; then\n    AUDIO_FILTER=\"${AUDIO_FILTER}; ${MIXED_AUDIO_LABEL}acopy[final_audio]\"\n    AUDIO_MAP=\"[final_audio]\"\n  else\n    AUDIO_MAP=\"${MIXED_AUDIO_LABEL}\"\n  fi\nfi\n\n# ========== OUTRO (video + audio) ==========\nif [ -n \"$OUTRO_FILE\" ] && [ -n \"$OUTRO_INDEX\" ]; then\n  OUTRO_START=$(awk -v d=\"$EFFECTIVE_DURATION\" -v t=\"$OUTRO_TRANSITION_DURATION\" 'BEGIN{ printf(\"%.3f\", d-t) }')\n\n  # VIDEO outro\n  if [ -n \"$RANDOM_INSERT_FILE\" ]; then\n    OUTRO_VIDEO_BLOCK=\"[${OUTRO_INDEX}:v]scale=1080:1920:force_original_aspect_ratio=decrease,pad=1080:1920:(ow-iw)/2:(oh-ih)/2,setsar=1,setpts=PTS-STARTPTS[outro_scaled]; \\\n[final_v]fps=${TARGET_FPS},setsar=1,setpts=PTS-STARTPTS[main_normalized]; \\\n[main_normalized]fps=${TARGET_FPS}[main_normalized_fps]; \\\n[outro_scaled]fps=${TARGET_FPS}[outro_scaled_fps]; \\\n[main_normalized_fps][outro_scaled_fps]xfade=transition=fade:duration=${OUTRO_TRANSITION_DURATION}:offset=${OUTRO_START}[final_v]\"\n    append_filter \"$OUTRO_VIDEO_BLOCK\"\n  else\n    OUTRO_VIDEO_BLOCK=\"[${OUTRO_INDEX}:v]scale=1080:1920:force_original_aspect_ratio=decrease,pad=1080:1920:(ow-iw)/2:(oh-ih)/2,setsar=1,setpts=PTS-STARTPTS[outro_scaled]; \\\n[composed_main]fps=${TARGET_FPS},setsar=1,setpts=PTS-STARTPTS[main_normalized]; \\\n[main_normalized]fps=${TARGET_FPS}[main_normalized_fps]; \\\n[outro_scaled]fps=${TARGET_FPS}[outro_scaled_fps]; \\\n[main_normalized_fps][outro_scaled_fps]xfade=transition=fade:duration=${OUTRO_TRANSITION_DURATION}:offset=${OUTRO_START}[final_v]\"\n    append_filter \"$OUTRO_VIDEO_BLOCK\"\n  fi\n\n  # AUDIO outro\n  if [ -n \"$AUDIO_FILTER\" ]; then\n    AUDIO_FILTER=\"${AUDIO_FILTER}; \\\n[${OUTRO_INDEX}:a]asetpts=PTS-STARTPTS[outro_a]; \\\n[final_audio][outro_a]concat=n=2:v=0:a=1[final_audio]\"\n  fi\n\n  OUTPUT_LABEL=\"[final_v]\"\nelse\n  if [ -n \"$RANDOM_INSERT_FILE\" ]; then\n    OUTPUT_LABEL=\"[final_v]\"\n  else\n    append_filter \"[composed_main]fps=${TARGET_FPS}[final_v]\"\n    OUTPUT_LABEL=\"[final_v]\"\n  fi\nfi\n\n# Final brightness application\nif [ \"$(awk -v b=\"$BRIGHTNESS\" 'BEGIN{ if (b==0) print \"0\"; else print \"1\" }')\" = \"1\" ]; then\n  append_filter \"[final_v]eq=brightness=${BRIGHTNESS}[final_v_out]\"\n  FINAL_OUTPUT_LABEL=\"[final_v_out]\"\nelse\n  FINAL_OUTPUT_LABEL=\"${OUTPUT_LABEL}\"\nfi\n\n# Combine all filters\nif [ -n \"$AUDIO_FILTER\" ]; then\n  COMPLETE_FILTER=\"${FILTER_LINES}; ${AUDIO_FILTER}\"\nelse\n  COMPLETE_FILTER=\"${FILTER_LINES}\"\nfi\n\n# Build input args with thread queue size for better multi-threading\nINPUT_ARGS=\"-thread_queue_size ${THREAD_QUEUE_SIZE}\"\nOVERLAY_LOOP_PREFIX=\"\"\nif [ \"$OVERLAY_LOOP_ENABLE\" = \"true\" ]; then\n  OVERLAY_LOOP_PREFIX=\"-stream_loop -1 \"\nfi\nif [ -n \"$TRIM_DURATION\" ]; then\n  INPUT_ARGS=\"$INPUT_ARGS -t ${INPUT_READ_DURATION} -i \\\"$INPUT_FILE\\\" -thread_queue_size ${THREAD_QUEUE_SIZE} ${OVERLAY_LOOP_PREFIX}-t ${OVERLAY_READ_DURATION} -i \\\"$MERGED_OVERLAY\\\"\"\nelse\n  INPUT_ARGS=\"$INPUT_ARGS -i \\\"$INPUT_FILE\\\" -thread_queue_size ${THREAD_QUEUE_SIZE} ${OVERLAY_LOOP_PREFIX}-i \\\"$MERGED_OVERLAY\\\"\"\nfi\n\nif [ \"$CAPTION_ENABLE\" = \"true\" ]; then\n  INPUT_ARGS=\"$INPUT_ARGS -thread_queue_size ${THREAD_QUEUE_SIZE} -i \\\"$CAPTION_PNG\\\"\"\nfi\n\nif [ -n \"$RANDOM_INSERT_FILE\" ]; then\n  INPUT_ARGS=\"$INPUT_ARGS -thread_queue_size ${THREAD_QUEUE_SIZE} -i \\\"$RANDOM_INSERT_FILE\\\"\"\nfi\n\nif [ -n \"$OUTRO_FILE\" ]; then\n  INPUT_ARGS=\"$INPUT_ARGS -thread_queue_size ${THREAD_QUEUE_SIZE} -i \\\"$OUTRO_FILE\\\"\"\nfi\n\n# Build final ffmpeg command with filter threading\nCMD=\"ffmpeg -hide_banner -y -progress pipe:2 -loglevel warning $INPUT_ARGS -filter_threads ${FILTER_THREADS} -filter_complex \\\"${COMPLETE_FILTER}\\\" -map \\\"${FINAL_OUTPUT_LABEL}\\\"\"\n\nif [ -n \"$AUDIO_FILTER\" ]; then\n  CMD=\"$CMD -map \\\"${AUDIO_MAP}\\\"\"\nelse\n  CMD=\"$CMD -map ${AUDIO_MAP}\"\nfi\n\n# Build x264 encoding parameters with speed optimizations\nX264_PARAMS=\"\"\nif [ \"$SPEED_MODE_AGGRESSIVE\" = \"true\" ]; then\n  # Aggressive x264 tuning for maximum speed\n  if [ \"$SLICED_THREADS\" = \"true\" ]; then\n    X264_PARAMS=\"-x264-params ref=1:bframes=0:me=dia:subme=1:trellis=0:weightp=0:cabac=0:8x8dct=0:fast-pskip=1:aq-mode=0:threads=${FFMPEG_THREADS}:sliced-threads=1\"\n  else\n    X264_PARAMS=\"-x264-params ref=1:bframes=0:me=dia:subme=1:trellis=0:weightp=0:cabac=0:8x8dct=0:fast-pskip=1:aq-mode=0:threads=${FFMPEG_THREADS}\"\n  fi\n  echo \"Using aggressive x264 parameters for maximum encoding speed\" >&2\nelif [ \"$SLICED_THREADS\" = \"true\" ]; then\n  # Add sliced threading for dual-core VPS even in normal mode\n  X264_PARAMS=\"-x264-params sliced-threads=1:threads=${FFMPEG_THREADS}\"\n  echo \"Using sliced threading for dual-core CPU optimization\" >&2\nfi\n\nCMD=\"$CMD -c:v libx264 -crf ${ENCODING_CRF} -preset ${ENCODING_PRESET} -threads ${FFMPEG_THREADS} ${X264_PARAMS} -c:a aac -b:a 128k -r ${TARGET_FPS} -aspect 9:16\"\n\nif [ -n \"$TRIM_DURATION\" ] && [ -z \"$OUTRO_FILE\" ]; then\n  CMD=\"$CMD -t ${EFFECTIVE_DURATION}\"\nfi\n\nCMD=\"$CMD \\\"$OUT_FILE\\\"\"\n\n# Debug output\necho \"=== DEBUG: filter_complex ===\" >&2\necho \"$COMPLETE_FILTER\" >&2\necho \"=== DEBUG: ffmpeg cmd ===\" >&2\necho \"$CMD\" >&2\n\n# Execute\necho \"Executing final render with overlay audio support...\" >&2\necho \"Progress will be shown below:\" >&2\n\nif sh -c \"$CMD\" < /dev/null; then\n  [ \"$CAPTION_ENABLE\" = \"true\" ] && rm -f \"$CAPTION_PNG\" || true\n  [ -n \"$MERGED_OVERLAY_TMP\" ] && [ -f \"$MERGED_OVERLAY_TMP\" ] && rm -f \"$MERGED_OVERLAY_TMP\" || true\n  [ -n \"$COMPOSED_MAIN_TMP\" ] && [ -f \"$COMPOSED_MAIN_TMP\" ] && rm -f \"$COMPOSED_MAIN_TMP\" || true\n  echo \"Success! Output file: $OUT_FILE\" >&2\n  printf '%s\\n' \"$(basename \"$OUT_FILE\")\"\n  exit 0\nelse\n  echo \"ERR: ffmpeg failed or timed out.\" >&2\n  echo \"Check the debug output above for details.\" >&2\n  exit 1\nfi\n"
      },
      "type": "n8n-nodes-base.executeCommand",
      "typeVersion": 1,
      "position": [
        -2528,
        -1248
      ],
      "id": "eccac215-ee6e-4f27-aaa6-835d19c7f723",
      "name": "Reaction2",
      "disabled": true
    }
  ],
  "origin": "n8n",
  "pinData": {},
  "repo": {
    "owner": "hellomdasif",
    "name": "n8n-backup"
  },
  "settings": {
    "executionOrder": "v1",
    "callerPolicy": "workflowsFromSameOwner",
    "availableInMCP": false,
    "errorWorkflow": "o9ORuJvZYNmMmFfK"
  },
  "shared": [
    {
      "createdAt": "2025-10-17T10:42:40.295Z",
      "updatedAt": "2025-10-17T10:42:40.295Z",
      "role": "workflow:owner",
      "workflowId": "3xsUSVxkYvsH7w2i",
      "projectId": "COQIBF46Vn0bg2e3"
    }
  ],
  "staticData": null,
  "tags": [
    {
      "createdAt": "2025-10-07T12:15:31.199Z",
      "updatedAt": "2025-10-07T12:15:31.199Z",
      "id": "FPKsDlaKRbVBVjZv",
      "name": "EXECUTE FILES"
    }
  ],
  "triggerCount": 1,
  "updatedAt": "2025-10-22T16:01:22.000Z",
  "versionId": "01fd4fdc-d937-4fb1-9e37-c408862190c6"
}