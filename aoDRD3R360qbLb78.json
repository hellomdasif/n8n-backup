{
  "active": false,
  "connections": {
    "Webhook": {
      "main": [
        [
          {
            "node": "If",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "bk": {
      "main": [
        [
          {
            "node": "Respond to Webhook",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "If": {
      "main": [
        [
          {
            "node": "Edit Fields",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "bk",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Asif": {
      "main": [
        [
          {
            "node": "Respond to Webhook",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Edit Fields": {
      "main": [
        [
          {
            "node": "Code in JavaScript",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Code in JavaScript": {
      "main": [
        [
          {
            "node": "Asif",
            "type": "main",
            "index": 0
          }
        ]
      ]
    }
  },
  "createdAt": "2025-10-01T09:53:34.630Z",
  "id": "aoDRD3R360qbLb78",
  "isArchived": true,
  "meta": null,
  "name": "REACTION2",
  "nodes": [
    {
      "parameters": {
        "path": "reaction2",
        "responseMode": "responseNode",
        "options": {}
      },
      "type": "n8n-nodes-base.webhook",
      "typeVersion": 2.1,
      "position": [
        -448,
        -528
      ],
      "id": "50db256d-b02e-4460-a6c2-0e35bd6fe584",
      "name": "Webhook",
      "webhookId": "2b211a6d-6873-4028-b8eb-4dae79db405b"
    },
    {
      "parameters": {
        "options": {}
      },
      "type": "n8n-nodes-base.respondToWebhook",
      "typeVersion": 1.4,
      "position": [
        672,
        -528
      ],
      "id": "efeeaa05-a053-4739-9483-b68568df3fa6",
      "name": "Respond to Webhook"
    },
    {
      "parameters": {
        "command": "=#!/bin/sh\nset -eu\n\n# Enhanced video composition with audio handling and fixed output path.\n# Final output is always: /files/output/output.mp4\n# Features: SPEED_FACTOR (video+main audio), BRIGHTNESS, TARGET_FPS=30\n# NEW: OVERLAY_AUDIO_ENABLE, OVERLAY_AUDIO_VOLUME (1-100)\n\n# ---------------- CONFIG ----------------\nINPUT_URL=\"{{ $node[\"Webhook\"].json.body.root_dir }}{{$node[\"Webhook\"].json.body.folder}}{{$node[\"Webhook\"].json.body.filename}}\"\nOVERLAY_FILE=\"{{$node[\"Webhook\"].json.body.OVERLAY_FILE}}\"\nOVERLAY_2=\"\"\nOVERLAY_2_LENGTH_SECONDS=\"\"\nOVERLAY_2_START_SEC=\"0\"\nOVERLAY_TRANSITION_DURATION=\"0.6\"\n\nTRIM_DURATION=\"60\" # leave empty for no trim, or number of seconds\nOUTRO_FILE=\"\"\nOUTRO_TRANSITION_DURATION=\"0.5\"\n\n# RANDOM INSERT with AUDIO support (leave empty to disable)\nRANDOM_INSERT_FILE=\"\"\nRANDOM_INSERT_TRANSITION=\"0.2\"\n\n# NEW: Overlay audio settings\nOVERLAY_AUDIO_ENABLE=true        # Enable overlay audio preservation\nOVERLAY_AUDIO_VOLUME=95           # Volume level 1-100 (100 = original, 50 = half)\n\n# Crop settings: enable independent top/bottom cropping\nCROP_ENABLE=true\nCROP_TOP_ENABLE=true\nCROP_TOP_PERCENT=35\nCROP_BOTTOM_ENABLE=true\nCROP_BOTTOM_PERCENT=5\n\n# Default crop values\nDEFAULT_CROP_TOP_PERCENT=40\nDEFAULT_CROP_BOTTOM_PERCENT=0\n\n# Mirror/flip main video horizontally\nMIRROR_ENABLE=false\n\n# Speed factor (applies to composed main video + main audio)\nSPEED_FACTOR=\"0.9\"\n\n# Brightness adjustment for final output (-1.0 .. 1.0)\nBRIGHTNESS=\"0.1\"\n\n# Force Instagram-friendly fps\nTARGET_FPS=30\n\nCAPTION_ENABLE=true\nCAPTION_FONT_PATH=\"/files/fonts/ARIALBD.TTF\"\nCAPTION_POS_X_PERCENT=50\nCAPTION_POS_Y_PERCENT=35\nCAPTION_TEXT=\"WAIT FOR END ...\"\nCAPTION_FONT_SIZE=60\nCAPTION_FONT_COLOR=\"white\"\nTEXT_BG_ENABLE=true\nTEXT_BG_COLOR=\"black\"\nTEXT_BG_OPACITY=150\nTEXT_BG_PADDING=25\n\n# ---------------- OUTPUT (FIXED) ----------------\nOUT_FILE=\"{{ $node[\"Webhook\"].json.body.root_dir }}{{$node[\"Webhook\"].json.body.folder}}output/{{$node[\"Webhook\"].json.body.filename}}\"\nmkdir -p \"$(dirname \"$OUT_FILE\")\"\n\nOUT_DIR=\"$(dirname \"$OUT_FILE\")\"\nCAPTION_PNG=\"${OUT_DIR}/caption_image.png\"\nMERGED_OVERLAY_TMP=\"${OUT_DIR}/overlay_merged_$(date +%s)_$$.mp4\"\nCOMPOSED_MAIN_TMP=\"${OUT_DIR}/main_composed_$(date +%s)_$$.mp4\"\n\nFFMPEG_TIMEOUT=\"5m\"\n# --------------- end config --------------\n\necho \"=== Start: enhanced video composition with overlay audio support ===\" >&2\n\n# Validate overlay audio volume\nif [ \"$OVERLAY_AUDIO_ENABLE\" = \"true\" ]; then\n  if [ -z \"${OVERLAY_AUDIO_VOLUME:-}\" ] || [ \"$OVERLAY_AUDIO_VOLUME\" -lt 1 ] || [ \"$OVERLAY_AUDIO_VOLUME\" -gt 100 ]; then\n    echo \"WARN: Invalid OVERLAY_AUDIO_VOLUME ($OVERLAY_AUDIO_VOLUME), using 100\" >&2\n    OVERLAY_AUDIO_VOLUME=100\n  fi\n  # Convert 1-100 scale to 0.01-1.0 for FFmpeg volume filter\n  OVERLAY_VOLUME_FLOAT=$(awk -v v=\"$OVERLAY_AUDIO_VOLUME\" 'BEGIN{ printf(\"%.2f\", v/100.0) }')\n  echo \"Overlay audio: ENABLED at ${OVERLAY_AUDIO_VOLUME}% volume (${OVERLAY_VOLUME_FLOAT})\" >&2\nelse\n  echo \"Overlay audio: DISABLED\" >&2\nfi\n\n# Resolve INPUT_FILE from INPUT_URL\nINPUT_FILE=\"$INPUT_URL\"\n\necho \"Main background: $INPUT_FILE\" >&2\necho \"Overlay primary: $OVERLAY_FILE\" >&2\n[ -n \"$OVERLAY_2\" ] && echo \"Overlay secondary: $OVERLAY_2\" >&2\n[ -n \"$OUTRO_FILE\" ] && echo \"Outro file: $OUTRO_FILE\" >&2\n[ -n \"$RANDOM_INSERT_FILE\" ] && echo \"Random insert file: $RANDOM_INSERT_FILE\" >&2\n[ -n \"$TRIM_DURATION\" ] && echo \"Trim duration: $TRIM_DURATION seconds\" >&2\necho \"SPEED_FACTOR: $SPEED_FACTOR, BRIGHTNESS: $BRIGHTNESS, TARGET_FPS: $TARGET_FPS\" >&2\n\n# Helper functions\nprobe_duration() { ffprobe -v error -show_entries format=duration -of default=noprint_wrappers=1:nokey=1 \"$1\" 2>/dev/null || printf \"\"; }\nprobe_resolution() { ffprobe -v error -select_streams v:0 -show_entries stream=width,height -of csv=p=0:s=x \"$1\" 2>/dev/null || printf \"\"; }\nprobe_framerate() { ffprobe -v error -select_streams v:0 -show_entries stream=r_frame_rate -of default=nw=1:nk=1 \"$1\" 2>/dev/null || printf \"\"; }\nhas_audio() { ffprobe -v error -select_streams a:0 -show_entries stream=codec_type -of default=nw=1:nk=1 \"$1\" 2>/dev/null | grep -q \"audio\" && echo \"yes\" || echo \"no\"; }\n\n# Validate files\nif [ ! -f \"$INPUT_FILE\" ]; then echo \"ERR: main input missing: $INPUT_FILE\" >&2; exit 1; fi\nif [ ! -f \"$OVERLAY_FILE\" ]; then echo \"ERR: overlay primary missing: $OVERLAY_FILE\" >&2; exit 1; fi\nif [ -n \"$OVERLAY_2\" ] && [ ! -f \"$OVERLAY_2\" ]; then echo \"ERR: overlay secondary missing: $OVERLAY_2\" >&2; exit 1; fi\n\n# Check if overlay has audio\nOVERLAY_HAS_AUDIO=$(has_audio \"$OVERLAY_FILE\")\nif [ \"$OVERLAY_AUDIO_ENABLE\" = \"true\" ] && [ \"$OVERLAY_HAS_AUDIO\" = \"no\" ]; then\n  echo \"WARN: Overlay audio enabled but overlay file has no audio stream. Disabling overlay audio.\" >&2\n  OVERLAY_AUDIO_ENABLE=false\nfi\n\nif [ -n \"$OUTRO_FILE\" ] && [ ! -f \"$OUTRO_FILE\" ]; then\n  echo \"WARN: outro path provided but file not found: $OUTRO_FILE — skipping outro.\" >&2\n  OUTRO_FILE=\"\"\nfi\n\nif [ -n \"$RANDOM_INSERT_FILE\" ] && [ ! -f \"$RANDOM_INSERT_FILE\" ]; then\n  echo \"ERR: random insert file missing: $RANDOM_INSERT_FILE\" >&2; exit 1;\nfi\n\nif [ -z \"${OUTRO_FILE:-}\" ]; then\n  OUTRO_FILE=\"\"\n  OUTRO_INDEX=\"\"\n  echo \"No valid outro — outro processing disabled.\" >&2\nfi\n\n# Probe overlay durations\nOV1_DUR=$(probe_duration \"$OVERLAY_FILE\"); OV1_DUR=${OV1_DUR:-0}; OV1_DUR=$(awk -v v=\"$OV1_DUR\" 'BEGIN{printf(\"%.3f\", v+0)}')\necho \"Overlay1 duration: $OV1_DUR\" >&2\nif [ -n \"$OVERLAY_2\" ]; then\n  OV2_DUR=$(probe_duration \"$OVERLAY_2\"); OV2_DUR=${OV2_DUR:-0}; OV2_DUR=$(awk -v v=\"$OV2_DUR\" 'BEGIN{printf(\"%.3f\", v+0)}')\n  echo \"Overlay2 duration: $OV2_DUR\" >&2\nfi\n\n# Determine overlay resolution and FPS\nIN_RES=$(probe_resolution \"$OVERLAY_FILE\" || true)\nif [ -n \"$IN_RES\" ]; then\n  O_W=$(printf \"%s\" \"$IN_RES\" | awk -Fx '{print $1}')\n  O_H=$(printf \"%s\" \"$IN_RES\" | awk -Fx '{print $2}')\nelse\n  O_W=720; O_H=1280\nfi\nFPS_RAW=$(probe_framerate \"$OVERLAY_FILE\" || true)\necho \"Overlay native resolution: ${O_W}x${O_H} native-fps:${FPS_RAW} -> using TARGET_FPS=${TARGET_FPS}\" >&2\n\n# Merge overlays if needed (VIDEO + AUDIO)\nif [ -z \"$OVERLAY_2\" ]; then\n  echo \"No overlay2 provided — using overlay primary as-is.\" >&2\n  MERGED_OVERLAY=\"$OVERLAY_FILE\"\nelse\n  if [ -n \"$OVERLAY_2_LENGTH_SECONDS\" ]; then\n    OVERLAY_2_LENGTH_SECONDS=$(awk -v v=\"$OVERLAY_2_LENGTH_SECONDS\" 'BEGIN{printf(\"%.3f\", v+0)}')\n    FIRST_END_SEC=$(awk -v d=\"$OV1_DUR\" -v s=\"$OVERLAY_2_LENGTH_SECONDS\" 'BEGIN{printf(\"%.3f\", d - s)}')\n  else\n    FIRST_END_SEC=$(awk -v d=\"$OV1_DUR\" 'BEGIN{printf(\"%.3f\", d*0.70)}')\n  fi\n\n  TRANS=$(awk -v v=\"$OVERLAY_TRANSITION_DURATION\" 'BEGIN{printf(\"%.3f\", v+0)}')\n  OFFSET=$(awk -v f=\"$FIRST_END_SEC\" -v t=\"$TRANS\" 'BEGIN{printf(\"%.3f\", f - t)}')\n\n  # Merge video AND audio\n  ffmpeg -y -hide_banner -loglevel error \\\n    -i \"$OVERLAY_FILE\" -i \"$OVERLAY_2\" \\\n    -filter_complex \"\\\n[0:v]trim=start=0:end=${FIRST_END_SEC},setpts=PTS-STARTPTS,scale=${O_W}:${O_H},fps=${TARGET_FPS},setsar=1,format=yuv420p[v0]; \\\n[1:v]trim=start=${OVERLAY_2_START_SEC},setpts=PTS-STARTPTS,scale=${O_W}:${O_H},fps=${TARGET_FPS},setsar=1,format=yuv420p[v1]; \\\n[v0][v1]xfade=transition=fade:duration=${TRANS}:offset=${OFFSET}[vxf]; \\\n[0:a]atrim=start=0:end=${FIRST_END_SEC},asetpts=PTS-STARTPTS[a0]; \\\n[1:a]atrim=start=${OVERLAY_2_START_SEC},asetpts=PTS-STARTPTS[a1]; \\\n[a0][a1]acrossfade=d=${TRANS}:o=${OFFSET}[axf]\" \\\n    -map \"[vxf]\" -map \"[axf]\" -c:v libx264 -crf 18 -preset veryfast -c:a aac -b:a 192k -movflags +faststart \\\n    \"$MERGED_OVERLAY_TMP\"\n\n  MERGED_OVERLAY=\"$MERGED_OVERLAY_TMP\"\nfi\n\n# Generate caption if enabled\nif [ \"$CAPTION_ENABLE\" = \"true\" ]; then\n  rm -f \"${CAPTION_PNG}\" || true\n  export CAPTION_PNG CAPTION_TEXT CAPTION_FONT_PATH CAPTION_FONT_SIZE CAPTION_FONT_COLOR CAPTION_POS_X_PERCENT CAPTION_POS_Y_PERCENT TEXT_BG_ENABLE TEXT_BG_COLOR TEXT_BG_OPACITY TEXT_BG_PADDING\n  python3 - <<'PY' 1>&2\nimport os\nfrom PIL import Image, ImageDraw, ImageFont\n\nout_path = os.environ[\"CAPTION_PNG\"]\ntext = os.environ.get(\"CAPTION_TEXT\", \"\")\nfont_path = os.environ.get(\"CAPTION_FONT_PATH\", \"/usr/share/fonts/truetype/dejavu/DejaVuSans-Bold.ttf\")\ntry:\n    font_size = int(os.environ.get(\"CAPTION_FONT_SIZE\", \"64\"))\nexcept Exception:\n    font_size = 64\nfont_color = os.environ.get(\"CAPTION_FONT_COLOR\", \"white\")\ntry:\n    pos_x_pct = int(os.environ.get(\"CAPTION_POS_X_PERCENT\", \"50\"))\nexcept Exception:\n    pos_x_pct = 50\ntry:\n    pos_y_pct = int(os.environ.get(\"CAPTION_POS_Y_PERCENT\", \"50\"))\nexcept Exception:\n    pos_y_pct = 50\nbg_enable = os.environ.get(\"TEXT_BG_ENABLE\", \"true\").lower() == 'true'\ntry:\n    bg_opacity = int(os.environ.get(\"TEXT_BG_OPACITY\", \"150\"))\nexcept Exception:\n    bg_opacity = 150\ntry:\n    bg_padding = int(os.environ.get(\"TEXT_BG_PADDING\", \"20\"))\nexcept Exception:\n    bg_padding = 20\n\ncanvas_w, canvas_h = 1080, 1920\ncanvas = Image.new(\"RGBA\", (canvas_w, canvas_h), (0, 0, 0, 0))\ndraw = ImageDraw.Draw(canvas)\nfont = None\ntry:\n    font = ImageFont.truetype(font_path, font_size)\nexcept Exception:\n    candidates = [\n        \"/usr/share/fonts/truetype/dejavu/DejaVuSans-Bold.ttf\",\n        \"/usr/share/fonts/truetype/liberation/LiberationSans-Bold.ttf\"\n    ]\n    for p in candidates:\n        if os.path.isfile(p):\n            try:\n                font = ImageFont.truetype(p, font_size)\n                break\n            except Exception:\n                pass\nif font is None:\n    font = ImageFont.load_default()\n\ntext = text or \" \"\nlines = text.splitlines() if \"\\n\" in text else [text]\nline_heights = []\nmax_w = 0\ntemp_draw = ImageDraw.Draw(canvas)\nfor ln in lines:\n    bbox = temp_draw.textbbox((0,0), ln, font=font)\n    w = bbox[2] - bbox[0]\n    h = bbox[3] - bbox[1]\n    line_heights.append(h)\n    if w > max_w:\n        max_w = w\ntotal_h = sum(line_heights) + (len(lines)-1) * int(font_size * 0.2)\n\nx = (canvas_w * pos_x_pct / 100.0) - (max_w / 2.0)\ny = (canvas_h * pos_y_pct / 100.0) - (total_h / 2.0)\n\nif bg_enable:\n    bg_layer = Image.new(\"RGBA\", (canvas_w, canvas_h), (0,0,0,0))\n    bg_draw = ImageDraw.Draw(bg_layer)\n    left = int(x - bg_padding); top = int(y - bg_padding)\n    right = int(x + max_w + bg_padding); bottom = int(y + total_h + bg_padding)\n    bg_draw.rectangle([left, top, right, bottom], fill=(0,0,0,bg_opacity))\n    canvas = Image.alpha_composite(canvas, bg_layer)\n\ndraw = ImageDraw.Draw(canvas)\ncur_y = y\nfor idx, ln in enumerate(lines):\n    draw.text((x, cur_y), ln, font=font, fill=font_color)\n    cur_y += line_heights[idx] + int(font_size * 0.2)\n\nos.makedirs(os.path.dirname(out_path), exist_ok=True)\ncanvas.save(out_path)\nPY\n  if [ ! -f \"$CAPTION_PNG\" ]; then echo \"ERR: caption generation failed.\" >&2; exit 1; fi\nfi\n\n# Probe main duration\nMAIN_VID_DURATION=$(probe_duration \"$INPUT_FILE\" || printf \"\")\nMAIN_VID_DURATION=${MAIN_VID_DURATION:-10}\nMAIN_VID_DURATION=$(awk -v v=\"$MAIN_VID_DURATION\" 'BEGIN{ if(v==0) v=10; printf(\"%.3f\", v+0)}')\necho \"Main video duration (original): $MAIN_VID_DURATION\" >&2\n\n# Calculate proper INPUT_READ_DURATION based on SPEED_FACTOR\nSPEED_FACTOR_N=$(awk -v s=\"$SPEED_FACTOR\" 'BEGIN{ if(s<=0) s=1.0; printf(\"%.6f\", s+0) }')\n\n# Apply trim with speed factor consideration\nINPUT_READ_DURATION=\"\"\nif [ -n \"$TRIM_DURATION\" ]; then\n    INPUT_READ_DURATION=$(awk -v t=\"$TRIM_DURATION\" -v s=\"$SPEED_FACTOR_N\" 'BEGIN{ printf(\"%.3f\", t*s) }')\n    if [ \"$(awk -v i=\"$INPUT_READ_DURATION\" -v m=\"$MAIN_VID_DURATION\" 'BEGIN{ if(i>m) print 1; else print 0 }')\" = \"1\" ]; then\n        echo \"WARNING: Requested duration exceeds available. Adjusting...\" >&2\n        INPUT_READ_DURATION=\"$MAIN_VID_DURATION\"\n        EFFECTIVE_DURATION=$(awk -v i=\"$INPUT_READ_DURATION\" -v s=\"$SPEED_FACTOR_N\" 'BEGIN{ printf(\"%.3f\", i/s) }')\n    else\n        EFFECTIVE_DURATION=\"$TRIM_DURATION\"\n    fi\nelse\n    INPUT_READ_DURATION=\"$MAIN_VID_DURATION\"\n    EFFECTIVE_DURATION=$(awk -v m=\"$MAIN_VID_DURATION\" -v s=\"$SPEED_FACTOR_N\" 'BEGIN{ printf(\"%.3f\", m/s) }')\nfi\n\necho \"SPEED_FACTOR: $SPEED_FACTOR_N\" >&2\necho \"INPUT_READ_DURATION: $INPUT_READ_DURATION (amount to read from files)\" >&2\necho \"EFFECTIVE_DURATION: $EFFECTIVE_DURATION (output duration after speed change)\" >&2\n\n# Rotation and crop filters\nROTATE_TAG=$(ffprobe -v error -select_streams v:0 -show_entries stream_tags=rotate -of default=nw=1:nk=1 \"$INPUT_FILE\" 2>/dev/null || printf \"0\")\nROTATION_FILTER=\"\"\ncase \"$ROTATE_TAG\" in\n  90) ROTATION_FILTER=\"transpose=1,\" ;;\n  270) ROTATION_FILTER=\"transpose=2,\" ;;\nesac\n\n# Build crop filter\nCROP_FILTER=\"\"\nif [ \"$CROP_ENABLE\" = \"true\" ]; then\n  CROP_TOP_PCT=0\n  CROP_BOTTOM_PCT=0\n  \n  if [ \"$CROP_TOP_ENABLE\" = \"true\" ]; then\n    if [ -z \"${CROP_TOP_PERCENT:-}\" ]; then\n      CROP_TOP_PCT=$DEFAULT_CROP_TOP_PERCENT\n      echo \"CROP_TOP_PERCENT not set, using default: ${DEFAULT_CROP_TOP_PERCENT}%\" >&2\n    else\n      case \"$CROP_TOP_PERCENT\" in\n        ''|*[!0-9]*)\n          CROP_TOP_PCT=$DEFAULT_CROP_TOP_PERCENT\n          echo \"CROP_TOP_PERCENT invalid, using default: ${DEFAULT_CROP_TOP_PERCENT}%\" >&2\n          ;;\n        *)\n          CROP_TOP_PCT=$CROP_TOP_PERCENT\n          ;;\n      esac\n    fi\n  fi\n  \n  if [ \"$CROP_BOTTOM_ENABLE\" = \"true\" ]; then\n    if [ -z \"${CROP_BOTTOM_PERCENT:-}\" ]; then\n      CROP_BOTTOM_PCT=$DEFAULT_CROP_BOTTOM_PERCENT\n      echo \"CROP_BOTTOM_PERCENT not set, using default: ${DEFAULT_CROP_BOTTOM_PERCENT}%\" >&2\n    else\n      case \"$CROP_BOTTOM_PERCENT\" in\n        ''|*[!0-9]*)\n          CROP_BOTTOM_PCT=$DEFAULT_CROP_BOTTOM_PERCENT\n          echo \"CROP_BOTTOM_PERCENT invalid, using default: ${DEFAULT_CROP_BOTTOM_PERCENT}%\" >&2\n          ;;\n        *)\n          CROP_BOTTOM_PCT=$CROP_BOTTOM_PERCENT\n          ;;\n      esac\n    fi\n  fi\n  \n  TOTAL_CROP_PCT=$((CROP_TOP_PCT + CROP_BOTTOM_PCT))\n  \n  if [ \"$TOTAL_CROP_PCT\" -gt 0 ] && [ \"$TOTAL_CROP_PCT\" -lt 100 ]; then\n    KEEP_PCT=$((100 - TOTAL_CROP_PCT))\n    echo \"Crop settings: Top=${CROP_TOP_PCT}%, Bottom=${CROP_BOTTOM_PCT}%, Keeping=${KEEP_PCT}%\" >&2\n    CROP_FILTER=\"crop=in_w:in_h*${KEEP_PCT}/100:0:in_h*${CROP_TOP_PCT}/100,\"\n  elif [ \"$TOTAL_CROP_PCT\" -ge 100 ]; then\n    echo \"WARNING: Total crop percentage >= 100%, disabling crop\" >&2\n    CROP_FILTER=\"\"\n  fi\nfi\n\n# Mirror filter\nMIRROR_FILTER=\"\"\nif [ \"$MIRROR_ENABLE\" = \"true\" ]; then\n  MIRROR_FILTER=\"hflip,\"\nfi\n\n# Calculate input indices\nINPUT_INDEX=0\nOVERLAY_INDEX=1\nCAPTION_INDEX=\"\"\nRANDOM_INSERT_INDEX=\"\"\nOUTRO_INDEX=\"\"\n\nif [ \"$CAPTION_ENABLE\" = \"true\" ]; then\n  CAPTION_INDEX=2\n  NEXT_INDEX=3\nelse\n  NEXT_INDEX=2\nfi\n\nif [ -n \"$RANDOM_INSERT_FILE\" ]; then\n  RANDOM_INSERT_INDEX=$NEXT_INDEX\n  NEXT_INDEX=$((NEXT_INDEX + 1))\nfi\n\nif [ -n \"$OUTRO_FILE\" ]; then\n  OUTRO_INDEX=$NEXT_INDEX\nfi\n\n# Build main composition base\nif [ \"$CAPTION_ENABLE\" = \"true\" ]; then\n  BASE_FILTER=\"color=c=black:s=1080x1920:d=${EFFECTIVE_DURATION}[canvas]; \\\n[${OVERLAY_INDEX}:v]trim=duration=${INPUT_READ_DURATION},setpts=PTS-STARTPTS,scale=1080:-1,crop=1080:ih[top_video]; \\\n[${INPUT_INDEX}:v]trim=duration=${INPUT_READ_DURATION},setpts=PTS-STARTPTS,${ROTATION_FILTER}${CROP_FILTER}scale=1080:-1,${MIRROR_FILTER}format=yuv420p[bottom_video]; \\\n[canvas][top_video]overlay=0:0[bg_with_top]; \\\n[bg_with_top][bottom_video]overlay=(W-w)/2:H-h[layout_complete]; \\\n[layout_complete][${CAPTION_INDEX}:v]overlay=0:0,setsar=1,format=yuv420p,fps=${TARGET_FPS},setpts=PTS/${SPEED_FACTOR_N}[composed_main]\"\nelse\n  BASE_FILTER=\"color=c=black:s=1080x1920:d=${EFFECTIVE_DURATION}[canvas]; \\\n[${OVERLAY_INDEX}:v]trim=duration=${INPUT_READ_DURATION},setpts=PTS-STARTPTS,scale=1080:-1,crop=1080:ih[top_video]; \\\n[${INPUT_INDEX}:v]trim=duration=${INPUT_READ_DURATION},setpts=PTS-STARTPTS,${ROTATION_FILTER}${CROP_FILTER}scale=1080:-1,${MIRROR_FILTER}format=yuv420p[bottom_video]; \\\n[canvas][top_video]overlay=0:0[bg_with_top]; \\\n[bg_with_top][bottom_video]overlay=(W-w)/2:H-h,setsar=1,format=yuv420p,fps=${TARGET_FPS},setpts=PTS/${SPEED_FACTOR_N}[composed_main]\"\nfi\n\n# Assemble filter complex incrementally\nFILTER_LINES=\"\"\nappend_filter() {\n  if [ -z \"$FILTER_LINES\" ]; then\n    FILTER_LINES=\"$1\"\n  else\n    FILTER_LINES=\"${FILTER_LINES}; ${1}\"\n  fi\n}\n\nappend_filter \"$BASE_FILTER\"\n\n# Build the audio tempo chain for main audio\nAUDIO_TEMPO_CHAIN=\"\"\nif [ \"$SPEED_FACTOR_N\" != \"1.000000\" ]; then\n  export SPEED_FACTOR_N\n  AUDIO_TEMPO_CHAIN=$(python3 - <<'PY'\nimport os\ns = float(os.environ.get('SPEED_FACTOR_N','1'))\nif s <= 0:\n    print(\"atempo=1.0\")\nelse:\n    factors = []\n    tmp = s\n    while tmp > 2.0000001:\n        factors.append(2.0)\n        tmp = tmp / 2.0\n    while tmp < 0.5 - 1e-12:\n        factors.append(0.5)\n        tmp = tmp / 0.5\n    factors.append(round(tmp, 6))\n    out = \",\".join(f\"atempo={f:.6f}\" for f in factors)\n    print(out)\nPY\n)\n  echo \"AUDIO_TEMPO_CHAIN: $AUDIO_TEMPO_CHAIN\" >&2\nfi\n\n# ========== AUDIO HANDLING ==========\nAUDIO_FILTER=\"\"\nAUDIO_MAP=\"0:a?\"\n\n# NEW: Mix main audio with overlay audio FIRST (before random insert)\nif [ \"$OVERLAY_AUDIO_ENABLE\" = \"true\" ]; then\n  echo \"=== Mixing main audio with overlay audio at ${OVERLAY_AUDIO_VOLUME}% ===\" >&2\n  \n  # Build base mixed audio (main + overlay)\n  if [ -n \"$AUDIO_TEMPO_CHAIN\" ]; then\n    BASE_AUDIO_MIX=\"[0:a]atrim=duration=${INPUT_READ_DURATION},asetpts=PTS-STARTPTS,${AUDIO_TEMPO_CHAIN}[main_tempo]; \\\n[${OVERLAY_INDEX}:a]atrim=duration=${INPUT_READ_DURATION},asetpts=PTS-STARTPTS,volume=${OVERLAY_VOLUME_FLOAT}[overlay_vol]; \\\n[main_tempo][overlay_vol]amix=inputs=2:duration=longest:dropout_transition=2[base_mixed]\"\n  else\n    BASE_AUDIO_MIX=\"[0:a]atrim=duration=${INPUT_READ_DURATION},asetpts=PTS-STARTPTS[main_a]; \\\n[${OVERLAY_INDEX}:a]atrim=duration=${INPUT_READ_DURATION},asetpts=PTS-STARTPTS,volume=${OVERLAY_VOLUME_FLOAT}[overlay_vol]; \\\n[main_a][overlay_vol]amix=inputs=2:duration=longest:dropout_transition=2[base_mixed]\"\n  fi\n  \n  AUDIO_FILTER=\"$BASE_AUDIO_MIX\"\n  MIXED_AUDIO_LABEL=\"[base_mixed]\"\nelse\n  # No overlay audio - just use main audio\n  if [ -n \"$AUDIO_TEMPO_CHAIN\" ]; then\n    AUDIO_FILTER=\"[0:a]atrim=duration=${INPUT_READ_DURATION},asetpts=PTS-STARTPTS,${AUDIO_TEMPO_CHAIN}[base_mixed]\"\n    MIXED_AUDIO_LABEL=\"[base_mixed]\"\n  else\n    MIXED_AUDIO_LABEL=\"0:a\"\n  fi\nfi\n\n# ========== RANDOM INSERT (video + audio) ==========\nif [ -n \"$RANDOM_INSERT_FILE\" ]; then\n  INSERT_DURATION=$(probe_duration \"$RANDOM_INSERT_FILE\" || printf \"2\")\n  INSERT_DURATION=$(awk -v v=\"$INSERT_DURATION\" 'BEGIN{ printf(\"%.3f\", v+0)}')\n  echo \"Random insert duration: $INSERT_DURATION seconds\" >&2\n\n  export EFFECTIVE_DURATION INSERT_DURATION\n  RANDOM_POS=$(python3 - <<'PY'\nimport os, struct\nefd = float(os.environ.get('EFFECTIVE_DURATION','0'))\nidur = float(os.environ.get('INSERT_DURATION','0'))\nminpos = 3.0\nmaxpos = efd - idur - 1.0\nif maxpos < minpos:\n    maxpos = minpos\nr = struct.unpack(\">I\", os.urandom(4))[0] / 4294967295.0\nv = minpos + r * (maxpos - minpos)\nprint(f\"{v:.3f}\")\nPY\n)\n  echo \"Random insert at: ${RANDOM_POS}s\" >&2\n\n  BEFORE_INSERT=$(awk -v p=\"$RANDOM_POS\" 'BEGIN{ printf(\"%.3f\", p) }')\n  NEW_DURATION=$(awk -v e=\"$EFFECTIVE_DURATION\" -v i=\"$INSERT_DURATION\" 'BEGIN{ printf(\"%.3f\", e+i) }')\n\n  # VIDEO insert\n  VIDEO_INSERT_BLOCK=\"[composed_main]fps=${TARGET_FPS},split=2[main1][main2]; \\\n[main1]trim=start=0:end=${BEFORE_INSERT},setpts=PTS-STARTPTS[seg1]; \\\n[main2]trim=start=${BEFORE_INSERT},setpts=PTS-STARTPTS[seg3]; \\\n[${RANDOM_INSERT_INDEX}:v]scale=1080:1920:force_original_aspect_ratio=decrease,pad=1080:1920:(ow-iw)/2:(oh-ih)/2,setsar=1,fps=${TARGET_FPS},setpts=PTS-STARTPTS[insert_scaled]; \\\n[seg1][insert_scaled][seg3]concat=n=3:v=1:a=0[concat_v]; \\\n[concat_v]fps=${TARGET_FPS}[final_v]\"\n\n  append_filter \"$VIDEO_INSERT_BLOCK\"\n\n  # AUDIO insert - split the mixed audio\n  if [ -n \"$AUDIO_FILTER\" ]; then\n    AUDIO_FILTER=\"${AUDIO_FILTER}; \\\n${MIXED_AUDIO_LABEL}asplit=2[mix1][mix2]; \\\n[mix1]atrim=start=0:end=${BEFORE_INSERT},asetpts=PTS-STARTPTS[a1]; \\\n[mix2]atrim=start=${BEFORE_INSERT},asetpts=PTS-STARTPTS[a3]; \\\n[${RANDOM_INSERT_INDEX}:a]asetpts=PTS-STARTPTS[insert_audio]; \\\n[a1][insert_audio][a3]concat=n=3:v=0:a=1[final_audio]\"\n  fi\n\n  EFFECTIVE_DURATION=\"$NEW_DURATION\"\n  AUDIO_MAP=\"[final_audio]\"\nelse\n  # No random insert - use the base mixed audio\n  if [ -n \"$AUDIO_FILTER\" ]; then\n    AUDIO_FILTER=\"${AUDIO_FILTER}; ${MIXED_AUDIO_LABEL}acopy[final_audio]\"\n    AUDIO_MAP=\"[final_audio]\"\n  else\n    AUDIO_MAP=\"${MIXED_AUDIO_LABEL}\"\n  fi\nfi\n\n# ========== OUTRO (video + audio) ==========\nif [ -n \"$OUTRO_FILE\" ] && [ -n \"$OUTRO_INDEX\" ]; then\n  OUTRO_START=$(awk -v d=\"$EFFECTIVE_DURATION\" -v t=\"$OUTRO_TRANSITION_DURATION\" 'BEGIN{ printf(\"%.3f\", d-t) }')\n\n  # VIDEO outro\n  if [ -n \"$RANDOM_INSERT_FILE\" ]; then\n    OUTRO_VIDEO_BLOCK=\"[${OUTRO_INDEX}:v]scale=1080:1920:force_original_aspect_ratio=decrease,pad=1080:1920:(ow-iw)/2:(oh-ih)/2,setsar=1,setpts=PTS-STARTPTS[outro_scaled]; \\\n[final_v]fps=${TARGET_FPS},setsar=1,setpts=PTS-STARTPTS[main_normalized]; \\\n[main_normalized]fps=${TARGET_FPS}[main_normalized_fps]; \\\n[outro_scaled]fps=${TARGET_FPS}[outro_scaled_fps]; \\\n[main_normalized_fps][outro_scaled_fps]xfade=transition=fade:duration=${OUTRO_TRANSITION_DURATION}:offset=${OUTRO_START}[final_v]\"\n    append_filter \"$OUTRO_VIDEO_BLOCK\"\n  else\n    OUTRO_VIDEO_BLOCK=\"[${OUTRO_INDEX}:v]scale=1080:1920:force_original_aspect_ratio=decrease,pad=1080:1920:(ow-iw)/2:(oh-ih)/2,setsar=1,setpts=PTS-STARTPTS[outro_scaled]; \\\n[composed_main]fps=${TARGET_FPS},setsar=1,setpts=PTS-STARTPTS[main_normalized]; \\\n[main_normalized]fps=${TARGET_FPS}[main_normalized_fps]; \\\n[outro_scaled]fps=${TARGET_FPS}[outro_scaled_fps]; \\\n[main_normalized_fps][outro_scaled_fps]xfade=transition=fade:duration=${OUTRO_TRANSITION_DURATION}:offset=${OUTRO_START}[final_v]\"\n    append_filter \"$OUTRO_VIDEO_BLOCK\"\n  fi\n\n  # AUDIO outro\n  if [ -n \"$AUDIO_FILTER\" ]; then\n    AUDIO_FILTER=\"${AUDIO_FILTER}; \\\n[${OUTRO_INDEX}:a]asetpts=PTS-STARTPTS[outro_a]; \\\n[final_audio][outro_a]concat=n=2:v=0:a=1[final_audio]\"\n  fi\n\n  OUTPUT_LABEL=\"[final_v]\"\nelse\n  if [ -n \"$RANDOM_INSERT_FILE\" ]; then\n    OUTPUT_LABEL=\"[final_v]\"\n  else\n    append_filter \"[composed_main]fps=${TARGET_FPS}[final_v]\"\n    OUTPUT_LABEL=\"[final_v]\"\n  fi\nfi\n\n# Final brightness application\nif [ \"$(awk -v b=\"$BRIGHTNESS\" 'BEGIN{ if (b==0) print \"0\"; else print \"1\" }')\" = \"1\" ]; then\n  append_filter \"[final_v]eq=brightness=${BRIGHTNESS}[final_v_out]\"\n  FINAL_OUTPUT_LABEL=\"[final_v_out]\"\nelse\n  FINAL_OUTPUT_LABEL=\"${OUTPUT_LABEL}\"\nfi\n\n# Combine all filters\nif [ -n \"$AUDIO_FILTER\" ]; then\n  COMPLETE_FILTER=\"${FILTER_LINES}; ${AUDIO_FILTER}\"\nelse\n  COMPLETE_FILTER=\"${FILTER_LINES}\"\nfi\n\n# Build input args\nINPUT_ARGS=\"\"\nif [ -n \"$TRIM_DURATION\" ]; then\n  INPUT_ARGS=\"-t ${INPUT_READ_DURATION} -i \\\"$INPUT_FILE\\\" -t ${INPUT_READ_DURATION} -i \\\"$MERGED_OVERLAY\\\"\"\nelse\n  INPUT_ARGS=\"-i \\\"$INPUT_FILE\\\" -i \\\"$MERGED_OVERLAY\\\"\"\nfi\n\nif [ \"$CAPTION_ENABLE\" = \"true\" ]; then\n  INPUT_ARGS=\"$INPUT_ARGS -i \\\"$CAPTION_PNG\\\"\"\nfi\n\nif [ -n \"$RANDOM_INSERT_FILE\" ]; then\n  INPUT_ARGS=\"$INPUT_ARGS -i \\\"$RANDOM_INSERT_FILE\\\"\"\nfi\n\nif [ -n \"$OUTRO_FILE\" ]; then\n  INPUT_ARGS=\"$INPUT_ARGS -i \\\"$OUTRO_FILE\\\"\"\nfi\n\n# Build final ffmpeg command\nCMD=\"ffmpeg -hide_banner -y -progress pipe:2 -loglevel warning $INPUT_ARGS -filter_complex \\\"${COMPLETE_FILTER}\\\" -map \\\"${FINAL_OUTPUT_LABEL}\\\"\"\n\nif [ -n \"$AUDIO_FILTER\" ]; then\n  CMD=\"$CMD -map \\\"${AUDIO_MAP}\\\"\"\nelse\n  CMD=\"$CMD -map ${AUDIO_MAP}\"\nfi\n\nCMD=\"$CMD -c:v libx264 -crf 23 -preset veryfast -c:a aac -b:a 192k -r ${TARGET_FPS} -aspect 9:16\"\n\nif [ -n \"$TRIM_DURATION\" ] && [ -z \"$OUTRO_FILE\" ]; then\n  CMD=\"$CMD -t ${EFFECTIVE_DURATION}\"\nfi\n\nCMD=\"$CMD \\\"$OUT_FILE\\\"\"\n\n# Debug output\necho \"=== DEBUG: filter_complex ===\" >&2\necho \"$COMPLETE_FILTER\" >&2\necho \"=== DEBUG: ffmpeg cmd ===\" >&2\necho \"$CMD\" >&2\n\n# Execute\necho \"Executing final render with overlay audio support...\" >&2\necho \"Progress will be shown below:\" >&2\n\nif timeout \"$FFMPEG_TIMEOUT\" sh -c \"$CMD\" < /dev/null; then\n  [ \"$CAPTION_ENABLE\" = \"true\" ] && rm -f \"$CAPTION_PNG\" || true\n  [ -n \"$MERGED_OVERLAY_TMP\" ] && [ -f \"$MERGED_OVERLAY_TMP\" ] && rm -f \"$MERGED_OVERLAY_TMP\" || true\n  [ -n \"$COMPOSED_MAIN_TMP\" ] && [ -f \"$COMPOSED_MAIN_TMP\" ] && rm -f \"$COMPOSED_MAIN_TMP\" || true\n  echo \"✅ Success! Output file: $OUT_FILE\" >&2\n  printf '%s\\n' \"$(basename \"$OUT_FILE\")\"\n  exit 0\nelse\n  echo \"❌ ERR: ffmpeg failed or timed out.\" >&2\n  echo \"Check the debug output above for details.\" >&2\n  exit 1\nfi"
      },
      "type": "n8n-nodes-base.executeCommand",
      "typeVersion": 1,
      "position": [
        464,
        -464
      ],
      "id": "3c5a8312-e415-40c6-b448-c713925000b5",
      "name": "bk"
    },
    {
      "parameters": {
        "command": "=#!/bin/sh\nset -eu\n\n# Enhanced video composition with audio handling and fixed output path.\n# Final output is always: /files/output/output.mp4\n# Features: SPEED_FACTOR (video+main audio), BRIGHTNESS, TARGET_FPS=30\n\n# ---------------- CONFIG ----------------\nINPUT_URL=\"{{ $node[\"Webhook\"].json.body.root_dir }}{{$node[\"Webhook\"].json.body.folder}}{{$node[\"Webhook\"].json.body.filename}}\"\nOVERLAY_FILE=\"{{$node[\"Webhook\"].json.body.OVERLAY_FILE}}\"\nOVERLAY_2=\"\"\nOVERLAY_2_LENGTH_SECONDS=\"\"\nOVERLAY_2_START_SEC=\"0\"\nOVERLAY_TRANSITION_DURATION=\"0.6\"\n\nTRIM_DURATION=\"60\" # leave empty for no trim, or number of seconds\nOUTRO_FILE=\"\"\nOUTRO_TRANSITION_DURATION=\"0.5\"\n\n# RANDOM INSERT with AUDIO support (leave empty to disable)\nRANDOM_INSERT_FILE=\"\"\nRANDOM_INSERT_TRANSITION=\"0.2\"\n\n# Crop settings: enable independent top/bottom cropping\nCROP_ENABLE=true\nCROP_TOP_ENABLE=true      # Enable top crop\nCROP_TOP_PERCENT=35       # Percentage to crop from top (0-100)\nCROP_BOTTOM_ENABLE=true  # Enable bottom crop\nCROP_BOTTOM_PERCENT=5     # Percentage to crop from bottom (0-100)\n\n# Default crop values (used when CROP_TOP_PERCENT or CROP_BOTTOM_PERCENT are empty/invalid)\nDEFAULT_CROP_TOP_PERCENT=40    # Default percentage for top crop\nDEFAULT_CROP_BOTTOM_PERCENT=0  # Default percentage for bottom crop\n\n# Mirror/flip main video horizontally\nMIRROR_ENABLE=false\n\n# Speed factor (applies to composed main video + main audio)\n# <1.0 slows down (e.g., 0.8), 1.0 normal, >1.0 speeds up (e.g., 1.2)\nSPEED_FACTOR=\"0.9\"\n\n# Brightness adjustment for final output (-1.0 .. 1.0)\nBRIGHTNESS=\"0.1\"\n\n# Force Instagram-friendly fps\nTARGET_FPS=30\n\nCAPTION_ENABLE=true\nCAPTION_FONT_PATH=\"/files/fonts/ARIALBD.TTF\"\nCAPTION_POS_X_PERCENT=50\nCAPTION_POS_Y_PERCENT=35\nCAPTION_TEXT=\"WAIT FOR END ...\"\nCAPTION_FONT_SIZE=60\nCAPTION_FONT_COLOR=\"white\"\nTEXT_BG_ENABLE=true\nTEXT_BG_COLOR=\"black\"\nTEXT_BG_OPACITY=150\nTEXT_BG_PADDING=25\n\n# ---------------- OUTPUT (FIXED) ----------------\nOUT_FILE=\"{{ $node[\"Webhook\"].json.body.root_dir }}{{$node[\"Webhook\"].json.body.folder}}output/{{$node[\"Webhook\"].json.body.filename}}\"\nmkdir -p \"$(dirname \"$OUT_FILE\")\"\n\nOUT_DIR=\"$(dirname \"$OUT_FILE\")\"\nCAPTION_PNG=\"${OUT_DIR}/caption_image.png\"\nMERGED_OVERLAY_TMP=\"${OUT_DIR}/overlay_merged_$(date +%s)_$$.mp4\"\nCOMPOSED_MAIN_TMP=\"${OUT_DIR}/main_composed_$(date +%s)_$$.mp4\"\n\nFFMPEG_TIMEOUT=\"5m\"\n# --------------- end config --------------\n\necho \"=== Start: enhanced video composition with audio insert ===\" >&2\n\n# Resolve INPUT_FILE from INPUT_URL (same logic as before)\nINPUT_FILE=\"$INPUT_URL\"\n\n\necho \"Main background: $INPUT_FILE\" >&2\necho \"Overlay primary: $OVERLAY_FILE\" >&2\n[ -n \"$OVERLAY_2\" ] && echo \"Overlay secondary: $OVERLAY_2\" >&2\n[ -n \"$OUTRO_FILE\" ] && echo \"Outro file: $OUTRO_FILE\" >&2\n[ -n \"$RANDOM_INSERT_FILE\" ] && echo \"Random insert file: $RANDOM_INSERT_FILE\" >&2\n[ -n \"$TRIM_DURATION\" ] && echo \"Trim duration: $TRIM_DURATION seconds\" >&2\necho \"SPEED_FACTOR: $SPEED_FACTOR, BRIGHTNESS: $BRIGHTNESS, TARGET_FPS: $TARGET_FPS\" >&2\n\n# Helper functions\nprobe_duration() { ffprobe -v error -show_entries format=duration -of default=noprint_wrappers=1:nokey=1 \"$1\" 2>/dev/null || printf \"\"; }\nprobe_resolution() { ffprobe -v error -select_streams v:0 -show_entries stream=width,height -of csv=p=0:s=x \"$1\" 2>/dev/null || printf \"\"; }\nprobe_framerate() { ffprobe -v error -select_streams v:0 -show_entries stream=r_frame_rate -of default=nw=1:nk=1 \"$1\" 2>/dev/null || printf \"\"; }\n\n# Validate files\nif [ ! -f \"$INPUT_FILE\" ]; then echo \"ERR: main input missing: $INPUT_FILE\" >&2; exit 1; fi\nif [ ! -f \"$OVERLAY_FILE\" ]; then echo \"ERR: overlay primary missing: $OVERLAY_FILE\" >&2; exit 1; fi\nif [ -n \"$OVERLAY_2\" ] && [ ! -f \"$OVERLAY_2\" ]; then echo \"ERR: overlay secondary missing: $OVERLAY_2\" >&2; exit 1; fi\n\n# If an outro path was supplied but file missing — warn and treat as empty\nif [ -n \"$OUTRO_FILE\" ] && [ ! -f \"$OUTRO_FILE\" ]; then\n  echo \"WARN: outro path provided but file not found: $OUTRO_FILE — skipping outro.\" >&2\n  OUTRO_FILE=\"\"\nfi\n\nif [ -n \"$RANDOM_INSERT_FILE\" ] && [ ! -f \"$RANDOM_INSERT_FILE\" ]; then\n  echo \"ERR: random insert file missing: $RANDOM_INSERT_FILE\" >&2; exit 1;\nfi\n\n# If outro is empty or invalid, explicitly clear it and skip outro processing\nif [ -z \"${OUTRO_FILE:-}\" ]; then\n  OUTRO_FILE=\"\"\n  OUTRO_INDEX=\"\"\n  echo \"No valid outro — outro processing disabled.\" >&2\nfi\n\n# Probe overlay durations\nOV1_DUR=$(probe_duration \"$OVERLAY_FILE\"); OV1_DUR=${OV1_DUR:-0}; OV1_DUR=$(awk -v v=\"$OV1_DUR\" 'BEGIN{printf(\"%.3f\", v+0)}')\necho \"Overlay1 duration: $OV1_DUR\" >&2\nif [ -n \"$OVERLAY_2\" ]; then\n  OV2_DUR=$(probe_duration \"$OVERLAY_2\"); OV2_DUR=${OV2_DUR:-0}; OV2_DUR=$(awk -v v=\"$OV2_DUR\" 'BEGIN{printf(\"%.3f\", v+0)}')\n  echo \"Overlay2 duration: $OV2_DUR\" >&2\nfi\n\n# Determine overlay resolution and FPS (we'll still force TARGET_FPS)\nIN_RES=$(probe_resolution \"$OVERLAY_FILE\" || true)\nif [ -n \"$IN_RES\" ]; then\n  O_W=$(printf \"%s\" \"$IN_RES\" | awk -Fx '{print $1}')\n  O_H=$(printf \"%s\" \"$IN_RES\" | awk -Fx '{print $2}')\nelse\n  O_W=720; O_H=1280\nfi\nFPS_RAW=$(probe_framerate \"$OVERLAY_FILE\" || true)\necho \"Overlay native resolution: ${O_W}x${O_H} native-fps:${FPS_RAW} -> using TARGET_FPS=${TARGET_FPS}\" >&2\n\n# Merge overlays if needed\nif [ -z \"$OVERLAY_2\" ]; then\n  echo \"No overlay2 provided — using overlay primary as-is.\" >&2\n  MERGED_OVERLAY=\"$OVERLAY_FILE\"\nelse\n  if [ -n \"$OVERLAY_2_LENGTH_SECONDS\" ]; then\n    OVERLAY_2_LENGTH_SECONDS=$(awk -v v=\"$OVERLAY_2_LENGTH_SECONDS\" 'BEGIN{printf(\"%.3f\", v+0)}')\n    FIRST_END_SEC=$(awk -v d=\"$OV1_DUR\" -v s=\"$OVERLAY_2_LENGTH_SECONDS\" 'BEGIN{printf(\"%.3f\", d - s)}')\n  else\n    FIRST_END_SEC=$(awk -v d=\"$OV1_DUR\" 'BEGIN{printf(\"%.3f\", d*0.70)}')\n  fi\n\n  TRANS=$(awk -v v=\"$OVERLAY_TRANSITION_DURATION\" 'BEGIN{printf(\"%.3f\", v+0)}')\n  OFFSET=$(awk -v f=\"$FIRST_END_SEC\" -v t=\"$TRANS\" 'BEGIN{printf(\"%.3f\", f - t)}')\n\n  ffmpeg -y -hide_banner -loglevel error \\\n    -i \"$OVERLAY_FILE\" -i \"$OVERLAY_2\" \\\n    -filter_complex \"\\\n[0:v]trim=start=0:end=${FIRST_END_SEC},setpts=PTS-STARTPTS,scale=${O_W}:${O_H},fps=${TARGET_FPS},setsar=1,format=yuv420p[v0]; \\\n[1:v]trim=start=${OVERLAY_2_START_SEC},setpts=PTS-STARTPTS,scale=${O_W}:${O_H},fps=${TARGET_FPS},setsar=1,format=yuv420p[v1]; \\\n[v0][v1]xfade=transition=fade:duration=${TRANS}:offset=${OFFSET}[vxf]\" \\\n    -map \"[vxf]\" -c:v libx264 -crf 18 -preset veryfast -an -movflags +faststart \\\n    \"$MERGED_OVERLAY_TMP\"\n\n  MERGED_OVERLAY=\"$MERGED_OVERLAY_TMP\"\nfi\n\n# Generate caption if enabled\nif [ \"$CAPTION_ENABLE\" = \"true\" ]; then\n  rm -f \"${CAPTION_PNG}\" || true\n  export CAPTION_PNG CAPTION_TEXT CAPTION_FONT_PATH CAPTION_FONT_SIZE CAPTION_FONT_COLOR CAPTION_POS_X_PERCENT CAPTION_POS_Y_PERCENT TEXT_BG_ENABLE TEXT_BG_COLOR TEXT_BG_OPACITY TEXT_BG_PADDING\n  python3 - <<'PY' 1>&2\nimport os\nfrom PIL import Image, ImageDraw, ImageFont\n\nout_path = os.environ[\"CAPTION_PNG\"]\ntext = os.environ.get(\"CAPTION_TEXT\", \"\")\nfont_path = os.environ.get(\"CAPTION_FONT_PATH\", \"/usr/share/fonts/truetype/dejavu/DejaVuSans-Bold.ttf\")\ntry:\n    font_size = int(os.environ.get(\"CAPTION_FONT_SIZE\", \"64\"))\nexcept Exception:\n    font_size = 64\nfont_color = os.environ.get(\"CAPTION_FONT_COLOR\", \"white\")\ntry:\n    pos_x_pct = int(os.environ.get(\"CAPTION_POS_X_PERCENT\", \"50\"))\nexcept Exception:\n    pos_x_pct = 50\ntry:\n    pos_y_pct = int(os.environ.get(\"CAPTION_POS_Y_PERCENT\", \"50\"))\nexcept Exception:\n    pos_y_pct = 50\nbg_enable = os.environ.get(\"TEXT_BG_ENABLE\", \"true\").lower() == 'true'\ntry:\n    bg_opacity = int(os.environ.get(\"TEXT_BG_OPACITY\", \"150\"))\nexcept Exception:\n    bg_opacity = 150\ntry:\n    bg_padding = int(os.environ.get(\"TEXT_BG_PADDING\", \"20\"))\nexcept Exception:\n    bg_padding = 20\n\ncanvas_w, canvas_h = 1080, 1920\ncanvas = Image.new(\"RGBA\", (canvas_w, canvas_h), (0, 0, 0, 0))\ndraw = ImageDraw.Draw(canvas)\nfont = None\ntry:\n    font = ImageFont.truetype(font_path, font_size)\nexcept Exception:\n    candidates = [\n        \"/usr/share/fonts/truetype/dejavu/DejaVuSans-Bold.ttf\",\n        \"/usr/share/fonts/truetype/liberation/LiberationSans-Bold.ttf\"\n    ]\n    for p in candidates:\n        if os.path.isfile(p):\n            try:\n                font = ImageFont.truetype(p, font_size)\n                break\n            except Exception:\n                pass\nif font is None:\n    font = ImageFont.load_default()\n\ntext = text or \" \"\nlines = text.splitlines() if \"\\n\" in text else [text]\nline_heights = []\nmax_w = 0\ntemp_draw = ImageDraw.Draw(canvas)\nfor ln in lines:\n    bbox = temp_draw.textbbox((0,0), ln, font=font)\n    w = bbox[2] - bbox[0]\n    h = bbox[3] - bbox[1]\n    line_heights.append(h)\n    if w > max_w:\n        max_w = w\ntotal_h = sum(line_heights) + (len(lines)-1) * int(font_size * 0.2)\n\nx = (canvas_w * pos_x_pct / 100.0) - (max_w / 2.0)\ny = (canvas_h * pos_y_pct / 100.0) - (total_h / 2.0)\n\nif bg_enable:\n    bg_layer = Image.new(\"RGBA\", (canvas_w, canvas_h), (0,0,0,0))\n    bg_draw = ImageDraw.Draw(bg_layer)\n    left = int(x - bg_padding); top = int(y - bg_padding)\n    right = int(x + max_w + bg_padding); bottom = int(y + total_h + bg_padding)\n    bg_draw.rectangle([left, top, right, bottom], fill=(0,0,0,bg_opacity))\n    canvas = Image.alpha_composite(canvas, bg_layer)\n\ndraw = ImageDraw.Draw(canvas)\ncur_y = y\nfor idx, ln in enumerate(lines):\n    draw.text((x, cur_y), ln, font=font, fill=font_color)\n    cur_y += line_heights[idx] + int(font_size * 0.2)\n\nos.makedirs(os.path.dirname(out_path), exist_ok=True)\ncanvas.save(out_path)\nPY\n  if [ ! -f \"$CAPTION_PNG\" ]; then echo \"ERR: caption generation failed.\" >&2; exit 1; fi\nfi\n\n# Probe main duration\nMAIN_VID_DURATION=$(probe_duration \"$INPUT_FILE\" || printf \"\")\nMAIN_VID_DURATION=${MAIN_VID_DURATION:-10}\nMAIN_VID_DURATION=$(awk -v v=\"$MAIN_VID_DURATION\" 'BEGIN{ if(v==0) v=10; printf(\"%.3f\", v+0)}')\necho \"Main video duration (original): $MAIN_VID_DURATION\" >&2\n\n# Calculate proper INPUT_READ_DURATION based on SPEED_FACTOR\nSPEED_FACTOR_N=$(awk -v s=\"$SPEED_FACTOR\" 'BEGIN{ if(s<=0) s=1.0; printf(\"%.6f\", s+0) }')\n\n# Apply trim with speed factor consideration\nINPUT_READ_DURATION=\"\"\nif [ -n \"$TRIM_DURATION\" ]; then\n    # For output X seconds at speed S, we need X*S seconds input\n    INPUT_READ_DURATION=$(awk -v t=\"$TRIM_DURATION\" -v s=\"$SPEED_FACTOR_N\" 'BEGIN{ printf(\"%.3f\", t*s) }')\n    # Ensure we don't exceed main duration\n    if [ \"$(awk -v i=\"$INPUT_READ_DURATION\" -v m=\"$MAIN_VID_DURATION\" 'BEGIN{ if(i>m) print 1; else print 0 }')\" = \"1\" ]; then\n        echo \"WARNING: Requested duration exceeds available. Adjusting...\" >&2\n        INPUT_READ_DURATION=\"$MAIN_VID_DURATION\"\n        EFFECTIVE_DURATION=$(awk -v i=\"$INPUT_READ_DURATION\" -v s=\"$SPEED_FACTOR_N\" 'BEGIN{ printf(\"%.3f\", i/s) }')\n    else\n        EFFECTIVE_DURATION=\"$TRIM_DURATION\"\n    fi\nelse\n    INPUT_READ_DURATION=\"$MAIN_VID_DURATION\"\n    EFFECTIVE_DURATION=$(awk -v m=\"$MAIN_VID_DURATION\" -v s=\"$SPEED_FACTOR_N\" 'BEGIN{ printf(\"%.3f\", m/s) }')\nfi\n\necho \"SPEED_FACTOR: $SPEED_FACTOR_N\" >&2\necho \"INPUT_READ_DURATION: $INPUT_READ_DURATION (amount to read from files)\" >&2\necho \"EFFECTIVE_DURATION: $EFFECTIVE_DURATION (output duration after speed change)\" >&2\n\n# Rotation and crop filters\nROTATE_TAG=$(ffprobe -v error -select_streams v:0 -show_entries stream_tags=rotate -of default=nw=1:nk=1 \"$INPUT_FILE\" 2>/dev/null || printf \"0\")\nROTATION_FILTER=\"\"\ncase \"$ROTATE_TAG\" in\n  90) ROTATION_FILTER=\"transpose=1,\" ;;\n  270) ROTATION_FILTER=\"transpose=2,\" ;;\nesac\n\n# Build crop filter based on new settings\nCROP_FILTER=\"\"\nif [ \"$CROP_ENABLE\" = \"true\" ]; then\n  # Validate and apply defaults for crop percentages\n  CROP_TOP_PCT=0\n  CROP_BOTTOM_PCT=0\n  \n  if [ \"$CROP_TOP_ENABLE\" = \"true\" ]; then\n    # Check if CROP_TOP_PERCENT is set and valid, otherwise use default\n    if [ -z \"${CROP_TOP_PERCENT:-}\" ]; then\n      CROP_TOP_PCT=$DEFAULT_CROP_TOP_PERCENT\n      echo \"CROP_TOP_PERCENT not set, using default: ${DEFAULT_CROP_TOP_PERCENT}%\" >&2\n    else\n      # Validate it's a number\n      case \"$CROP_TOP_PERCENT\" in\n        ''|*[!0-9]*)\n          CROP_TOP_PCT=$DEFAULT_CROP_TOP_PERCENT\n          echo \"CROP_TOP_PERCENT invalid, using default: ${DEFAULT_CROP_TOP_PERCENT}%\" >&2\n          ;;\n        *)\n          CROP_TOP_PCT=$CROP_TOP_PERCENT\n          ;;\n      esac\n    fi\n  fi\n  \n  if [ \"$CROP_BOTTOM_ENABLE\" = \"true\" ]; then\n    # Check if CROP_BOTTOM_PERCENT is set and valid, otherwise use default\n    if [ -z \"${CROP_BOTTOM_PERCENT:-}\" ]; then\n      CROP_BOTTOM_PCT=$DEFAULT_CROP_BOTTOM_PERCENT\n      echo \"CROP_BOTTOM_PERCENT not set, using default: ${DEFAULT_CROP_BOTTOM_PERCENT}%\" >&2\n    else\n      # Validate it's a number\n      case \"$CROP_BOTTOM_PERCENT\" in\n        ''|*[!0-9]*)\n          CROP_BOTTOM_PCT=$DEFAULT_CROP_BOTTOM_PERCENT\n          echo \"CROP_BOTTOM_PERCENT invalid, using default: ${DEFAULT_CROP_BOTTOM_PERCENT}%\" >&2\n          ;;\n        *)\n          CROP_BOTTOM_PCT=$CROP_BOTTOM_PERCENT\n          ;;\n      esac\n    fi\n  fi\n  \n  # Total percentage to keep\n  TOTAL_CROP_PCT=$((CROP_TOP_PCT + CROP_BOTTOM_PCT))\n  \n  if [ \"$TOTAL_CROP_PCT\" -gt 0 ] && [ \"$TOTAL_CROP_PCT\" -lt 100 ]; then\n    KEEP_PCT=$((100 - TOTAL_CROP_PCT))\n    \n    echo \"Crop settings: Top=${CROP_TOP_PCT}%, Bottom=${CROP_BOTTOM_PCT}%, Keeping=${KEEP_PCT}%\" >&2\n    \n    # FFmpeg crop filter: crop=width:height:x:y\n    # For cropping top and/or bottom:\n    # - width: keep full width (in_w)\n    # - height: in_h * (keep_percentage / 100)\n    # - x: 0 (no horizontal crop)\n    # - y: in_h * (top_crop_percentage / 100)\n    CROP_FILTER=\"crop=in_w:in_h*${KEEP_PCT}/100:0:in_h*${CROP_TOP_PCT}/100,\"\n  elif [ \"$TOTAL_CROP_PCT\" -ge 100 ]; then\n    echo \"WARNING: Total crop percentage >= 100%, disabling crop\" >&2\n    CROP_FILTER=\"\"\n  fi\nfi\n\n# Mirror filter\nMIRROR_FILTER=\"\"\nif [ \"$MIRROR_ENABLE\" = \"true\" ]; then\n  MIRROR_FILTER=\"hflip,\"\nfi\n\n# Calculate input indices (after validating existence of optional files)\nINPUT_INDEX=0\nOVERLAY_INDEX=1\nCAPTION_INDEX=\"\"\nRANDOM_INSERT_INDEX=\"\"\nOUTRO_INDEX=\"\"\n\nif [ \"$CAPTION_ENABLE\" = \"true\" ]; then\n  CAPTION_INDEX=2\n  NEXT_INDEX=3\nelse\n  NEXT_INDEX=2\nfi\n\nif [ -n \"$RANDOM_INSERT_FILE\" ]; then\n  RANDOM_INSERT_INDEX=$NEXT_INDEX\n  NEXT_INDEX=$((NEXT_INDEX + 1))\nfi\n\nif [ -n \"$OUTRO_FILE\" ]; then\n  OUTRO_INDEX=$NEXT_INDEX\nfi\n\n# Build main composition base (use INPUT_READ_DURATION for trims, EFFECTIVE_DURATION for canvas)\nif [ \"$CAPTION_ENABLE\" = \"true\" ]; then\n  BASE_FILTER=\"color=c=black:s=1080x1920:d=${EFFECTIVE_DURATION}[canvas]; \\\n[${OVERLAY_INDEX}:v]trim=duration=${INPUT_READ_DURATION},setpts=PTS-STARTPTS,scale=1080:-1,crop=1080:ih[top_video]; \\\n[${INPUT_INDEX}:v]trim=duration=${INPUT_READ_DURATION},setpts=PTS-STARTPTS,${ROTATION_FILTER}${CROP_FILTER}scale=1080:-1,${MIRROR_FILTER}format=yuv420p[bottom_video]; \\\n[canvas][top_video]overlay=0:0[bg_with_top]; \\\n[bg_with_top][bottom_video]overlay=(W-w)/2:H-h[layout_complete]; \\\n[layout_complete][${CAPTION_INDEX}:v]overlay=0:0,setsar=1,format=yuv420p,fps=${TARGET_FPS},setpts=PTS/${SPEED_FACTOR_N}[composed_main]\"\nelse\n  BASE_FILTER=\"color=c=black:s=1080x1920:d=${EFFECTIVE_DURATION}[canvas]; \\\n[${OVERLAY_INDEX}:v]trim=duration=${INPUT_READ_DURATION},setpts=PTS-STARTPTS,scale=1080:-1,crop=1080:ih[top_video]; \\\n[${INPUT_INDEX}:v]trim=duration=${INPUT_READ_DURATION},setpts=PTS-STARTPTS,${ROTATION_FILTER}${CROP_FILTER}scale=1080:-1,${MIRROR_FILTER}format=yuv420p[bottom_video]; \\\n[canvas][top_video]overlay=0:0[bg_with_top]; \\\n[bg_with_top][bottom_video]overlay=(W-w)/2:H-h,setsar=1,format=yuv420p,fps=${TARGET_FPS},setpts=PTS/${SPEED_FACTOR_N}[composed_main]\"\nfi\n\n# Assemble filter complex incrementally\nFILTER_LINES=\"\"\nappend_filter() {\n  if [ -z \"$FILTER_LINES\" ]; then\n    FILTER_LINES=\"$1\"\n  else\n    FILTER_LINES=\"${FILTER_LINES}; ${1}\"\n  fi\n}\n\nappend_filter \"$BASE_FILTER\"\n\n# Build the audio tempo chain for main audio (only if SPEED_FACTOR != 1)\nAUDIO_TEMPO_CHAIN=\"\"\nif [ \"$SPEED_FACTOR_N\" != \"1.000000\" ]; then\n  export SPEED_FACTOR_N\n  AUDIO_TEMPO_CHAIN=$(python3 - <<'PY'\nimport os\ns = float(os.environ.get('SPEED_FACTOR_N','1'))\nif s <= 0:\n    print(\"atempo=1.0\")\nelse:\n    factors = []\n    tmp = s\n    while tmp > 2.0000001:\n        factors.append(2.0)\n        tmp = tmp / 2.0\n    while tmp < 0.5 - 1e-12:\n        factors.append(0.5)\n        tmp = tmp / 0.5\n    factors.append(round(tmp, 6))\n    out = \",\".join(f\"atempo={f:.6f}\" for f in factors)\n    print(out)\nPY\n)\n  echo \"AUDIO_TEMPO_CHAIN: $AUDIO_TEMPO_CHAIN\" >&2\nfi\n\n# ========== RANDOM INSERT (video + audio) ==========\nAUDIO_FILTER=\"\"\nAUDIO_MAP=\"0:a?\" # default\nif [ -n \"$RANDOM_INSERT_FILE\" ]; then\n  INSERT_DURATION=$(probe_duration \"$RANDOM_INSERT_FILE\" || printf \"2\")\n  INSERT_DURATION=$(awk -v v=\"$INSERT_DURATION\" 'BEGIN{ printf(\"%.3f\", v+0)}')\n  echo \"Random insert duration (insert file): $INSERT_DURATION seconds\" >&2\n\n  export EFFECTIVE_DURATION INSERT_DURATION\n  RANDOM_POS=$(python3 - <<'PY'\nimport os, struct\nefd = float(os.environ.get('EFFECTIVE_DURATION','0'))\nidur = float(os.environ.get('INSERT_DURATION','0'))\nminpos = 3.0\nmaxpos = efd - idur - 1.0\nif maxpos < minpos:\n    maxpos = minpos\nr = struct.unpack(\">I\", os.urandom(4))[0] / 4294967295.0\nv = minpos + r * (maxpos - minpos)\nprint(f\"{v:.3f}\")\nPY\n)\n  echo \"Random insert at: ${RANDOM_POS}s\" >&2\n\n  BEFORE_INSERT=$(awk -v p=\"$RANDOM_POS\" 'BEGIN{ printf(\"%.3f\", p) }')\n  NEW_DURATION=$(awk -v e=\"$EFFECTIVE_DURATION\" -v i=\"$INSERT_DURATION\" 'BEGIN{ printf(\"%.3f\", e+i) }')\n\n  VIDEO_INSERT_BLOCK=\"[composed_main]fps=${TARGET_FPS},split=2[main1][main2]; \\\n[main1]trim=start=0:end=${BEFORE_INSERT},setpts=PTS-STARTPTS[seg1]; \\\n[main2]trim=start=${BEFORE_INSERT},setpts=PTS-STARTPTS[seg3]; \\\n[${RANDOM_INSERT_INDEX}:v]scale=1080:1920:force_original_aspect_ratio=decrease,pad=1080:1920:(ow-iw)/2:(oh-ih)/2,setsar=1,fps=${TARGET_FPS},setpts=PTS-STARTPTS[insert_scaled]; \\\n[seg1][insert_scaled][seg3]concat=n=3:v=1:a=0[concat_v]; \\\n[concat_v]fps=${TARGET_FPS}[final_v]\"\n\n  append_filter \"$VIDEO_INSERT_BLOCK\"\n\n  BEFORE_INSERT_AUDIO=$(awk -v b=\"$BEFORE_INSERT\" -v s=\"$SPEED_FACTOR_N\" 'BEGIN{ printf(\"%.3f\", b*s) }')\n\n  if [ -n \"$AUDIO_TEMPO_CHAIN\" ]; then\n    AUDIO_FILTER=\"[0:a]atrim=start=0:end=${BEFORE_INSERT_AUDIO},asetpts=PTS-STARTPTS,${AUDIO_TEMPO_CHAIN}[a1]; \\\n[0:a]atrim=start=${BEFORE_INSERT_AUDIO},asetpts=PTS-STARTPTS,${AUDIO_TEMPO_CHAIN}[a3]; \\\n[${RANDOM_INSERT_INDEX}:a]asetpts=PTS-STARTPTS[insert_audio]; \\\n[a1][insert_audio][a3]concat=n=3:v=0:a=1[final_audio]\"\n  else\n    AUDIO_FILTER=\"[0:a]atrim=start=0:end=${BEFORE_INSERT_AUDIO},asetpts=PTS-STARTPTS[a1]; \\\n[0:a]atrim=start=${BEFORE_INSERT_AUDIO},asetpts=PTS-STARTPTS[a3]; \\\n[${RANDOM_INSERT_INDEX}:a]asetpts=PTS-STARTPTS[insert_audio]; \\\n[a1][insert_audio][a3]concat=n=3:v=0:a=1[final_audio]\"\n  fi\n\n  if [ -n \"$OUTRO_FILE\" ] && [ -n \"$OUTRO_INDEX\" ]; then\n    AUDIO_FILTER=\"${AUDIO_FILTER}; [${OUTRO_INDEX}:a]asetpts=PTS-STARTPTS[outro_a]; [final_audio][outro_a]concat=n=2:v=0:a=1[final_audio]\"\n  fi\n\n  EFFECTIVE_DURATION=\"$NEW_DURATION\"\n  AUDIO_MAP=\"[final_audio]\"\nfi\n\n# If no random insert, handle main audio +/- outro\nif [ -z \"$RANDOM_INSERT_FILE\" ]; then\n  if [ -n \"$OUTRO_FILE\" ] && [ -n \"$OUTRO_INDEX\" ]; then\n    if [ -n \"$AUDIO_TEMPO_CHAIN\" ]; then\n      AUDIO_FILTER=\"[0:a]atrim=duration=${INPUT_READ_DURATION},asetpts=PTS-STARTPTS,${AUDIO_TEMPO_CHAIN}[main_a]; \\\n[${OUTRO_INDEX}:a]asetpts=PTS-STARTPTS[outro_a]; \\\n[main_a][outro_a]concat=n=2:v=0:a=1[final_audio]\"\n    else\n      AUDIO_FILTER=\"[0:a]atrim=duration=${INPUT_READ_DURATION},asetpts=PTS-STARTPTS[main_a]; \\\n[${OUTRO_INDEX}:a]asetpts=PTS-STARTPTS[outro_a]; \\\n[main_a][outro_a]concat=n=2:v=0:a=1[final_audio]\"\n    fi\n    AUDIO_MAP=\"[final_audio]\"\n  else\n    if [ -n \"$AUDIO_TEMPO_CHAIN\" ]; then\n      AUDIO_FILTER=\"[0:a]atrim=duration=${INPUT_READ_DURATION},asetpts=PTS-STARTPTS,${AUDIO_TEMPO_CHAIN}[final_audio]\"\n      AUDIO_MAP=\"[final_audio]\"\n    else\n      AUDIO_FILTER=\"${AUDIO_FILTER:-}\"\n      AUDIO_MAP=\"${AUDIO_MAP:-0:a?}\"\n    fi\n  fi\nfi\n\n# Handle outro video if provided\nif [ -n \"$OUTRO_FILE\" ] && [ -n \"$OUTRO_INDEX\" ]; then\n  OUTRO_START=$(awk -v d=\"$EFFECTIVE_DURATION\" -v t=\"$OUTRO_TRANSITION_DURATION\" 'BEGIN{ printf(\"%.3f\", d-t) }')\n\n  if [ -n \"$RANDOM_INSERT_FILE\" ]; then\n    OUTRO_VIDEO_BLOCK=\"[${OUTRO_INDEX}:v]scale=1080:1920:force_original_aspect_ratio=decrease,pad=1080:1920:(ow-iw)/2:(oh-ih)/2,setsar=1,setpts=PTS-STARTPTS[outro_scaled]; \\\n[final_v]fps=${TARGET_FPS},setsar=1,setpts=PTS-STARTPTS[main_normalized]; \\\n[main_normalized]fps=${TARGET_FPS}[main_normalized_fps]; \\\n[outro_scaled]fps=${TARGET_FPS}[outro_scaled_fps]; \\\n[main_normalized_fps][outro_scaled_fps]xfade=transition=fade:duration=${OUTRO_TRANSITION_DURATION}:offset=${OUTRO_START}[final_v]\"\n    append_filter \"$OUTRO_VIDEO_BLOCK\"\n    OUTPUT_LABEL=\"[final_v]\"\n  else\n    OUTRO_VIDEO_BLOCK=\"[${OUTRO_INDEX}:v]scale=1080:1920:force_original_aspect_ratio=decrease,pad=1080:1920:(ow-iw)/2:(oh-ih)/2,setsar=1,setpts=PTS-STARTPTS[outro_scaled]; \\\n[composed_main]fps=${TARGET_FPS},setsar=1,setpts=PTS-STARTPTS[main_normalized]; \\\n[main_normalized]fps=${TARGET_FPS}[main_normalized_fps]; \\\n[outro_scaled]fps=${TARGET_FPS}[outro_scaled_fps]; \\\n[main_normalized_fps][outro_scaled_fps]xfade=transition=fade:duration=${OUTRO_TRANSITION_DURATION}:offset=${OUTRO_START}[final_v]\"\n    append_filter \"$OUTRO_VIDEO_BLOCK\"\n    OUTPUT_LABEL=\"[final_v]\"\n  fi\nelse\n  if [ -n \"$RANDOM_INSERT_FILE\" ]; then\n    OUTPUT_LABEL=\"[final_v]\"\n  else\n    append_filter \"[composed_main]fps=${TARGET_FPS}[final_v]\"\n    OUTPUT_LABEL=\"[final_v]\"\n  fi\nfi\n\n# Final brightness application\nif [ \"$(awk -v b=\"$BRIGHTNESS\" 'BEGIN{ if (b==0) print \"0\"; else print \"1\" }')\" = \"1\" ]; then\n  append_filter \"[final_v]eq=brightness=${BRIGHTNESS}[final_v_out]\"\n  FINAL_OUTPUT_LABEL=\"[final_v_out]\"\nelse\n  FINAL_OUTPUT_LABEL=\"${OUTPUT_LABEL}\"\nfi\n\n# Combine audio filters if present\nif [ -n \"$AUDIO_FILTER\" ]; then\n  COMPLETE_FILTER=\"${FILTER_LINES}; ${AUDIO_FILTER}\"\nelse\n  COMPLETE_FILTER=\"${FILTER_LINES}\"\nfi\n\n# Build input args\nINPUT_ARGS=\"\"\nif [ -n \"$TRIM_DURATION\" ]; then\n  INPUT_ARGS=\"-t ${INPUT_READ_DURATION} -i \\\"$INPUT_FILE\\\" -t ${INPUT_READ_DURATION} -i \\\"$MERGED_OVERLAY\\\"\"\nelse\n  INPUT_ARGS=\"-i \\\"$INPUT_FILE\\\" -i \\\"$MERGED_OVERLAY\\\"\"\nfi\n\nif [ \"$CAPTION_ENABLE\" = \"true\" ]; then\n  INPUT_ARGS=\"$INPUT_ARGS -i \\\"$CAPTION_PNG\\\"\"\nfi\n\nif [ -n \"$RANDOM_INSERT_FILE\" ]; then\n  INPUT_ARGS=\"$INPUT_ARGS -i \\\"$RANDOM_INSERT_FILE\\\"\"\nfi\n\nif [ -n \"$OUTRO_FILE\" ]; then\n  INPUT_ARGS=\"$INPUT_ARGS -i \\\"$OUTRO_FILE\\\"\"\nfi\n\n# Build final ffmpeg command\nCMD=\"ffmpeg -hide_banner -y -progress pipe:2 -loglevel warning $INPUT_ARGS -filter_complex \\\"${COMPLETE_FILTER}\\\" -map \\\"${FINAL_OUTPUT_LABEL}\\\"\"\n\nif [ -n \"$AUDIO_FILTER\" ]; then\n  CMD=\"$CMD -map \\\"${AUDIO_MAP}\\\"\"\nelse\n  CMD=\"$CMD -map ${AUDIO_MAP}\"\nfi\n\nCMD=\"$CMD -c:v libx264 -crf 23 -preset veryfast -c:a aac -b:a 192k -r ${TARGET_FPS} -aspect 9:16\"\n\n# Apply final -t using EFFECTIVE_DURATION (if trim requested and no outro)\nif [ -n \"$TRIM_DURATION\" ] && [ -z \"$OUTRO_FILE\" ]; then\n  CMD=\"$CMD -t ${EFFECTIVE_DURATION}\"\nfi\n\nCMD=\"$CMD \\\"$OUT_FILE\\\"\"\n\n# Debug output\necho \"=== DEBUG: filter_complex ===\" >&2\necho \"$COMPLETE_FILTER\" >&2\necho \"=== DEBUG: ffmpeg cmd ===\" >&2\necho \"$CMD\" >&2\n\n# Execute\necho \"Executing final render with audio handling...\" >&2\necho \"Progress will be shown below:\" >&2\n\nif timeout \"$FFMPEG_TIMEOUT\" sh -c \"$CMD\" < /dev/null; then\n  [ \"$CAPTION_ENABLE\" = \"true\" ] && rm -f \"$CAPTION_PNG\" || true\n  [ -n \"$MERGED_OVERLAY_TMP\" ] && [ -f \"$MERGED_OVERLAY_TMP\" ] && rm -f \"$MERGED_OVERLAY_TMP\" || true\n  [ -n \"$COMPOSED_MAIN_TMP\" ] && [ -f \"$COMPOSED_MAIN_TMP\" ] && rm -f \"$COMPOSED_MAIN_TMP\" || true\n  echo \"✅ Success! Output file: $OUT_FILE\" >&2\n  printf '%s\\n' \"$(basename \"$OUT_FILE\")\"\n  exit 0\nelse\n  echo \"❌ ERR: ffmpeg failed or timed out.\" >&2\n  echo \"Check the debug output above for details.\" >&2\n  exit 1\nfi"
      },
      "type": "n8n-nodes-base.executeCommand",
      "typeVersion": 1,
      "position": [
        -448,
        -848
      ],
      "id": "2a750bc2-02a2-4261-9c0c-cff8a23de400",
      "name": "bk1",
      "disabled": true
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict",
            "version": 2
          },
          "conditions": [
            {
              "id": "b50047ef-9137-4f48-96c1-b9a8caaf52a0",
              "leftValue": "={{ $json.body.folder }}",
              "rightValue": "KahaniExpress",
              "operator": {
                "type": "string",
                "operation": "contains"
              }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "type": "n8n-nodes-base.if",
      "typeVersion": 2.2,
      "position": [
        -224,
        -528
      ],
      "id": "57309dcd-4907-4d29-9c1a-825003ffe2ec",
      "name": "If"
    },
    {
      "parameters": {
        "command": "=#!/bin/sh\nset -eu\n\n# Enhanced video composition with audio handling and fixed output path.\n# Final output is always: /files/output/output.mp4\n# Features: SPEED_FACTOR (video+main audio), BRIGHTNESS, TARGET_FPS=30\n# NEW: OVERLAY_AUDIO_ENABLE, OVERLAY_AUDIO_VOLUME (1-100)\n\n# ---------------- CONFIG ----------------\nINPUT_URL=\"{{ $node[\"Webhook\"].json.body.root_dir }}{{$node[\"Webhook\"].json.body.folder}}{{$node[\"Webhook\"].json.body.filename}}\"\nOVERLAY_FILE=\"{{$node[\"Webhook\"].json.body.OVERLAY_FILE}}\"\nOVERLAY_2=\"\"\nOVERLAY_2_LENGTH_SECONDS=\"\"\nOVERLAY_2_START_SEC=\"0\"\nOVERLAY_TRANSITION_DURATION=\"0.6\"\n\nTRIM_DURATION=\"60\" # leave empty for no trim, or number of seconds\nOUTRO_FILE=\"\"\nOUTRO_TRANSITION_DURATION=\"0.5\"\n\n# RANDOM INSERT with AUDIO support (leave empty to disable)\nRANDOM_INSERT_FILE=\"\"\nRANDOM_INSERT_TRANSITION=\"0.2\"\n\n# NEW: Overlay audio settings\nOVERLAY_AUDIO_ENABLE=true        # Enable overlay audio preservation\nOVERLAY_AUDIO_VOLUME=100           # Volume level 1-100 (100 = original, 50 = half)\n\n# Crop settings: enable independent top/bottom cropping\nCROP_ENABLE=true\nCROP_TOP_ENABLE=true\nCROP_TOP_PERCENT=20\nCROP_BOTTOM_ENABLE=true\nCROP_BOTTOM_PERCENT=22\n\n# Default crop values\nDEFAULT_CROP_TOP_PERCENT=40\nDEFAULT_CROP_BOTTOM_PERCENT=0\n\n# Mirror/flip main video horizontally\nMIRROR_ENABLE=false\n\n# Speed factor (applies to composed main video + main audio)\nSPEED_FACTOR=\"0.9\"\n\n# Brightness adjustment for final output (-1.0 .. 1.0)\nBRIGHTNESS=\"0.1\"\n\n# Force Instagram-friendly fps\nTARGET_FPS=30\n\nCAPTION_ENABLE=true\nCAPTION_FONT_PATH=\"/files/fonts/ARIALBD.TTF\"\nCAPTION_POS_X_PERCENT=50\nCAPTION_POS_Y_PERCENT=35\nCAPTION_TEXT=\"{{ $json.picked.hindi }}\"\nCAPTION_FONT_SIZE=45\nCAPTION_FONT_COLOR=\"white\"\nTEXT_BG_ENABLE=true\nTEXT_BG_COLOR=\"black\"\nTEXT_BG_OPACITY=150\nTEXT_BG_PADDING=25\n\n# ---------------- OUTPUT (FIXED) ----------------\nOUT_FILE=\"{{ $node[\"Webhook\"].json.body.root_dir }}{{$node[\"Webhook\"].json.body.folder}}output/{{$node[\"Webhook\"].json.body.filename}}\"\nmkdir -p \"$(dirname \"$OUT_FILE\")\"\n\nOUT_DIR=\"$(dirname \"$OUT_FILE\")\"\nCAPTION_PNG=\"${OUT_DIR}/caption_image.png\"\nMERGED_OVERLAY_TMP=\"${OUT_DIR}/overlay_merged_$(date +%s)_$$.mp4\"\nCOMPOSED_MAIN_TMP=\"${OUT_DIR}/main_composed_$(date +%s)_$$.mp4\"\n\nFFMPEG_TIMEOUT=\"5m\"\n# --------------- end config --------------\n\necho \"=== Start: enhanced video composition with overlay audio support ===\" >&2\n\n# Validate overlay audio volume\nif [ \"$OVERLAY_AUDIO_ENABLE\" = \"true\" ]; then\n  if [ -z \"${OVERLAY_AUDIO_VOLUME:-}\" ] || [ \"$OVERLAY_AUDIO_VOLUME\" -lt 1 ] || [ \"$OVERLAY_AUDIO_VOLUME\" -gt 100 ]; then\n    echo \"WARN: Invalid OVERLAY_AUDIO_VOLUME ($OVERLAY_AUDIO_VOLUME), using 100\" >&2\n    OVERLAY_AUDIO_VOLUME=100\n  fi\n  # Convert 1-100 scale to 0.01-1.0 for FFmpeg volume filter\n  OVERLAY_VOLUME_FLOAT=$(awk -v v=\"$OVERLAY_AUDIO_VOLUME\" 'BEGIN{ printf(\"%.2f\", v/100.0) }')\n  echo \"Overlay audio: ENABLED at ${OVERLAY_AUDIO_VOLUME}% volume (${OVERLAY_VOLUME_FLOAT})\" >&2\nelse\n  echo \"Overlay audio: DISABLED\" >&2\nfi\n\n# Resolve INPUT_FILE from INPUT_URL\nINPUT_FILE=\"$INPUT_URL\"\n\necho \"Main background: $INPUT_FILE\" >&2\necho \"Overlay primary: $OVERLAY_FILE\" >&2\n[ -n \"$OVERLAY_2\" ] && echo \"Overlay secondary: $OVERLAY_2\" >&2\n[ -n \"$OUTRO_FILE\" ] && echo \"Outro file: $OUTRO_FILE\" >&2\n[ -n \"$RANDOM_INSERT_FILE\" ] && echo \"Random insert file: $RANDOM_INSERT_FILE\" >&2\n[ -n \"$TRIM_DURATION\" ] && echo \"Trim duration: $TRIM_DURATION seconds\" >&2\necho \"SPEED_FACTOR: $SPEED_FACTOR, BRIGHTNESS: $BRIGHTNESS, TARGET_FPS: $TARGET_FPS\" >&2\n\n# Helper functions\nprobe_duration() { ffprobe -v error -show_entries format=duration -of default=noprint_wrappers=1:nokey=1 \"$1\" 2>/dev/null || printf \"\"; }\nprobe_resolution() { ffprobe -v error -select_streams v:0 -show_entries stream=width,height -of csv=p=0:s=x \"$1\" 2>/dev/null || printf \"\"; }\nprobe_framerate() { ffprobe -v error -select_streams v:0 -show_entries stream=r_frame_rate -of default=nw=1:nk=1 \"$1\" 2>/dev/null || printf \"\"; }\nhas_audio() { ffprobe -v error -select_streams a:0 -show_entries stream=codec_type -of default=nw=1:nk=1 \"$1\" 2>/dev/null | grep -q \"audio\" && echo \"yes\" || echo \"no\"; }\n\n# Validate files\nif [ ! -f \"$INPUT_FILE\" ]; then echo \"ERR: main input missing: $INPUT_FILE\" >&2; exit 1; fi\nif [ ! -f \"$OVERLAY_FILE\" ]; then echo \"ERR: overlay primary missing: $OVERLAY_FILE\" >&2; exit 1; fi\nif [ -n \"$OVERLAY_2\" ] && [ ! -f \"$OVERLAY_2\" ]; then echo \"ERR: overlay secondary missing: $OVERLAY_2\" >&2; exit 1; fi\n\n# Check if overlay has audio\nOVERLAY_HAS_AUDIO=$(has_audio \"$OVERLAY_FILE\")\nif [ \"$OVERLAY_AUDIO_ENABLE\" = \"true\" ] && [ \"$OVERLAY_HAS_AUDIO\" = \"no\" ]; then\n  echo \"WARN: Overlay audio enabled but overlay file has no audio stream. Disabling overlay audio.\" >&2\n  OVERLAY_AUDIO_ENABLE=false\nfi\n\nif [ -n \"$OUTRO_FILE\" ] && [ ! -f \"$OUTRO_FILE\" ]; then\n  echo \"WARN: outro path provided but file not found: $OUTRO_FILE — skipping outro.\" >&2\n  OUTRO_FILE=\"\"\nfi\n\nif [ -n \"$RANDOM_INSERT_FILE\" ] && [ ! -f \"$RANDOM_INSERT_FILE\" ]; then\n  echo \"ERR: random insert file missing: $RANDOM_INSERT_FILE\" >&2; exit 1;\nfi\n\nif [ -z \"${OUTRO_FILE:-}\" ]; then\n  OUTRO_FILE=\"\"\n  OUTRO_INDEX=\"\"\n  echo \"No valid outro — outro processing disabled.\" >&2\nfi\n\n# Probe overlay durations\nOV1_DUR=$(probe_duration \"$OVERLAY_FILE\"); OV1_DUR=${OV1_DUR:-0}; OV1_DUR=$(awk -v v=\"$OV1_DUR\" 'BEGIN{printf(\"%.3f\", v+0)}')\necho \"Overlay1 duration: $OV1_DUR\" >&2\nif [ -n \"$OVERLAY_2\" ]; then\n  OV2_DUR=$(probe_duration \"$OVERLAY_2\"); OV2_DUR=${OV2_DUR:-0}; OV2_DUR=$(awk -v v=\"$OV2_DUR\" 'BEGIN{printf(\"%.3f\", v+0)}')\n  echo \"Overlay2 duration: $OV2_DUR\" >&2\nfi\n\n# Determine overlay resolution and FPS\nIN_RES=$(probe_resolution \"$OVERLAY_FILE\" || true)\nif [ -n \"$IN_RES\" ]; then\n  O_W=$(printf \"%s\" \"$IN_RES\" | awk -Fx '{print $1}')\n  O_H=$(printf \"%s\" \"$IN_RES\" | awk -Fx '{print $2}')\nelse\n  O_W=720; O_H=1280\nfi\nFPS_RAW=$(probe_framerate \"$OVERLAY_FILE\" || true)\necho \"Overlay native resolution: ${O_W}x${O_H} native-fps:${FPS_RAW} -> using TARGET_FPS=${TARGET_FPS}\" >&2\n\n# Merge overlays if needed (VIDEO + AUDIO)\nif [ -z \"$OVERLAY_2\" ]; then\n  echo \"No overlay2 provided — using overlay primary as-is.\" >&2\n  MERGED_OVERLAY=\"$OVERLAY_FILE\"\nelse\n  if [ -n \"$OVERLAY_2_LENGTH_SECONDS\" ]; then\n    OVERLAY_2_LENGTH_SECONDS=$(awk -v v=\"$OVERLAY_2_LENGTH_SECONDS\" 'BEGIN{printf(\"%.3f\", v+0)}')\n    FIRST_END_SEC=$(awk -v d=\"$OV1_DUR\" -v s=\"$OVERLAY_2_LENGTH_SECONDS\" 'BEGIN{printf(\"%.3f\", d - s)}')\n  else\n    FIRST_END_SEC=$(awk -v d=\"$OV1_DUR\" 'BEGIN{printf(\"%.3f\", d*0.70)}')\n  fi\n\n  TRANS=$(awk -v v=\"$OVERLAY_TRANSITION_DURATION\" 'BEGIN{printf(\"%.3f\", v+0)}')\n  OFFSET=$(awk -v f=\"$FIRST_END_SEC\" -v t=\"$TRANS\" 'BEGIN{printf(\"%.3f\", f - t)}')\n\n  # Merge video AND audio\n  ffmpeg -y -hide_banner -loglevel error \\\n    -i \"$OVERLAY_FILE\" -i \"$OVERLAY_2\" \\\n    -filter_complex \"\\\n[0:v]trim=start=0:end=${FIRST_END_SEC},setpts=PTS-STARTPTS,scale=${O_W}:${O_H},fps=${TARGET_FPS},setsar=1,format=yuv420p[v0]; \\\n[1:v]trim=start=${OVERLAY_2_START_SEC},setpts=PTS-STARTPTS,scale=${O_W}:${O_H},fps=${TARGET_FPS},setsar=1,format=yuv420p[v1]; \\\n[v0][v1]xfade=transition=fade:duration=${TRANS}:offset=${OFFSET}[vxf]; \\\n[0:a]atrim=start=0:end=${FIRST_END_SEC},asetpts=PTS-STARTPTS[a0]; \\\n[1:a]atrim=start=${OVERLAY_2_START_SEC},asetpts=PTS-STARTPTS[a1]; \\\n[a0][a1]acrossfade=d=${TRANS}:o=${OFFSET}[axf]\" \\\n    -map \"[vxf]\" -map \"[axf]\" -c:v libx264 -crf 18 -preset veryfast -c:a aac -b:a 192k -movflags +faststart \\\n    \"$MERGED_OVERLAY_TMP\"\n\n  MERGED_OVERLAY=\"$MERGED_OVERLAY_TMP\"\nfi\n\n# Generate caption if enabled\nif [ \"$CAPTION_ENABLE\" = \"true\" ]; then\n  rm -f \"${CAPTION_PNG}\" || true\n  export CAPTION_PNG CAPTION_TEXT CAPTION_FONT_PATH CAPTION_FONT_SIZE CAPTION_FONT_COLOR CAPTION_POS_X_PERCENT CAPTION_POS_Y_PERCENT TEXT_BG_ENABLE TEXT_BG_COLOR TEXT_BG_OPACITY TEXT_BG_PADDING\n  python3 - <<'PY' 1>&2\nimport os\nimport re\nimport sys\nfrom PIL import Image, ImageDraw, ImageFont\nimport urllib.request\nimport io\n\n# Emoji rendering using Twemoji PNG images\ndef get_emoji_image(emoji_char, size):\n    \"\"\"Download and return emoji image from Twemoji CDN\"\"\"\n    try:\n        # Get Unicode codepoint(s) for the emoji\n        codepoints = '-'.join(f'{ord(c):x}' for c in emoji_char)\n        # Twemoji CDN URL (72x72 PNG)\n        url = f'https://cdn.jsdelivr.net/gh/twitter/twemoji@14.0.2/assets/72x72/{codepoints}.png'\n\n        with urllib.request.urlopen(url, timeout=3) as response:\n            img_data = response.read()\n            emoji_img = Image.open(io.BytesIO(img_data))\n            # Resize to match font size\n            emoji_img = emoji_img.resize((size, size), Image.Resampling.LANCZOS)\n            return emoji_img\n    except Exception as e:\n        print(f\"Could not fetch emoji {emoji_char} ({codepoints}): {e}\", file=sys.stderr, flush=True)\n        return None\n\nout_path = os.environ[\"CAPTION_PNG\"]\ntext = os.environ.get(\"CAPTION_TEXT\", \"\")\nfont_path = os.environ.get(\"CAPTION_FONT_PATH\", \"/usr/share/fonts/truetype/dejavu/DejaVuSans-Bold.ttf\")\ntry:\n    font_size = int(os.environ.get(\"CAPTION_FONT_SIZE\", \"64\"))\nexcept Exception:\n    font_size = 64\nfont_color = os.environ.get(\"CAPTION_FONT_COLOR\", \"white\")\ntry:\n    pos_x_pct = int(os.environ.get(\"CAPTION_POS_X_PERCENT\", \"50\"))\nexcept Exception:\n    pos_x_pct = 50\ntry:\n    pos_y_pct = int(os.environ.get(\"CAPTION_POS_Y_PERCENT\", \"50\"))\nexcept Exception:\n    pos_y_pct = 50\nbg_enable = os.environ.get(\"TEXT_BG_ENABLE\", \"true\").lower() == 'true'\ntry:\n    bg_opacity = int(os.environ.get(\"TEXT_BG_OPACITY\", \"150\"))\nexcept Exception:\n    bg_opacity = 150\ntry:\n    bg_padding = int(os.environ.get(\"TEXT_BG_PADDING\", \"20\"))\nexcept Exception:\n    bg_padding = 20\n\ncanvas_w, canvas_h = 1080, 1920\n\n# Font loading with multi-script support\ndef load_font(path, size):\n    \"\"\"Try to load a font, return None if failed\"\"\"\n    try:\n        font = ImageFont.truetype(path, size)\n        # Test if font can actually render (some emoji fonts need SVG support)\n        test_draw = ImageDraw.Draw(Image.new(\"RGBA\", (10, 10)))\n        try:\n            test_draw.textbbox((0, 0), \"A\", font=font)\n            return font\n        except (OSError, RuntimeError):\n            # Font loaded but can't render (likely SVG-based emoji font)\n            print(f\"WARNING: {path} requires SVG support, skipping\", flush=True)\n            return None\n    except Exception:\n        return None\n\n# Define font candidates for different scripts\nhindi_font_paths = [\n    \"/usr/share/fonts/truetype/noto/NotoSansDevanagari-Bold.ttf\",\n    \"/usr/share/fonts/truetype/noto/NotoSansDevanagari.ttf\",\n    \"/System/Library/Fonts/Devanagari Sangam MN.ttc\",\n    \"/usr/share/fonts/truetype/lohit-devanagari/Lohit-Devanagari.ttf\",\n    \"/usr/share/fonts/truetype/fonts-noto-devanagari/NotoSansDevanagari-Bold.ttf\"\n]\n\nlatin_font_paths = [\n    font_path,  # User-specified font\n    \"/usr/share/fonts/truetype/dejavu/DejaVuSans-Bold.ttf\",\n    \"/usr/share/fonts/truetype/liberation/LiberationSans-Bold.ttf\",\n    \"/System/Library/Fonts/Supplemental/Arial Bold.ttf\"\n]\n\n# Load fonts\nlatin_font = None\nfor p in latin_font_paths:\n    if os.path.isfile(p):\n        latin_font = load_font(p, font_size)\n        if latin_font:\n            break\n\nhindi_font = None\nfor p in hindi_font_paths:\n    if os.path.isfile(p):\n        hindi_font = load_font(p, font_size)\n        if hindi_font:\n            print(f\"Loaded Hindi font: {p}\", flush=True)\n            break\n\nprint(\"Emojis will be rendered using Twemoji images from CDN\", flush=True)\n\n# Fallback to default if no fonts loaded\nif latin_font is None:\n    latin_font = ImageFont.load_default()\n\n# Use Hindi font as fallback if available, otherwise use latin\nprimary_font = hindi_font if hindi_font else latin_font\n\ntext = text or \" \"\nlines = text.splitlines() if \"\\n\" in text else [text]\n\n# Detect script type for each character\ndef get_char_type(char):\n    \"\"\"Detect if character is Hindi (Devanagari), emoji, or latin\"\"\"\n    code = ord(char)\n    # Devanagari Unicode range: 0x0900-0x097F\n    if 0x0900 <= code <= 0x097F:\n        return 'hindi'\n    # Emoji ranges (expanded for better coverage)\n    elif (0x1F300 <= code <= 0x1FAFF or  # Misc symbols, pictographs, and extended\n          0x2600 <= code <= 0x26FF or    # Misc symbols\n          0x2700 <= code <= 0x27BF or    # Dingbats\n          0xFE00 <= code <= 0xFE0F or    # Variation selectors\n          0x1F000 <= code <= 0x1F0FF or  # Mahjong tiles\n          0x1F100 <= code <= 0x1F1FF or  # Enclosed alphanumeric supplement\n          0x1F200 <= code <= 0x1F2FF or  # Enclosed ideographic supplement\n          0x2300 <= code <= 0x23FF or    # Miscellaneous Technical\n          0x25A0 <= code <= 0x25FF or    # Geometric Shapes\n          0x2B00 <= code <= 0x2BFF or    # Miscellaneous Symbols and Arrows\n          0x1F900 <= code <= 0x1F9FF):   # Supplemental Symbols and Pictographs\n        return 'emoji'\n    else:\n        return 'latin'\n\n# Render text with proper font switching\ndef render_multiline_text(canvas, lines, start_y, font_color):\n    \"\"\"Render text with automatic font switching for Hindi and emoji\"\"\"\n    draw = ImageDraw.Draw(canvas)\n    cur_y = start_y\n    line_spacing = int(font_size * 0.3)\n\n    for line in lines:\n        # Calculate line width for centering\n        line_width = 0\n        segments = []\n        current_segment = \"\"\n        current_type = None\n\n        # Split line into segments by script type\n        for char in line:\n            char_type = get_char_type(char)\n            if char_type != current_type:\n                if current_segment:\n                    segments.append((current_segment, current_type))\n                current_segment = char\n                current_type = char_type\n            else:\n                current_segment += char\n\n        if current_segment:\n            segments.append((current_segment, current_type))\n\n        # Calculate total line width\n        for segment, seg_type in segments:\n            if seg_type == 'hindi' and hindi_font:\n                bbox = draw.textbbox((0, 0), segment, font=hindi_font)\n                line_width += bbox[2] - bbox[0]\n            elif seg_type == 'emoji':\n                # Emojis will be rendered as images - use font_size as width\n                line_width += int(font_size * 1.2) * len(segment)\n            else:\n                bbox = draw.textbbox((0, 0), segment, font=latin_font)\n                line_width += bbox[2] - bbox[0]\n\n        # Calculate starting x position (centered)\n        x = (canvas_w * pos_x_pct / 100.0) - (line_width / 2.0)\n\n        # Draw each segment with appropriate font\n        for segment, seg_type in segments:\n            if seg_type == 'hindi' and hindi_font:\n                draw.text((x, cur_y), segment, font=hindi_font, fill=font_color)\n                bbox = draw.textbbox((x, cur_y), segment, font=hindi_font)\n                x += bbox[2] - bbox[0]\n            elif seg_type == 'emoji':\n                # Render emojis as downloaded images\n                for emoji_char in segment:\n                    emoji_img = get_emoji_image(emoji_char, int(font_size * 1.2))\n                    if emoji_img:\n                        # Paste emoji image with transparency\n                        y_offset = int(cur_y - font_size * 0.1)  # Slight vertical adjustment\n                        canvas.paste(emoji_img, (int(x), y_offset), emoji_img if emoji_img.mode == 'RGBA' else None)\n                        x += int(font_size * 1.2)\n                    else:\n                        # Fallback: skip emoji with space\n                        x += int(font_size * 0.6)\n            else:\n                draw.text((x, cur_y), segment, font=latin_font, fill=font_color)\n                bbox = draw.textbbox((x, cur_y), segment, font=latin_font)\n                x += bbox[2] - bbox[0]\n\n        cur_y += font_size + line_spacing\n\n    return cur_y\n\n# Calculate bounding boxes for background\ncanvas = Image.new(\"RGBA\", (canvas_w, canvas_h), (0, 0, 0, 0))\ntemp_draw = ImageDraw.Draw(canvas)\nline_spacing = int(font_size * 0.3)\n\nline_bboxes = []\nmax_w = 0\n\nfor line in lines:\n    # Calculate width using multi-font approach\n    line_width = 0\n    for char in line:\n        char_type = get_char_type(char)\n        if char_type == 'hindi' and hindi_font:\n            bbox = temp_draw.textbbox((0, 0), char, font=hindi_font)\n            line_width += bbox[2] - bbox[0]\n        elif char_type == 'emoji':\n            # Emojis rendered as images\n            line_width += int(font_size * 1.2)\n        else:\n            bbox = temp_draw.textbbox((0, 0), char, font=latin_font)\n            line_width += bbox[2] - bbox[0]\n\n    line_bboxes.append((line, line_width, font_size))\n    if line_width > max_w:\n        max_w = line_width\n\ntotal_h = sum(h for _, _, h in line_bboxes) + (len(lines) - 1) * line_spacing\n\ny = (canvas_h * pos_y_pct / 100.0) - (total_h / 2.0)\n\n# Draw rounded backgrounds\nif bg_enable:\n    bg_layer = Image.new(\"RGBA\", (canvas_w, canvas_h), (0, 0, 0, 0))\n    bg_draw = ImageDraw.Draw(bg_layer)\n\n    cur_y = y\n    for ln, w, h in line_bboxes:\n        line_x = (canvas_w * pos_x_pct / 100.0) - (w / 2.0)\n        left = int(line_x - bg_padding)\n        top = int(cur_y - bg_padding)\n        right = int(line_x + w + bg_padding)\n        bottom = int(cur_y + h + bg_padding)\n\n        radius = min(int(h * 0.5), bg_padding)\n        bg_draw.rounded_rectangle([left, top, right, bottom], radius=radius, fill=(0, 0, 0, bg_opacity))\n        cur_y += h + line_spacing\n\n    canvas = Image.alpha_composite(canvas, bg_layer)\n\n# Draw text with multi-font support and Twemoji image rendering\nrender_multiline_text(canvas, lines, y, font_color)\n\nos.makedirs(os.path.dirname(out_path), exist_ok=True)\ncanvas.save(out_path)\nprint(f\"Caption saved: {out_path}\", flush=True)\nPY\n  if [ ! -f \"$CAPTION_PNG\" ]; then echo \"ERR: caption generation failed.\" >&2; exit 1; fi\nfi\n\n# Probe main duration\nMAIN_VID_DURATION=$(probe_duration \"$INPUT_FILE\" || printf \"\")\nMAIN_VID_DURATION=${MAIN_VID_DURATION:-10}\nMAIN_VID_DURATION=$(awk -v v=\"$MAIN_VID_DURATION\" 'BEGIN{ if(v==0) v=10; printf(\"%.3f\", v+0)}')\necho \"Main video duration (original): $MAIN_VID_DURATION\" >&2\n\n# Calculate proper INPUT_READ_DURATION based on SPEED_FACTOR\nSPEED_FACTOR_N=$(awk -v s=\"$SPEED_FACTOR\" 'BEGIN{ if(s<=0) s=1.0; printf(\"%.6f\", s+0) }')\n\n# Apply trim with speed factor consideration\nINPUT_READ_DURATION=\"\"\nif [ -n \"$TRIM_DURATION\" ]; then\n    INPUT_READ_DURATION=$(awk -v t=\"$TRIM_DURATION\" -v s=\"$SPEED_FACTOR_N\" 'BEGIN{ printf(\"%.3f\", t*s) }')\n    if [ \"$(awk -v i=\"$INPUT_READ_DURATION\" -v m=\"$MAIN_VID_DURATION\" 'BEGIN{ if(i>m) print 1; else print 0 }')\" = \"1\" ]; then\n        echo \"WARNING: Requested duration exceeds available. Adjusting...\" >&2\n        INPUT_READ_DURATION=\"$MAIN_VID_DURATION\"\n        EFFECTIVE_DURATION=$(awk -v i=\"$INPUT_READ_DURATION\" -v s=\"$SPEED_FACTOR_N\" 'BEGIN{ printf(\"%.3f\", i/s) }')\n    else\n        EFFECTIVE_DURATION=\"$TRIM_DURATION\"\n    fi\nelse\n    INPUT_READ_DURATION=\"$MAIN_VID_DURATION\"\n    EFFECTIVE_DURATION=$(awk -v m=\"$MAIN_VID_DURATION\" -v s=\"$SPEED_FACTOR_N\" 'BEGIN{ printf(\"%.3f\", m/s) }')\nfi\n\necho \"SPEED_FACTOR: $SPEED_FACTOR_N\" >&2\necho \"INPUT_READ_DURATION: $INPUT_READ_DURATION (amount to read from files)\" >&2\necho \"EFFECTIVE_DURATION: $EFFECTIVE_DURATION (output duration after speed change)\" >&2\n\n# Rotation and crop filters\nROTATE_TAG=$(ffprobe -v error -select_streams v:0 -show_entries stream_tags=rotate -of default=nw=1:nk=1 \"$INPUT_FILE\" 2>/dev/null || printf \"0\")\nROTATION_FILTER=\"\"\ncase \"$ROTATE_TAG\" in\n  90) ROTATION_FILTER=\"transpose=1,\" ;;\n  270) ROTATION_FILTER=\"transpose=2,\" ;;\nesac\n\n# Build crop filter\nCROP_FILTER=\"\"\nif [ \"$CROP_ENABLE\" = \"true\" ]; then\n  CROP_TOP_PCT=0\n  CROP_BOTTOM_PCT=0\n  \n  if [ \"$CROP_TOP_ENABLE\" = \"true\" ]; then\n    if [ -z \"${CROP_TOP_PERCENT:-}\" ]; then\n      CROP_TOP_PCT=$DEFAULT_CROP_TOP_PERCENT\n      echo \"CROP_TOP_PERCENT not set, using default: ${DEFAULT_CROP_TOP_PERCENT}%\" >&2\n    else\n      case \"$CROP_TOP_PERCENT\" in\n        ''|*[!0-9]*)\n          CROP_TOP_PCT=$DEFAULT_CROP_TOP_PERCENT\n          echo \"CROP_TOP_PERCENT invalid, using default: ${DEFAULT_CROP_TOP_PERCENT}%\" >&2\n          ;;\n        *)\n          CROP_TOP_PCT=$CROP_TOP_PERCENT\n          ;;\n      esac\n    fi\n  fi\n  \n  if [ \"$CROP_BOTTOM_ENABLE\" = \"true\" ]; then\n    if [ -z \"${CROP_BOTTOM_PERCENT:-}\" ]; then\n      CROP_BOTTOM_PCT=$DEFAULT_CROP_BOTTOM_PERCENT\n      echo \"CROP_BOTTOM_PERCENT not set, using default: ${DEFAULT_CROP_BOTTOM_PERCENT}%\" >&2\n    else\n      case \"$CROP_BOTTOM_PERCENT\" in\n        ''|*[!0-9]*)\n          CROP_BOTTOM_PCT=$DEFAULT_CROP_BOTTOM_PERCENT\n          echo \"CROP_BOTTOM_PERCENT invalid, using default: ${DEFAULT_CROP_BOTTOM_PERCENT}%\" >&2\n          ;;\n        *)\n          CROP_BOTTOM_PCT=$CROP_BOTTOM_PERCENT\n          ;;\n      esac\n    fi\n  fi\n  \n  TOTAL_CROP_PCT=$((CROP_TOP_PCT + CROP_BOTTOM_PCT))\n  \n  if [ \"$TOTAL_CROP_PCT\" -gt 0 ] && [ \"$TOTAL_CROP_PCT\" -lt 100 ]; then\n    KEEP_PCT=$((100 - TOTAL_CROP_PCT))\n    echo \"Crop settings: Top=${CROP_TOP_PCT}%, Bottom=${CROP_BOTTOM_PCT}%, Keeping=${KEEP_PCT}%\" >&2\n    CROP_FILTER=\"crop=in_w:in_h*${KEEP_PCT}/100:0:in_h*${CROP_TOP_PCT}/100,\"\n  elif [ \"$TOTAL_CROP_PCT\" -ge 100 ]; then\n    echo \"WARNING: Total crop percentage >= 100%, disabling crop\" >&2\n    CROP_FILTER=\"\"\n  fi\nfi\n\n# Mirror filter\nMIRROR_FILTER=\"\"\nif [ \"$MIRROR_ENABLE\" = \"true\" ]; then\n  MIRROR_FILTER=\"hflip,\"\nfi\n\n# Calculate input indices\nINPUT_INDEX=0\nOVERLAY_INDEX=1\nCAPTION_INDEX=\"\"\nRANDOM_INSERT_INDEX=\"\"\nOUTRO_INDEX=\"\"\n\nif [ \"$CAPTION_ENABLE\" = \"true\" ]; then\n  CAPTION_INDEX=2\n  NEXT_INDEX=3\nelse\n  NEXT_INDEX=2\nfi\n\nif [ -n \"$RANDOM_INSERT_FILE\" ]; then\n  RANDOM_INSERT_INDEX=$NEXT_INDEX\n  NEXT_INDEX=$((NEXT_INDEX + 1))\nfi\n\nif [ -n \"$OUTRO_FILE\" ]; then\n  OUTRO_INDEX=$NEXT_INDEX\nfi\n\n# Build main composition base\nif [ \"$CAPTION_ENABLE\" = \"true\" ]; then\n  BASE_FILTER=\"color=c=black:s=1080x1920:d=${EFFECTIVE_DURATION}[canvas]; \\\n[${OVERLAY_INDEX}:v]trim=duration=${INPUT_READ_DURATION},setpts=PTS-STARTPTS,scale=1080:-1,crop=1080:ih[top_video]; \\\n[${INPUT_INDEX}:v]trim=duration=${INPUT_READ_DURATION},setpts=PTS-STARTPTS,${ROTATION_FILTER}${CROP_FILTER}scale=1080:-1,${MIRROR_FILTER}format=yuv420p[bottom_video]; \\\n[canvas][top_video]overlay=0:0[bg_with_top]; \\\n[bg_with_top][bottom_video]overlay=(W-w)/2:H-h[layout_complete]; \\\n[layout_complete][${CAPTION_INDEX}:v]overlay=0:0,setsar=1,format=yuv420p,fps=${TARGET_FPS},setpts=PTS/${SPEED_FACTOR_N}[composed_main]\"\nelse\n  BASE_FILTER=\"color=c=black:s=1080x1920:d=${EFFECTIVE_DURATION}[canvas]; \\\n[${OVERLAY_INDEX}:v]trim=duration=${INPUT_READ_DURATION},setpts=PTS-STARTPTS,scale=1080:-1,crop=1080:ih[top_video]; \\\n[${INPUT_INDEX}:v]trim=duration=${INPUT_READ_DURATION},setpts=PTS-STARTPTS,${ROTATION_FILTER}${CROP_FILTER}scale=1080:-1,${MIRROR_FILTER}format=yuv420p[bottom_video]; \\\n[canvas][top_video]overlay=0:0[bg_with_top]; \\\n[bg_with_top][bottom_video]overlay=(W-w)/2:H-h,setsar=1,format=yuv420p,fps=${TARGET_FPS},setpts=PTS/${SPEED_FACTOR_N}[composed_main]\"\nfi\n\n# Assemble filter complex incrementally\nFILTER_LINES=\"\"\nappend_filter() {\n  if [ -z \"$FILTER_LINES\" ]; then\n    FILTER_LINES=\"$1\"\n  else\n    FILTER_LINES=\"${FILTER_LINES}; ${1}\"\n  fi\n}\n\nappend_filter \"$BASE_FILTER\"\n\n# Build the audio tempo chain for main audio\nAUDIO_TEMPO_CHAIN=\"\"\nif [ \"$SPEED_FACTOR_N\" != \"1.000000\" ]; then\n  export SPEED_FACTOR_N\n  AUDIO_TEMPO_CHAIN=$(python3 - <<'PY'\nimport os\ns = float(os.environ.get('SPEED_FACTOR_N','1'))\nif s <= 0:\n    print(\"atempo=1.0\")\nelse:\n    factors = []\n    tmp = s\n    while tmp > 2.0000001:\n        factors.append(2.0)\n        tmp = tmp / 2.0\n    while tmp < 0.5 - 1e-12:\n        factors.append(0.5)\n        tmp = tmp / 0.5\n    factors.append(round(tmp, 6))\n    out = \",\".join(f\"atempo={f:.6f}\" for f in factors)\n    print(out)\nPY\n)\n  echo \"AUDIO_TEMPO_CHAIN: $AUDIO_TEMPO_CHAIN\" >&2\nfi\n\n# ========== AUDIO HANDLING ==========\nAUDIO_FILTER=\"\"\nAUDIO_MAP=\"0:a?\"\n\n# NEW: Mix main audio with overlay audio FIRST (before random insert)\nif [ \"$OVERLAY_AUDIO_ENABLE\" = \"true\" ]; then\n  echo \"=== Mixing main audio with overlay audio at ${OVERLAY_AUDIO_VOLUME}% ===\" >&2\n\n  # Build base mixed audio (main + overlay) - use amerge with proper volume normalization\n  if [ -n \"$AUDIO_TEMPO_CHAIN\" ]; then\n    BASE_AUDIO_MIX=\"[0:a]atrim=duration=${INPUT_READ_DURATION},asetpts=PTS-STARTPTS,${AUDIO_TEMPO_CHAIN}[main_tempo]; \\\n[${OVERLAY_INDEX}:a]atrim=duration=${INPUT_READ_DURATION},asetpts=PTS-STARTPTS,volume=${OVERLAY_VOLUME_FLOAT}[overlay_vol]; \\\n[main_tempo][overlay_vol]amix=inputs=2:duration=longest:dropout_transition=2,volume=2[base_mixed]\"\n  else\n    BASE_AUDIO_MIX=\"[0:a]atrim=duration=${INPUT_READ_DURATION},asetpts=PTS-STARTPTS[main_a]; \\\n[${OVERLAY_INDEX}:a]atrim=duration=${INPUT_READ_DURATION},asetpts=PTS-STARTPTS,volume=${OVERLAY_VOLUME_FLOAT}[overlay_vol]; \\\n[main_a][overlay_vol]amix=inputs=2:duration=longest:dropout_transition=2,volume=2[base_mixed]\"\n  fi\n\n  AUDIO_FILTER=\"$BASE_AUDIO_MIX\"\n  MIXED_AUDIO_LABEL=\"[base_mixed]\"\nelse\n  # No overlay audio - just use main audio\n  if [ -n \"$AUDIO_TEMPO_CHAIN\" ]; then\n    AUDIO_FILTER=\"[0:a]atrim=duration=${INPUT_READ_DURATION},asetpts=PTS-STARTPTS,${AUDIO_TEMPO_CHAIN}[base_mixed]\"\n    MIXED_AUDIO_LABEL=\"[base_mixed]\"\n  else\n    MIXED_AUDIO_LABEL=\"0:a\"\n  fi\nfi\n\n# ========== RANDOM INSERT (video + audio) ==========\nif [ -n \"$RANDOM_INSERT_FILE\" ]; then\n  INSERT_DURATION=$(probe_duration \"$RANDOM_INSERT_FILE\" || printf \"2\")\n  INSERT_DURATION=$(awk -v v=\"$INSERT_DURATION\" 'BEGIN{ printf(\"%.3f\", v+0)}')\n  echo \"Random insert duration: $INSERT_DURATION seconds\" >&2\n\n  export EFFECTIVE_DURATION INSERT_DURATION\n  RANDOM_POS=$(python3 - <<'PY'\nimport os, struct\nefd = float(os.environ.get('EFFECTIVE_DURATION','0'))\nidur = float(os.environ.get('INSERT_DURATION','0'))\nminpos = 3.0\nmaxpos = efd - idur - 1.0\nif maxpos < minpos:\n    maxpos = minpos\nr = struct.unpack(\">I\", os.urandom(4))[0] / 4294967295.0\nv = minpos + r * (maxpos - minpos)\nprint(f\"{v:.3f}\")\nPY\n)\n  echo \"Random insert at: ${RANDOM_POS}s\" >&2\n\n  BEFORE_INSERT=$(awk -v p=\"$RANDOM_POS\" 'BEGIN{ printf(\"%.3f\", p) }')\n  NEW_DURATION=$(awk -v e=\"$EFFECTIVE_DURATION\" -v i=\"$INSERT_DURATION\" 'BEGIN{ printf(\"%.3f\", e+i) }')\n\n  # VIDEO insert\n  VIDEO_INSERT_BLOCK=\"[composed_main]fps=${TARGET_FPS},split=2[main1][main2]; \\\n[main1]trim=start=0:end=${BEFORE_INSERT},setpts=PTS-STARTPTS[seg1]; \\\n[main2]trim=start=${BEFORE_INSERT},setpts=PTS-STARTPTS[seg3]; \\\n[${RANDOM_INSERT_INDEX}:v]scale=1080:1920:force_original_aspect_ratio=decrease,pad=1080:1920:(ow-iw)/2:(oh-ih)/2,setsar=1,fps=${TARGET_FPS},setpts=PTS-STARTPTS[insert_scaled]; \\\n[seg1][insert_scaled][seg3]concat=n=3:v=1:a=0[concat_v]; \\\n[concat_v]fps=${TARGET_FPS}[final_v]\"\n\n  append_filter \"$VIDEO_INSERT_BLOCK\"\n\n  # AUDIO insert - split the mixed audio\n  if [ -n \"$AUDIO_FILTER\" ]; then\n    AUDIO_FILTER=\"${AUDIO_FILTER}; \\\n${MIXED_AUDIO_LABEL}asplit=2[mix1][mix2]; \\\n[mix1]atrim=start=0:end=${BEFORE_INSERT},asetpts=PTS-STARTPTS[a1]; \\\n[mix2]atrim=start=${BEFORE_INSERT},asetpts=PTS-STARTPTS[a3]; \\\n[${RANDOM_INSERT_INDEX}:a]asetpts=PTS-STARTPTS[insert_audio]; \\\n[a1][insert_audio][a3]concat=n=3:v=0:a=1[final_audio]\"\n  fi\n\n  EFFECTIVE_DURATION=\"$NEW_DURATION\"\n  AUDIO_MAP=\"[final_audio]\"\nelse\n  # No random insert - use the base mixed audio\n  if [ -n \"$AUDIO_FILTER\" ]; then\n    AUDIO_FILTER=\"${AUDIO_FILTER}; ${MIXED_AUDIO_LABEL}acopy[final_audio]\"\n    AUDIO_MAP=\"[final_audio]\"\n  else\n    AUDIO_MAP=\"${MIXED_AUDIO_LABEL}\"\n  fi\nfi\n\n# ========== OUTRO (video + audio) ==========\nif [ -n \"$OUTRO_FILE\" ] && [ -n \"$OUTRO_INDEX\" ]; then\n  OUTRO_START=$(awk -v d=\"$EFFECTIVE_DURATION\" -v t=\"$OUTRO_TRANSITION_DURATION\" 'BEGIN{ printf(\"%.3f\", d-t) }')\n\n  # VIDEO outro\n  if [ -n \"$RANDOM_INSERT_FILE\" ]; then\n    OUTRO_VIDEO_BLOCK=\"[${OUTRO_INDEX}:v]scale=1080:1920:force_original_aspect_ratio=decrease,pad=1080:1920:(ow-iw)/2:(oh-ih)/2,setsar=1,setpts=PTS-STARTPTS[outro_scaled]; \\\n[final_v]fps=${TARGET_FPS},setsar=1,setpts=PTS-STARTPTS[main_normalized]; \\\n[main_normalized]fps=${TARGET_FPS}[main_normalized_fps]; \\\n[outro_scaled]fps=${TARGET_FPS}[outro_scaled_fps]; \\\n[main_normalized_fps][outro_scaled_fps]xfade=transition=fade:duration=${OUTRO_TRANSITION_DURATION}:offset=${OUTRO_START}[final_v]\"\n    append_filter \"$OUTRO_VIDEO_BLOCK\"\n  else\n    OUTRO_VIDEO_BLOCK=\"[${OUTRO_INDEX}:v]scale=1080:1920:force_original_aspect_ratio=decrease,pad=1080:1920:(ow-iw)/2:(oh-ih)/2,setsar=1,setpts=PTS-STARTPTS[outro_scaled]; \\\n[composed_main]fps=${TARGET_FPS},setsar=1,setpts=PTS-STARTPTS[main_normalized]; \\\n[main_normalized]fps=${TARGET_FPS}[main_normalized_fps]; \\\n[outro_scaled]fps=${TARGET_FPS}[outro_scaled_fps]; \\\n[main_normalized_fps][outro_scaled_fps]xfade=transition=fade:duration=${OUTRO_TRANSITION_DURATION}:offset=${OUTRO_START}[final_v]\"\n    append_filter \"$OUTRO_VIDEO_BLOCK\"\n  fi\n\n  # AUDIO outro\n  if [ -n \"$AUDIO_FILTER\" ]; then\n    AUDIO_FILTER=\"${AUDIO_FILTER}; \\\n[${OUTRO_INDEX}:a]asetpts=PTS-STARTPTS[outro_a]; \\\n[final_audio][outro_a]concat=n=2:v=0:a=1[final_audio]\"\n  fi\n\n  OUTPUT_LABEL=\"[final_v]\"\nelse\n  if [ -n \"$RANDOM_INSERT_FILE\" ]; then\n    OUTPUT_LABEL=\"[final_v]\"\n  else\n    append_filter \"[composed_main]fps=${TARGET_FPS}[final_v]\"\n    OUTPUT_LABEL=\"[final_v]\"\n  fi\nfi\n\n# Final brightness application\nif [ \"$(awk -v b=\"$BRIGHTNESS\" 'BEGIN{ if (b==0) print \"0\"; else print \"1\" }')\" = \"1\" ]; then\n  append_filter \"[final_v]eq=brightness=${BRIGHTNESS}[final_v_out]\"\n  FINAL_OUTPUT_LABEL=\"[final_v_out]\"\nelse\n  FINAL_OUTPUT_LABEL=\"${OUTPUT_LABEL}\"\nfi\n\n# Combine all filters\nif [ -n \"$AUDIO_FILTER\" ]; then\n  COMPLETE_FILTER=\"${FILTER_LINES}; ${AUDIO_FILTER}\"\nelse\n  COMPLETE_FILTER=\"${FILTER_LINES}\"\nfi\n\n# Build input args\nINPUT_ARGS=\"\"\nif [ -n \"$TRIM_DURATION\" ]; then\n  INPUT_ARGS=\"-t ${INPUT_READ_DURATION} -i \\\"$INPUT_FILE\\\" -t ${INPUT_READ_DURATION} -i \\\"$MERGED_OVERLAY\\\"\"\nelse\n  INPUT_ARGS=\"-i \\\"$INPUT_FILE\\\" -i \\\"$MERGED_OVERLAY\\\"\"\nfi\n\nif [ \"$CAPTION_ENABLE\" = \"true\" ]; then\n  INPUT_ARGS=\"$INPUT_ARGS -i \\\"$CAPTION_PNG\\\"\"\nfi\n\nif [ -n \"$RANDOM_INSERT_FILE\" ]; then\n  INPUT_ARGS=\"$INPUT_ARGS -i \\\"$RANDOM_INSERT_FILE\\\"\"\nfi\n\nif [ -n \"$OUTRO_FILE\" ]; then\n  INPUT_ARGS=\"$INPUT_ARGS -i \\\"$OUTRO_FILE\\\"\"\nfi\n\n# Build final ffmpeg command\nCMD=\"ffmpeg -hide_banner -y -progress pipe:2 -loglevel warning $INPUT_ARGS -filter_complex \\\"${COMPLETE_FILTER}\\\" -map \\\"${FINAL_OUTPUT_LABEL}\\\"\"\n\nif [ -n \"$AUDIO_FILTER\" ]; then\n  CMD=\"$CMD -map \\\"${AUDIO_MAP}\\\"\"\nelse\n  CMD=\"$CMD -map ${AUDIO_MAP}\"\nfi\n\nCMD=\"$CMD -c:v libx264 -crf 23 -preset veryfast -c:a aac -b:a 192k -r ${TARGET_FPS} -aspect 9:16\"\n\nif [ -n \"$TRIM_DURATION\" ] && [ -z \"$OUTRO_FILE\" ]; then\n  CMD=\"$CMD -t ${EFFECTIVE_DURATION}\"\nfi\n\nCMD=\"$CMD \\\"$OUT_FILE\\\"\"\n\n# Debug output\necho \"=== DEBUG: filter_complex ===\" >&2\necho \"$COMPLETE_FILTER\" >&2\necho \"=== DEBUG: ffmpeg cmd ===\" >&2\necho \"$CMD\" >&2\n\n# Execute\necho \"Executing final render with overlay audio support...\" >&2\necho \"Progress will be shown below:\" >&2\n\nif timeout \"$FFMPEG_TIMEOUT\" sh -c \"$CMD\" < /dev/null; then\n  [ \"$CAPTION_ENABLE\" = \"true\" ] && rm -f \"$CAPTION_PNG\" || true\n  [ -n \"$MERGED_OVERLAY_TMP\" ] && [ -f \"$MERGED_OVERLAY_TMP\" ] && rm -f \"$MERGED_OVERLAY_TMP\" || true\n  [ -n \"$COMPOSED_MAIN_TMP\" ] && [ -f \"$COMPOSED_MAIN_TMP\" ] && rm -f \"$COMPOSED_MAIN_TMP\" || true\n  echo \"✅ Success! Output file: $OUT_FILE\" >&2\n  printf '%s\\n' \"$(basename \"$OUT_FILE\")\"\n  exit 0\nelse\n  echo \"❌ ERR: ffmpeg failed or timed out.\" >&2\n  echo \"Check the debug output above for details.\" >&2\n  exit 1\nfi"
      },
      "type": "n8n-nodes-base.executeCommand",
      "typeVersion": 1,
      "position": [
        448,
        -624
      ],
      "id": "f40867b3-9d0d-4e6a-8023-d530f6f8ff71",
      "name": "Asif"
    },
    {
      "parameters": {
        "mode": "raw",
        "jsonOutput": "{\n  \"waiting_captions\": {\n    \"trendy_casual\": [\n      {\n        \"id\": 1,\n        \"hindi\": \"इंतज़ार खत्म करो यार... 🤨\",\n        \"english\": \"End the wait, bro... 🤨\",\n        \"emoji\": \"🤨\"\n      },\n      {\n        \"id\": 2,\n        \"hindi\": \"अब बताओ भी... 👀\",\n        \"english\": \"Now tell me already... 👀\",\n        \"emoji\": \"👀\"\n      },\n      {\n        \"id\": 3,\n        \"hindi\": \"अरे भाई पॉइंट पे आओ! 😅\",\n        \"english\": \"Bro, get to the point! 😅\",\n        \"emoji\": \"😅\"\n      },\n      {\n        \"id\": 4,\n        \"hindi\": \"सस्पेंस मत बढ़ा यार... 🙃\",\n        \"english\": \"Don't increase the suspense... 🙃\",\n        \"emoji\": \"🙃\"\n      },\n      {\n        \"id\": 5,\n        \"hindi\": \"कब तक वेट करूं भाई? 🫠\",\n        \"english\": \"How long should I wait bro? 🫠\",\n        \"emoji\": \"🫠\"\n      }\n    ],\n    \"funny_relatable\": [\n      {\n        \"id\": 6,\n        \"hindi\": \"मैं: कब तक इंतज़ार करूं? 🥱\",\n        \"english\": \"Me: How long should I wait? 🥱\",\n        \"emoji\": \"🥱\"\n      },\n      {\n        \"id\": 7,\n        \"hindi\": \"POV: तू मजाक कर रहा है 😑\",\n        \"english\": \"POV: You're joking 😑\",\n        \"emoji\": \"😑\"\n      },\n      {\n        \"id\": 8,\n        \"hindi\": \"सब्र का फल मीठा होता है... पर मैं नमकीन हूं 🤷‍♂️\",\n        \"english\": \"Patience is sweet... but I'm salty 🤷‍♂️\",\n        \"emoji\": \"🤷‍♂️\"\n      },\n      {\n        \"id\": 9,\n        \"hindi\": \"मेरा इंतज़ार: 📈📈📈\",\n        \"english\": \"My waiting: 📈📈📈\",\n        \"emoji\": \"📈\"\n      },\n      {\n        \"id\": 10,\n        \"hindi\": \"ब्रो ये क्या चल रहा है? 🤨\",\n        \"english\": \"Bro what's going on? 🤨\",\n        \"emoji\": \"🤨\"\n      }\n    ],\n    \"short_punchy\": [\n      {\n        \"id\": 11,\n        \"hindi\": \"वेट कर रहा हूं... 👁️\",\n        \"english\": \"I'm waiting... 👁️\",\n        \"emoji\": \"👁️\"\n      },\n      {\n        \"id\": 12,\n        \"hindi\": \"देखते हैं... 🧐\",\n        \"english\": \"Let's see... 🧐\",\n        \"emoji\": \"🧐\"\n      },\n      {\n        \"id\": 13,\n        \"hindi\": \"हम्म... इंटरेस्टिंग 🤔\",\n        \"english\": \"Hmm... interesting 🤔\",\n        \"emoji\": \"🤔\"\n      },\n      {\n        \"id\": 14,\n        \"hindi\": \"क्या सीन है? 👀\",\n        \"english\": \"What's the scene? 👀\",\n        \"emoji\": \"👀\"\n      },\n      {\n        \"id\": 15,\n        \"hindi\": \"नेक्स्ट क्या होगा? 😬\",\n        \"english\": \"What will happen next? 😬\",\n        \"emoji\": \"😬\"\n      }\n    ],\n    \"engagement_boosters\": [\n      {\n        \"id\": 16,\n        \"hindi\": \"कमेंट में बताओ तुम्हें पता है क्या? 👇\",\n        \"english\": \"Tell me in comments if you know 👇\",\n        \"emoji\": \"👇\"\n      },\n      {\n        \"id\": 17,\n        \"hindi\": \"अगर पता है तो लाइक करो ✨\",\n        \"english\": \"If you know, like ✨\",\n        \"emoji\": \"✨\"\n      },\n      {\n        \"id\": 18,\n        \"hindi\": \"ये देख के मैं: 🫨\",\n        \"english\": \"Me after seeing this: 🫨\",\n        \"emoji\": \"🫨\"\n      },\n      {\n        \"id\": 19,\n        \"hindi\": \"रिलेटेबल? 🙋‍♂️\",\n        \"english\": \"Relatable? 🙋‍♂️\",\n        \"emoji\": \"🙋‍♂️\"\n      },\n      {\n        \"id\": 20,\n        \"hindi\": \"सेव करले बाद में देखना 📌\",\n        \"english\": \"Save it, watch later 📌\",\n        \"emoji\": \"📌\"\n      }\n    ],\n    \"genz_hinglish\": [\n      {\n        \"id\": 21,\n        \"hindi\": \"अरे ये क्या था भाई 💀\",\n        \"english\": \"What was that bro 💀\",\n        \"emoji\": \"💀\"\n      },\n      {\n        \"id\": 22,\n        \"hindi\": \"मैं fr fr वेटिंग 🫠\",\n        \"english\": \"I'm fr fr waiting 🫠\",\n        \"emoji\": \"🫠\"\n      },\n      {\n        \"id\": 23,\n        \"hindi\": \"नहीं नहीं ये नहीं हो सकता 😭\",\n        \"english\": \"No no this can't happen 😭\",\n        \"emoji\": \"😭\"\n      },\n      {\n        \"id\": 24,\n        \"hindi\": \"भाई सच में? 🤯\",\n        \"english\": \"Bro really? 🤯\",\n        \"emoji\": \"🤯\"\n      },\n      {\n        \"id\": 25,\n        \"hindi\": \"ये तो अनएक्सपेक्टेड था 😳\",\n        \"english\": \"This was unexpected 😳\",\n        \"emoji\": \"😳\"\n      }\n    ],\n    \"universal_minimal\": [\n      {\n        \"id\": 26,\n        \"hindi\": \"... 👀\",\n        \"english\": \"... 👀\",\n        \"emoji\": \"👀\"\n      },\n      {\n        \"id\": 27,\n        \"hindi\": \"💭\",\n        \"english\": \"Thinking 💭\",\n        \"emoji\": \"💭\"\n      },\n      {\n        \"id\": 28,\n        \"hindi\": \"देखो क्या होता है 🎬\",\n        \"english\": \"See what happens 🎬\",\n        \"emoji\": \"🎬\"\n      },\n      {\n        \"id\": 29,\n        \"hindi\": \"Wait for it... ⏳\",\n        \"english\": \"Wait for it... ⏳\",\n        \"emoji\": \"⏳\"\n      },\n      {\n        \"id\": 30,\n        \"hindi\": \"स्टोरी अभी बाकी है मेरे दोस्त 🎭\",\n        \"english\": \"The story is not over yet, my friend 🎭\",\n        \"emoji\": \"🎭\"\n      }\n    ]\n  },\n  \"top_recommendations\": [ \"इंतज़ार खत्म करो यार... 🤨\", \"अरे भाई पॉइंट पे आओ! 😅\", \"देखते हैं... 🧐\" ]\n}\n",
        "options": {}
      },
      "type": "n8n-nodes-base.set",
      "typeVersion": 3.4,
      "position": [
        0,
        -624
      ],
      "id": "ada2964d-967f-4b4f-ba3a-87b76f677a30",
      "name": "Edit Fields"
    },
    {
      "parameters": {
        "jsCode": "// Run once for all items\nconst wc = items[0].json.waiting_captions || {};\nconst groups = Object.values(wc);\nconst all = groups.flat();\nif (!all.length) {\n  return [{ json: { picked: null } }];\n}\nconst pick = all[Math.floor(Math.random() * all.length)];\nreturn [{ json: { picked: pick } }];\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        224,
        -624
      ],
      "id": "4c1bec9c-f1a9-411d-a85e-e0bed8d521f1",
      "name": "Code in JavaScript"
    }
  ],
  "origin": "n8n",
  "pinData": {},
  "repo": {
    "owner": "hellomdasif",
    "name": "n8n-backup"
  },
  "settings": {
    "executionOrder": "v1"
  },
  "shared": [
    {
      "createdAt": "2025-10-01T09:53:34.634Z",
      "updatedAt": "2025-10-01T09:53:34.634Z",
      "role": "workflow:owner",
      "workflowId": "aoDRD3R360qbLb78",
      "projectId": "COQIBF46Vn0bg2e3"
    }
  ],
  "staticData": null,
  "tags": [
    {
      "createdAt": "2025-10-07T12:15:31.199Z",
      "updatedAt": "2025-10-07T12:15:31.199Z",
      "id": "FPKsDlaKRbVBVjZv",
      "name": "EXECUTE FILES"
    }
  ],
  "triggerCount": 1,
  "updatedAt": "2025-10-22T16:09:26.000Z",
  "versionId": "2047c452-0c4a-4cdb-93f7-140026f01d3a"
}